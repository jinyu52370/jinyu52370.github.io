{"meta":{"title":"轨 道 兔","subtitle":"为我自己，为友与仇，人与兽，爱者与不爱者，<br>我希望这野草的朽腐，火速到来。","description":"\"回去吧，Colin，我并没有拯救你的人生，我只是拥抱了你的孤独。\"","author":"Jinyu","url":"http://jinyu.host","root":"/"},"pages":[{"title":"","date":"2022-08-07T07:23:42.887Z","updated":"2022-08-07T07:23:42.887Z","comments":true,"path":"verification.html","permalink":"http://jinyu.host/verification.html","excerpt":"","text":"verify_ce3316dd4bd79c70714e1e21c0a00267"},{"title":"分类","date":"2022-07-29T01:51:31.000Z","updated":"2022-08-07T07:23:42.868Z","comments":true,"path":"categories/index.html","permalink":"http://jinyu.host/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-29T01:49:29.000Z","updated":"2022-08-07T07:23:42.867Z","comments":true,"path":"about/index.html","permalink":"http://jinyu.host/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-28T12:10:39.000Z","updated":"2022-08-07T07:23:42.887Z","comments":true,"path":"tags/index.html","permalink":"http://jinyu.host/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-07-29T01:49:24.000Z","updated":"2022-08-07T07:23:42.887Z","comments":true,"path":"link/index.html","permalink":"http://jinyu.host/link/index.html","excerpt":"","text":""},{"title":"视频","date":"2022-07-28T12:10:39.000Z","updated":"2022-08-07T07:23:42.886Z","comments":true,"path":"life/movies/index.html","permalink":"http://jinyu.host/life/movies/index.html","excerpt":"","text":"测试测试"},{"title":"健身","date":"2022-07-28T04:39:56.000Z","updated":"2022-08-07T07:23:42.868Z","comments":true,"path":"life/fitness/index.html","permalink":"http://jinyu.host/life/fitness/index.html","excerpt":"","text":"测试测试"},{"title":"背景","date":"2022-07-31T01:54:20.000Z","updated":"2022-08-07T07:23:42.887Z","comments":true,"path":"setting/background/index.html","permalink":"http://jinyu.host/setting/background/index.html","excerpt":"","text":"todo 需要后端服务"},{"title":"音乐","date":"2022-07-28T12:09:33.000Z","updated":"2022-08-07T07:23:42.886Z","comments":true,"path":"life/music/index.html","permalink":"http://jinyu.host/life/music/index.html","excerpt":"","text":"测试测试"},{"title":"焦茶","date":"2022-07-30T04:24:09.000Z","updated":"2022-08-11T12:46:25.983Z","comments":true,"path":"life/gallery/焦茶/index.html","permalink":"http://jinyu.host/life/gallery/%E7%84%A6%E8%8C%B6/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-07-28T04:07:33.000Z","updated":"2022-08-07T07:23:42.868Z","comments":true,"path":"life/gallery/index.html","permalink":"http://jinyu.host/life/gallery/index.html","excerpt":"","text":"焦茶 aaa"}],"posts":[{"title":"并发编程锁之ReentrantLock总结","slug":"23579483-7206-449c-aa75-14d135b74afd","date":"2020-09-06T03:47:22.000Z","updated":"2020-09-06T03:47:22.000Z","comments":true,"path":"2020/09/06/23579483-7206-449c-aa75-14d135b74afd/","link":"","permalink":"http://jinyu.host/2020/09/06/23579483-7206-449c-aa75-14d135b74afd/","excerpt":"","text":"锁之前我讲过，在并发编程中一个比较难解决的就是共享资源并发访问控制问题。如果同步做的不好，很容易出现不一致问题，从而导致业务逻辑的错误；但是如果对共享资源控制的过于严格，又很容易对性能造成很大的影响。在并发编程中，一方面多从大牛的源码中学习精巧的思想和结构设计；另一方面要对并发基础知识掌握的足够牢固，你才能游刃有余的结合些设计模式、架构思想做出些高质量的高并发、高性能的系统。并发编程对设计模式、架构设计是非常依赖的，因此，并发编程对经验的积累、知识的积累方面要求是比较高的。 刚才说过，共享资源在并发访问中很容易造成不一致问题，解决方案就是我们所熟知的悲观锁和乐观锁。悲观锁就如其名字一样：悲观锁认为并发访问一定会导致状态不一致问题，所以在并发操作前一定要锁住资源，让并发线程一个接一个串行化去访问。而乐观锁就不一样了，乐观锁认为并发访问在大多数情况下是不会导致状态不一致问题，所以可以放心的去访问，一旦出现问题再说，本质上乐观锁是不会对共享资源添加锁限制的。这是我个人的理解，可能直白不是那么的精准，有关悲观锁、乐观锁的定义可以搜索更准确的官方解释。 我们来看看在Java中是如何实现悲观锁和乐观锁的。悲观锁在Java中就是我们所熟知的锁，实现方式主要分为两种：synchronized和Lock，而乐观锁的实现主要通过CAS操作实现。这里我们来比较下synchronized和Lock方式的大致差别：​ 1、synchronized主要依赖JVM底层实现，而Lock是通过编码方式实现，其实现方式差别还是比较大​ 2、synchronized由于其简单方便，只需要声明在方法、代码块上即可，主要是不需要关心锁释放问题，在一般的编程中使用量还是比较大的，但是在真正的并发编程系统中，Lock方式明显优于synchronized：​ a.在高版本JDK中，已经对synchronized进行了优化，synchronized和Lock方式在性能方面差别已不太明显​ b.synchronized最致命的缺陷是：synchronized不支持中断和超时，也就是说通过synchronized一旦被阻塞住，如果一直无法获取到所资源就会一直被阻塞，即使中断也没用，这对并发系统的性能影响太大了；Lock支持中断和超时、还支持尝试机制获取锁，对synchronized进行了很好的扩展，所以从灵活性上Lock是明显优于synchronized的 在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock(实现类ReentrantReadWriteLock)，ReentrantLock在锁的使用上算是非常普遍的，这一节我们就以ReentrantLock为例，分析下Lock实现方式。 ReentrantLockReentrantLock是一个可重入的互斥锁，所谓可重入是线程可以重复获取已经持有的锁。锁基本上都是要支持可重入性，否则很容易出现死锁问题。比如：假如锁B不支持可重入性，线程A在持有锁B的情况下再次获取锁B，由于不支持可重入性导致线程A被阻塞，知道锁B资源被释放，但是锁B资源是被线程A持有的，所以线程A永远无法因获取到锁B而被唤醒，这就导致了死锁问题。 ReentrantLock内部实现主要通过AbstractQueuedSynchronizer类实现的，AbstractQueuedSynchronizer是抽象类，在ReentrantLock类中有两个实现类：NonfairSync和FairSync，分别对应非公平锁和公平锁的实现。类结构关系如下： 12345678910111213 +-------------------------------+ | AbstractQueuedSynchronizer | +--------------^----------------+ | | +------------------------------+ | Sync | +--------^----------^----------+ | | | |+-----------------------+ +-----------------------+| NonfairSync | | FairSync |+-----------------------+ +-----------------------+ ReentrantLock类内部持有一个Sync类型的变量，主要实现基本上都是调用Sync的实现机制，默认构建的是NonfairSync，即非公平锁，也可以通过带Boolean类型的构造函数构建公平锁，源码如下： 12345678910111213/*** 1、默认创建的非公平锁，性能更高，等价于ReentrantLock(false)*/public ReentrantLock() &#123; sync = new NonfairSync();&#125;/*** @param fair true:公平锁 false:非公平锁*/public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 获取锁原理使用ReentrantLock时，一般流程大致为：1、调用lock()申请锁资源，申请成功则立即返回，如果申请不到则会阻塞直到申请成功；2、申请锁成功后，即可进行共享资源操作；3、共享资源操作完成，最后调用unlock()释放锁资源。 123456789/** * 1、获取锁，如果该锁没有被其它线程持有则立即返回，并设置该lock的hold count=1 * 2、如果当前线程已经持有该锁，则lock的count+1并立即返回 * 3、如果该锁被其它线程持有，则当前线程处于休眠直到获取锁，获取锁同时设置hold count=1 * 4、sync.lock()会调用Sync具体实现类NonfairSync、FairSync中的lock()*/public void lock() &#123; sync.lock();&#125; ReentrantLock.lock()源码非常简单，调用sync.lock()，这就体现了ReentrantLock核心机制都是在Sync中实现的，上面已说过ReentrantLock中的Sync中有两个子类分别对应公平锁和非公平锁，这里我们就来先看非公平锁NonfairSync的实现： 123456789101112131415161718/*** state在AbstractQueuedSynchronizer类中定义，表示当前锁状态：** 0：当前锁锁未被任何线程持有，线程获取锁资源时可以使用CAS原子操作compareAndSetState(0, 1)* 将state由0修改成1，修改成功表示获取锁成功，state这时被修改成1了，并将exclusiveOwnerThread设置成当前Thread，* exclusiveOwnerThread即表示持有锁的线程** &gt;0：表示当前锁被线程持有，因为ReentrantLock是重入锁，同一个线程可以重入多次锁，每重入一次state加1，* 同样在释放锁资源release()的时候，每释放一次state减1，直到state=0表示全部释放完成，可以被其它线程竞争使用* state大于0时CAS原子操作compareAndSetState(0, 1)会失败，即进入另一分支*/final void lock() &#123; if (compareAndSetState(0, 1)) //当前线程获取锁成功，并将当前线程赋值给exclusiveOwnerThread变量 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);//该分支则表示已有线程持有当前锁&#125; 这里的逻辑也很简单，通过一个CAS操作将state由0设置成1，成功则获取锁成功，并让Sync的exclusiveOwnerThread变量持有当前线程，供后续当前线程重入使用；如果CAS操作失败，则表示存在竞争，已有线程获取到锁，当前线程获取锁失败，需要进入acquire(1)分支。可以看到ReentrantLock的核心就是通过state字段的值判断是否被占用。 1234567891011121314151617/*** 1、调用tryAcquire尝试获取锁，注意：tryAcquire在AbstractQueuedSynchronizer类中实现直接抛出异常，一般是子类NonfairSync、FairSync继承重写该方法* 2、tryAcquire会做如下尝试：* a.如果state=0表示当前锁又没有被线程所持有，重新获取一次锁，成功返回true，失败返回false* b.如果持有锁的线程就是当前线程，则将state累加1，用于记录重入次数，释放的时候也要全部释放，并返回true表示获取锁成功* c.非以上两种情况，直接返回fasle* 3、如果获取锁成功，即tryAcquire返回true，则直接返回* 4、如果获取锁失败，即tryAcquire返回false，则将当前线程封装成Node放入到Sync Queue里(调用addWaiter)，等待Signal信号* 5、调用acquireQueued进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking)* 4、根据acquireQueued的返回值判断在获取lock的过程中是否被中断, 若被中断, 则自己再中断一下(selfInterrupt)*/public final void acquire(int arg) &#123; //acquireQueued的主要作用是把已经追加到队列的线程节点（addWaiter方法返回值）进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; AbstractQueuedSynchronizer中acquire()逻辑大致如下： 1、首先调用tryAcquire()，该方法的目的主要是：a.重新自旋一次获取下锁看看是否成功，成功则返回true；b.判断持有锁的线程是否就是当前线程，如果是的话，直接在state累加1，并返回true表示获取锁成功；c.如果上述两个目的都没有实现，则返回false，表示获取锁失败。注意：tryAcquire()在AbstractQueuedSynchronizer中是直接抛出异常，具体调用的是子类NonfairSync中的实现逻辑，源码如下： 1234567891011121314151617181920212223/*** 1、该方法重新获取锁state，如果state=0表示当前又没有线程持有该锁了，则重新获取一次锁，成功返回true，失败返回false* 2、如果持有该锁的线程就是当前线程，则也会返回true表示获取锁成功，并将state累加acquires* 3、否则返回false表示获取锁失败*/final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123;//如果等于0表示此刻已没有线程持有该锁，所以重新获取一次锁，成功则立即返回true，否则立即返回false if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125;else if (current == getExclusiveOwnerThread()) &#123; //如果持有该锁的线程就是当前线程，则将state+1，然后立即返回true表示获取锁成功，这是可重入锁特性 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc);//修改state值，此处只会持有锁的线程才会执行，不存在多线程竞争情况，所以通过setState修改，而非CAS，这段代码实现了偏向锁的功能 return true; &#125; return false;&#125; 2、如果tryAcquire()获取锁失败则执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)语句，首先我们来看下addWaiter(Node.EXCLUSIVE)，它的作用就是将无法获取锁的线程追加到一个双向链表中，然后让线程休眠，当锁资源可用时会从该双向链表头部唤醒一个线程去竞争锁资源，其源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*** 1、将无法获取锁的当前线程封装成Node加入到Sync Queue里面，其中参数mode是独占锁还是共享锁，null表示独占锁。如果是读写锁mode就为共享锁模式* 2、Sync Queue实现的一个双向链表，包含head和tail分别指向头部和尾部Node，head和tail设置为了volatile,这两个节点的修改将会被其他线程看到,主要是通过修改这两个节点来完成入队和出队* 3、当新加入Node时，将tail指向新加入的Node，同时之前的Node的next指向新Node，新Node的pre指向之前的tail节点，即在双向链表上添加节点成功* 4、总而言之，addWaiter的目的就是通过CAS把当前线程封装的Node追加到队尾，并返回该Node实例。* 5、把线程要包装为Node对象的主要原因：* a.构造双向链表时，需要指针前驱节点和后驱节点* b.Node中mode用于区分是否是排它模式还是共享模式* c.Node中的waitStatus用于表示当前线程状态： SIGNAL(-1) ：线程的后继线程正/已被阻塞，当该线程release或cancel时要重新唤醒这个后继线程 CANCELLED(1)：因为超时或中断，该线程已经被取消，其前驱节点释放锁后不会让处于该种状态的线程去竞争锁资源 CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了Condition.await而被阻塞 PROPAGATE(-3)：传播共享锁 0：0代表无状态，默认Node就是该种状态，当存在后驱节点追加，就去把其前驱节点设置成SIGNAL*/private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); Node pred = tail; if (pred != null) &#123;//默认head = tail = null, tail !=null说明队列中已经有节点,直接CAS到尾节点 /** * 将当前Node追加到Queue尾部： * 1、将当前node的前驱节点设置成tail节点 * 2、通过cas操作将tail指针指向当前node * 3、并将之前的tail节点的next指向当前node * 通过上面三步骤，即将一个node追加到双向链表的尾部 */ node.prev = pred; if (compareAndSetTail(pred, node)) &#123;//4.CAS node到tail pred.next = node; return node; &#125; &#125; enq(node);//执行到这里，表明Queue队列为空,调用enq会初始化队列并将当前node追加到尾部 return node;&#125;/*** 1、这里通过一个死循环方式调用CAS，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾* 2、第一次循环tail肯定为null，则会初始化一个默认的node，并将head=tail指向该node* 3、第二次循环的时候，会将当前node追加到1中创建的node尾部*/private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; //1.队列为空,初始化一个dummy节点,其实和ConcurrentLinkedQueue一样 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 3、addWaiter(Node.EXCLUSIVE)将当前线程封装的Node节点添加到等待锁资源的Queue上后，接下来要执行acquireQueued()，该方法是获取锁逻辑比较核心的一个方法，关键点有如下几个：​ a.该方法被设计成了一个无限for循环，只有满足通过tryAcquire()获取到锁时才会退出该循环，当然如果没有获取到锁也不会一直在for循环中进行空循环，而是通过parkAndCheckInterrupt()让线程休眠，当线程被唤醒后才会执行一次for循环看是否可以获取锁，获取成功则会将Queue的head指针指向当前thread，并将之前head废弃​ b.在tryAcquire()竞争锁资源时，会存在p &#x3D;&#x3D; head判断，判断当前线程的前驱节点是否是head节点，只有前驱是head节点的线程才有资格调用tryAcquire()去竞争锁资源，这个设计思想逻辑主要是：申请锁资源失败的线程会依次加入到Queue中，head指向头部，tail指向尾部，如果head不为空，则该节点代表的线程为锁的占有者，当该线程释放锁时，它会唤醒它的后驱节点，而不是Queue中所有线程，因此，每次释放锁时只会唤醒一个线程，唤醒顺序也是从head到tail依次唤醒，而不是存在锁资源时一起唤醒然后竞争锁资源，因为这样如果存在几百几千个线程，同时竞争锁资源对系统性能损耗很大，有效的避免性能风暴​ c.该方法在让线程真正休眠前会让线程再次自旋一次获取锁，如果还是失败则立即进入休眠状态，作者这么设计就体现了：让线程休眠还是比较耗费性能资源的，涉及到上下文切换，另外当线程唤醒时可能会被分配到其它CPU上执行，由于高速缓存L1、L2是CPU独有的，就会降低高速缓存命中率，对性能影响还是比较大的，因此能尽量不休眠就不会让线程休眠​ d.当有线程释放锁时，会唤醒Queue头部线程的后驱节点，唤醒后依然要竞争锁，竞争的对象是刚申请锁资源还没有进入到Queue等待队列的线程们，如果竞争失败则再次进入休眠状态，这就体现了非公平锁的特性，这么设计的目的：主要从性能考虑，如果新申请锁的线程可以立即获取到锁，避免了后续一系列创建Node、添加Node到队列等一些列操作，而从Queue中唤醒的线程没有申请到锁只是重新进入休眠，代价要小很多，同时让它们一起竞争锁资源避免Queue等待队列中的线程一直无法获取锁而被饿死情况 123456789101112131415161718192021222324252627282930313233343536373839404142/*** 1、该方法是一个无限死循环，只有保证前驱节点就是头节点，并且重新调用一次tryAcquire()获取锁并成功，才会推送该循环* 2、否则会执行shouldParkAfterFailedAcquire()将当前node的前驱节点的waitStatus设置成SIGNAL，表示当它的前驱节点释放锁后会唤醒当前线程，然后当前线程就可以放心的让自己休眠了* 3、调用shouldParkAfterFailedAcquire()时，由于默认前驱节点的waitStatus不等于SIGNAL，所以会将前驱节点设置成SIGNAL，但是注意这时的返回结果是false，表示并不会立即让当前线程进入休眠状态，而是重新执行一次for循环，相当于给了一次重新获取锁的机会，如果获取锁成功，则将head节点指向当前节点，之前头结点就废弃了；如果获取失败则调用parkAndCheckInterrupt()让线程真正进入休眠状态4、parkAndCheckInterrupt()中调用LockSupport.park()让当前线程休眠，客户端也就进入阻塞状态，注意这里有个关键点：当休眠状态的线程被唤醒后，需要再次执行一次for循环通过tryAcquire()来竞争锁资源，竞争成功则退出当前for循环，当然也有可能会竞争失败，如果竞争失败会再次进去休眠状态** Queue队列中的线程是按照从头到尾部的顺序依次唤醒的，每次只会唤醒Queue中的一个线程，为什么还会出现竞争呢？这是因为虽然从Queue中只会唤醒一个线程，但是假如同时又有一个线程执行lock来获取锁资源，而此时并没有放入Queue等待队列中，它就会和从Queue中唤醒的线程进行竞争锁资源，这就体现了非公平锁的特性：后申请锁资源的线程可能会比先申请锁资源的线程优先申请到锁资源。* 为什么要这么设计呢？* 主要从性能考虑，如果新申请锁的线程可以立即获取到锁，避免了后续一系列创建Node、添加Node到队列等一些列操作，而从Queue中唤醒的线程没有申请到锁只是重新进入休眠，代价要小很多,同时让它们一起竞争锁资源避免Queue等待队列中的线程一直无法获取锁而被饿死情况*/final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //1.获取当前节点的前驱节点 final Node p = node.predecessor(); //2.判断前驱节点是否是head节点(前继节点是head, 存在两种情况： // a.前继节点现在占用lock // b.前继节点是个空节点,已经释放lock,node现在有机会获取lock; 则再次调用tryAcquire尝试获取一下锁，该源码之前已经分析过 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node);//3.获取lock成功,直接设置新head(原来的head可能就直接被GC回收) p.next = null; // help GC failed = false; return interrupted;//4.返回在整个获取的过程中是否被中断过；若整个过程中被中断过,则最后我在自我中断一下(selfInterrupt),因为外面的函数可能需要知道整个过程是否被中断过 &#125; //shouldParkAfterFailedAcquire(p, node)返回当前线程是否需要挂起，如果需要则调用parkAndCheckInterrupt()让当前线程休眠 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())//6.parkAndCheckInterrupt会把当前线程挂起，从而阻塞住线程的调用栈,返回值判断是否这次线程的唤醒是被中断唤醒 interrupted = true; &#125; &#125; finally &#123; if (failed)//7.在整个获取中出错 cancelAcquire(node);//8.清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除) &#125;&#125;private final boolean parkAndCheckInterrupt() &#123; //利用LockSupport的park方法来挂起当前线程的，直到被唤醒。 LockSupport.park(this); return Thread.interrupted();&#125; 看到这里，基本上对ReentrantLock非公平锁获取锁资源的流程有一个比较清晰的认识了。公平锁和非公平锁流程基本一致，区别只是在tryAcquire()获取锁逻辑的差别，具体如下： 12345678910111213141516171819FailSync类中的tryAcquire()获取锁逻辑：protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125;else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 可以看到，当锁资源可用(state&#x3D;0)并且当Queue队列中不存在等待锁资源的线程时，才会通过cas操作将state由0设置成1，表示申请锁资源成功，否则都将加入到Queue队列的尾部。对比非公平锁获取锁资源逻辑nonfairTryAcquire()，差别主要是：非公平锁只要判断锁资源可用就会立即通过cas操作获取锁资源，而公平锁则会在锁资源可用的情况下，还要满足Queue队列中无等待锁资源线程才能立即申请锁资源，否则会被追加到Queue队列的尾部，这就体现了公平特性。 上面已经将ReentrantLock.lock()获取锁的流程基本都 分析完成，当然ReentrantLock还提供lockInterruptibly()、tryLock()、tryLock(long timeout, TimeUnit unit)等，如果对lock()逻辑比较清楚，这些方式获取锁的原理就比较简单了，下面大致说下。 ReentrantLock.lockInterruptibly()：可中断方式获取锁，通过之前源码分析，线程如果没有获取到锁，会通过LockSupport.park()方式休眠，当锁资源释放时，其它线程调用Lock.unpark()唤醒休眠线程去竞争锁资源，但是LockSupport.park()休眠的线程也可以通过中断方式进行唤醒，可中断锁就是在唤醒时候判断如是中断唤醒，则直接抛出异常，而lock()方式获取的锁使用中断唤醒后直接去竞争锁资源了，竞争不到直接休眠，这就是它们的差别，具体实现看源码： 123456789101112131415161718192021private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())//进入阻塞状态，阻塞解除时，返回true表示中断方式唤醒 throw new InterruptedException();//中断唤醒时，不会去竞争锁资源，而是直接抛出异常 &#125; &#125; finally &#123; if (failed) cancelAcquire(node);&#125; ReentrantLock.tryLock()：可尝试性获取锁，获取到返回true，获取不到直接返回fasle，而不会阻塞，实现方式就更简单了，直接nonfairTryAcquire()获取锁，获取到立即返回true，获取不到立即返回false，而不是添加到Sync Queue阻塞队列中去等待。 ReentrantLock.tryLock(long timeout, TimeUnit unit)：会尝试一段时间，这段时间都无法获取锁就返回false 1234567891011121314151617181920212223242526272829303132private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; final long deadline = System.nanoTime() + nanosTimeout;//超时时间 //加入到Sync Queue，这里主要是性能优化，下面获取锁的逻辑在for无线循环中，如果超时时间设置较长 //一直无线循环下去肯定浪费CPU资源，所以会进行休眠，等待前驱节点释放锁时会唤醒该线程 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L)//如果超时，直接返回false，表示获取锁失败 return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)//如果超时时间现在大于1000纳秒，就会进入休眠，否则就不停的for循环，因为超时时间太短，没必要进行休眠，比较休眠还是比较耗费资源的 LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted())//可响应中断的，如果中断则会抛出异常 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 总结通过上面对ReentrantLock源码分析，Lock机制的核心就是通过cas原子操作state属性，state&#x3D;0表示锁资源可用，获取锁就是通过cas原子操作将state从0设置成1，成功就表示获取锁成功，如果state&gt;0,cas操作将会失败，即表示锁已被占用，当前获取锁失败。获取锁失败，根据是否是可中断、可超时等特性，处理的逻辑不太一致，但大致为：​ 1、将获取锁失败的线程封装成Node，封装成Node一方面是要构建双向队列，另一方面是Node中额外添加状态信息对节点进行控制​ 2、在一个for无线循环中通过Lock.park()让线程休眠，当有锁资源被释放发生时，会从队列头到尾的顺序依次唤醒线程(会跳过CANCELLED标记的节点，因为这些节点代表的线程已经无效了)，注意这里只会唤醒一个线程，唤醒的线程只表示该线程具有竞争锁资源的资格，还需要和新申请但还没有放入到Queue中的线程进行竞争该锁资源，这就是非公平锁的特性，这样设计主要是从性能方面考虑，如果竞争成功则退出for循环返回，否则继续进入休眠状态 最后再通过一个大致流程图，对整体的执行流程有个更清晰认识。 释放锁原理接下来我们来分析下ReentrantLock释放锁资源的流程。释放锁没有区分公平和非公平的，主要的工作就是减小state的值，当state等0的时候，释放锁并唤醒Queue中其他线程来获取锁。 123public void unlock() &#123; sync.release(1);&#125; release()是在AbstractQueuedSynchronizer中实现的， 123456789101112131415161718192021222324252627282930313233343536373839 /** * Releases in exclusive mode. Implemented by unblocking one or * more threads if &#123;@link #tryRelease&#125; returns true. * This method can be used to implement method &#123;@link Lock#unlock&#125;. * * @param arg the release argument. This value is conveyed to * &#123;@link #tryRelease&#125; but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from &#123;@link #tryRelease&#125; */ public final boolean release(int arg) &#123; //tryRelease:尝试释放状态，返回true表示锁资源释放完成， if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; /*** 1、只有持有该锁的线程才会执行tryRelease()，因此不会涉及到多线程问题，不需要使用cas保证原子性* 2、调用该方法会将state-1，然后判断state值，如果等于0表示当前线程已经释放锁资源完成，返回true，* 并将exclusiveOwnerThread设置成null，表示当前锁资源空闲，未被线程占用* 3、如果state&gt;0，则表示当前并未释放完全，返回false*/protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123;//只有state=0表示该锁被所有线程都释放完成，即锁可以被其它线程占用了，否则只是释放一次重入次数，并不会释放锁 free = true; setExclusiveOwnerThread(null); &#125; setState(c);//不存在并发问题，采用setState()而非cas操作，提供性能 return free;&#125; 深入分析上面通过源码已经对ReentrantLock获取锁和释放锁的大致流程有了比较清晰的认识，当你越深入分析时你会对Doug Lea这位大牛构思和多线程并发处理的游刃有余感到惊叹，以及后面我们会讲到的IO模型，依然会有Doug Lea大牛的精彩大作，如果你对他还不了解，可以多搜索关注下。 了解了流程并不一定就表示你已经完全熟悉ReentrantLock，你知道他是这么做的，但是你不一定清楚他这么做背后的考量是什么，毕竟并发编程比单线程编程复杂性高出太多，你很难顾及到所有线程分支运行的流程，这就是很容易导致bug的根源。上面我们已经分析过addWaiter()这个方法的作用，下面通过该方法进行更深入的分析，希望对并发编程的认识更加深刻。 addWaiter()方法主要完成工作：将未获取锁的线程封装成Node，然后追加到等待队列Queue尾部，等待队列Queue并不存在一个定义好的数据结构，而是通过head、tail、next和prev模拟出的具有出队、入队操作的双向链表。追加当前节点到双向链表尾部关键源码如下： 12345node.prev = pred;if (compareAndSetTail(pred, node)) &#123;//4.CAS node到tail pred.next = node; return node;&#125; 将上面代码梳理一下，大致分为三个步骤：​ 1、将当前node的prev指向tail节点；​ 2、通过cas原子操作将tail指针指向当前节点；​ 3、将之前tail节点的next指向当前节点。 示意图如下： 假如将追加节点的三个步骤顺序调换下，先将tail节点的next指向当前节点，然后cas原子修改tail指向，最后再来修改当前节点的prev指向，即将上面的1和3对调一下，会出现上面情况呢？ 将tail节点的next指向当前节点操作后，紧接着会执行cas操作修改tail指向当前节点，由于存在多线程并发问题，即可能会存在多个线程同时申请锁资源，假如现在t1、t2两个线程都同时做上面两个步骤：​ 1、t1线程修改next后，紧接着t2线程也修改next指向，导致会把t1修改的指向覆盖；​ 2、这时t1线程做cas替换tail指向成功后，t2也来做cas操作就会失败；​ 3、t1由于cas操作成功，最后修改prev指向 可以发现，由于并发导致追加的t1节点是存在问题的，正常情况下Node1的next应该指向t1节点，但是却被t2节点覆盖了。所以，1和3对调是在并发下是存在问题的。 假如1和2对调，先进行cas操作，然后修改prev，最后再来修改next又会怎么样呢？首先通过cas原子操作将tail指向当前节点，示意图如下： tail节点这时还是孤立的节点，prev和next都还没有指向，tail节点和其它节点之间没有关联了，这时如果其它线程需要遍历这个双向链表就比较危险了，比如释放锁时会调用unparkSuccessor()，其源码如下： 123456789101112131415161718private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //获取当前节点的后继节点，如果满足状态，那么进行唤醒操作 // 如果没有满足状态，从尾部开始找寻符合要求的节点并将其唤醒 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123;//s.waitStatus&gt;0表示当前线程已被CANCELLED，不需要唤醒 s = null; //从tail向前查找，知道找到waitStatus&lt;=0的线程，赋值给s for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //队列的维护（首节点的更换）是依靠消费者（获取时）来完成的，也就是说在满足了自旋退出的条件时的一刻，这个节点就会被设置成为首节点。 if (s != null) LockSupport.unpark(s.thread);&#125; 会发现其可能会存在一个从tail向前查找的流程，假如刚好这时执行这个流程，从tail向head查找节点显然就会存在问题，所以1和2对调的流程在并发下也是存在问题的。unparkSuccessor()在查找head的下一个有效节点的时候，没有从head到tail方向查找，而是反方向从tail向head查找，正常逻辑肯定是从head向tail方向查找速度更快，但是为啥反其道而行呢？如果你只看这段代码是永远看不出问题的，具体原因可以参加下面正常流程分析情况。 错误的顺序我就不一一举例了，大致都是差不多，现在我们来分析下为什么源码中这个顺序执行在并发下就不会存在问题。现在假设两个线程同一时间都没有获取到锁，都需要追加到Sync Queue队列尾部，大致流程如下：​ 1、线程t1的节点设置prev指向tail，线程t2节点同时也设置prev指向tail，这时就不会出现上面如果先设置next就会导致后设置把之前设置覆盖情况，因为如果先设置next是对Node1进行操作，存在多个线程对Node1同时操作导致状态不一致问题，而如果这里先设置prev，操作对象时线程本身的节点，是不存在多线程并发问题，示意图如下： 2、这时t1和t2都进行cas原子操作，反正会有一个线程会操作成功，假如是t1线程操作成功，然后就可以顺利的设置Node1节点的next指向t1，因为只会存在一个线程操作成功，所以对Node1的操作此时也不会存在并发问题，由于t1的cas操作成功导致t2线程进行cas操作必然失败，此刻示意图如下： 3、由于t2线程cas操作失败，因此不再继续操作Node1的next指向自己，而是进入enq()方法中，其源码如下，enq方法中通过cas+无限循环方式保证t2节点一定会被追加到Sync Queue尾部的，每次循环都是重新获取最新的tail，然后将t2的prev指向这个最新的tail，然后通过cas操作将tail指向自己，最后在将之前tail节点的next指向t2节点，这个案例中获取的最新tail就是t1节点了，所以t2节点会被追加到t1节点后，这样就能保证即使在高并发下依然可以实现节点正常添加，而不会像之前出现状态不一致情况，示意图如下： 1234567891011121314151617181920/*** 1、这里通过一个死循环方式调用CAS，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾* 2、第一次循环tail肯定为null，则会初始化一个默认的node，并将head=tail指向该node* 3、第二次循环的时候，会将当前node追加到1中创建的node尾部*/private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; //1.队列为空,初始化一个dummy节点,其实和ConcurrentLinkedQueue一样 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 4、上面分析unparkSuccessor()在查找head的下一个有效节点的时候，没有从head到tail方向查找，而是反方向从tail向head查找，如果你对我刚才分析得到逻辑理解透彻的话，就比较好解释了。比如：t1设置prev指向Node1，然后cas操作将tail指向了t1，这时Queue的结构如下，假如这时候执行unparkSuccessor()，Node0查找它的后驱节点为Node1，假如Node1是无效节点，Node1需要继续查找它的后驱节点，但是这时Node1的next并没有设置，是无法查找到的，所以必须从tail向head方向查找才行。 通过对addWaiter的深入分析，你会对并发编程的难度有一个更加深刻的认识，真是处处要小心，搞不好就掉坑里面去了，但是Doug Lea巧妙的构思处理的游刃有余。 至此，对ReentrantLock也有了一个比较完整的流程分析，这一节也就结束了，后面会对Lock的其它实现类及synchronized的底层实现机制进行些分析。 本文作者： zhang 本文链接： http://blog.reactor.top/2018/01/31/并发编程锁之ReentrantLock总结/ 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"锁","slug":"锁","permalink":"http://jinyu.host/tags/%E9%94%81/"},{"name":"并发","slug":"并发","permalink":"http://jinyu.host/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"多线程","permalink":"http://jinyu.host/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"并发编程锁之synchronized总结","slug":"afd8c681-d4f8-4655-bafa-4a958d92d4df","date":"2020-09-01T23:03:02.000Z","updated":"2020-09-01T23:06:09.000Z","comments":true,"path":"2020/09/02/afd8c681-d4f8-4655-bafa-4a958d92d4df/","link":"","permalink":"http://jinyu.host/2020/09/02/afd8c681-d4f8-4655-bafa-4a958d92d4df/","excerpt":"","text":"锁synchronized并发编程中数据同步需要依赖锁进行控制，上篇博文通过ReentrantLock源码分析也对Lock实现锁机制的大致原理有了一个了解，Lock主要是通过编码的方式实现锁，其核心就是：CAS+循环，CAS原子操作需要依赖底层硬件层特殊的CPU指令。这节我们来看下Java中另一种非常常见的实现同步的方式：synchronized。synchronized主要通过底层JVM进行实现，而且JVM为了优化，产生偏向锁、轻量级锁、重量级锁，由于其处于JVM底层实现中，对很多并发编程人员来说能清晰理解它们间的区别还是件困难的事。通过本篇博文，构建出对Java中锁得体系结构，让你对其有个更系统全面的认知。 synchronized实现同步主要分为两种情况：​ 1、同步方法：synchronized方法则会被翻译成普通的方法调用，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位设置成1，表示该方法是同步方法，当某个线程要访问某个方法的时候，使用调用该方法的对象(普通方法同步)或该方法所属的Class在JVM的内部对象表示Klass做为监视器锁(静态方法同步，全局锁)，这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放​ 2、同步代码块：对于同步代码块，JVM采用monitorenter、monitorexit两个指令来实现同步。monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应，这样就保证了执行monitorexit指令的线程是monitor监视器的所有者。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取栈顶对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将栈顶对象锁计数器减1，当计数器为0时，锁就会被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 对于同步方法或同步块，通过Class文件中的access_flags或monitorenter、monitorexit指令来标记执行这些代码时需要进行同步，但是具体如何进行同步呢？这就是接下来要分析的主要内容。再讲解同步之前，我们先来看下对象头，因为JVM中synchronized的实现关键就涉及到对象头的操作。 对象头Java中对象的内存布局主要分为三个区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。synchronized的实现方式依赖于对象头，所以，这里我们先来简单介绍下Java中对象头。 实例数据区主要是实例属性数据存储区域，对齐填充在HotSpot中主要采用8字节对齐方式，对象头和实例数据区字节数不是8的倍数，采用对齐填充方式让其等于8的倍数。这里来看下对象头，如果是数组类型，其由MarkWord、length(数组长度)和Pointer，Pointer是指向该对象的元数据信息，即该对象的Class实例，对象的方法定义都是在Class实例中；如果是非数组类型，对象头只包含：MarkWord和Pointer两部分。 对象头具体描述如下：1、如果是数组类型，则使用3个字宽存储对象头，如果是对象非数组类型，则使用2个字宽，在32位JVM中，一个字宽等于4字节，而64位JVM中，一个字宽等于8字节，即在32-bit JVM上对象头占用8bytes，在64-bit JVM上对象头占用16bytes（开启指针压缩后占用4+8&#x3D;12bytes）2、64位机器上，数组对象的对象头占用24 bytes，启用压缩之后占用16 bytes。之所以比普通对象占用内存多是因为需要额外的空间存储数组的长度，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。3、HotSpot虚拟机的对象头包括两部分信息：Mark Word(标记字段)和Klass Pointer(类型指针)4、Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等5、对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot 虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示： 上图展示的是32位机器下对象头的情况，64位情况下原理大致一样而且更简单，这里就不再介绍了。 MarkWord里默认数据是存储对象的hashcode等信息，但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式，当对象成为锁(被锁住)后，对象头里的MarkWord字段就会存储Monitor信息，Monitor信息可以理解为锁信息。 锁的状态可分为四种：无锁状态、偏向锁、轻量级锁和重量级锁，其实现原理要依赖对象头进行控制。再了解对象头的基础上，下面我们就可以分析每种锁的实现原理。 锁分类早期，synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依赖于底层的操作系统互斥Mutex Lock来实现的，而操作系统实现线程之间的阻塞、调度、唤醒等操作时需要从用户态切换到内核态，最后再由内核态切换到用户态，将CPU的控制权交由用户进程，用户态与内核态之间频繁的切换，严重影响锁的性能，这也是为什么早期的synchronized效率低的原因。 在Java 6之后Java官方对从JVM层面对synchronized进行较大优化，所以现在的synchronized锁效率也优化得很不错了，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁、轻量级锁和自旋锁等概念，下面就来分析下它们的原理。 轻量级锁轻量级锁实现的背后基于这样一种场景假设：在真实生产环境下，我们程序中的大部分同步代码一般都处于无锁竞争状态，轻量级锁主要解决如下场景：线程A和线程B都要访问对象o的同步方法，但是它们之间不会同时访问，线程A访问完成后线程B再去访问，它们之间访问类似于交替访问，因此，这种情况下并不会产生锁竞争问题。在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，只需要依靠CAS原子指令就可以完成锁的获取及释放，但是当检测到存在锁竞争的情况下，轻量级锁就会膨胀为重量级锁。 下面通过如下同步代码块分析下轻量级锁实现的大致流程： 1234public class Obj &#123; public synchronized void fun1()&#123; &#125;&#125; 1、当代码进入同步块时，即调用Obj.fun1()方法，当Obj实例为无锁状态，即对象头的锁标志位为01，当前线程会在栈帧中创建一个锁记录(Lock Record)，同时将锁对象Obj的对象头中MarkWord拷贝到锁记录中，因为栈是线程私有的，Java方法的调用就是通过栈帧得到入栈和出栈实现的，所以将锁记录保存到栈帧中，这一步主要完成MarkWord拷贝过程； 2、将MarkWord拷贝到Lock Record中完成后，尝试使用CAS将MarkWord更新为指向锁记录的指针，如果更新成功，当前线程就获得了锁，同时更新锁标志位为00，表示当前对象处于轻量级锁状态 3、更新失败情况主要如下：比如有两个线程A和线程B同时竞争锁，执行步骤1时由于当前对象处于无锁状态，所以这两个线程都会在它们的栈帧中创建Lock Record，然后将对象头中的MarkWord拷贝进去，然后它们都同时进入步骤2执行CAS原子操作将对象头中的锁指针指向自己栈帧中的Lock Record，所以，肯定有一个成功，另一个就会失败，成功的就是获取到偏向锁的线程，失败的就是没有获取偏向锁的线程。如果更新失败，JVM会先检查锁对象的MarkWord是否指向当前线程的锁记录，如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块，这是重入锁特性，不是则说明其有其它线程抢占了锁 4、其它线程抢占了锁，说明存在锁竞争情况，这时轻量级锁并不为立即膨胀为重量级锁，而是进入自旋模式，自旋模式期间还是无法获取锁，就会膨胀为重量级锁，大致思路：尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有非常重要的性能提高。 为什么要进入自旋模式原因？ 膨胀为重量级锁会涉及到有用户态切换到内核态进行线程的休眠和唤醒操作，然后再切换到用户态，这些操作给系统的并发性能带来了很大的压力，共享数据的锁定状态可能只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后面请求锁的那个线程”稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只需要让线程执行一个忙循环（自旋），所以自旋会对CPU造成资源浪费，特别是长时间无法获取锁的情况下，所以自旋次数一定要设置成一个合理的值，而不能无限自旋下去。JDK1.6默认是开启了自旋锁功能，而且对自旋次数也不在是固定值，而是通过一套优化机制进行自适应，简化了对自旋锁的使用。 注意：自旋在多处理器上才有意义，这理解也很简单：自旋是不会释放CPU资源的，在单处理器上如果某个线程处于自旋状态，也就意味着没有其它线程处于同时处于运行状态，也就在自旋期间不可能存在线程释放锁资源。所以，单处理上自旋是没有意义的，不过现在服务器一般不可能运行在单处理器上。 5、如何膨胀为重量级锁呢？​ a.步骤4中在自旋模式下依然无法获取锁，即会膨胀为重量锁​ b.首先当前线程会修改Obj对象头中锁标志位，由代表轻量级锁的00修改成代表重量级锁的10，然后当前线程进入休眠模式，当然了再进入休眠模式之前还会进行一些操作，这里先这么理解，后面分析重量锁时具体流程再分析说明​ c.当持有Obj对象偏向锁的线程执行完同步方法后，会通过一次CAS原子操作将对象头中的MarkWord由当前栈帧中的Lock Record进行重置回之前内容，如果重置成功，则释放锁完成；但是，根据上步骤我们知道，由于当前已膨胀为重量级锁，导致Obj对象的MarkWord中的锁标志位已被修改，CAS重置对象头操作会失败，这时就会感知到：在偏向锁运行期间，存在了其它线程竞争锁资源情况，当前锁已被膨胀为重量级锁，所以，在释放锁得到同时，会唤醒应等待该锁导致休眠的线程 轻量级锁是不支持”并发”，遇到”并发”就要膨胀为重量级锁。可能你会疑问：锁就是用来解决并发下资源同步问题，轻量级锁对“并发”都不支持要它能干什么呢？注意：此并发并非彼并发，这里的并发是带有引号的，即不存在锁竞争的并发。 轻量级锁在申请锁资源时通过一个CAS操作即可获取，释放锁资源时也是通过一个CAS操作即可完成，CAS是一种乐观锁的实现机制，其开销显然要比互斥开销小很多，这就是轻量级锁提升性能的核心所在。但是，轻量级锁只是对无锁竞争并发场景下的一个优化，如果锁竞争激烈，轻量级锁不但有互斥开销，还要多一次CAS开销，这是轻量级锁比重量级锁性能更差。所以，JVM检测到锁竞争时自动膨胀为重量级锁原因就在于此。 偏向锁轻量级锁优化了并发情况下串行化访问的场景，即下面示意图中的场景一，现在有个更极端情况：假如一段时间间隔内同步方法只会被同一个线程多次访问，即下面示意图中的场景二，从总体看同步方法是在单线程环境中运行。如果使用轻量级锁，每次调用同步方法要通过一次CAS操作申请锁，执行完后同样通过一次CAS操作释放锁，如下面场景二产生了7次调用共要执行14次CAS操作，还不包括其它开销。JVM工程师们对场景二进一步进行优化：只会在线程第一次调用同步方法时获取锁，执行完成后不去释放，后面该线程再次进入时不需要再次获取锁，直接进入，只有当其它线程申请锁时才会释放，因此，同样的场景二，偏向锁只会产生2次CAS操作。 偏向锁的引入，主要是JVM工程师们经过研究发现：在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁的代价而引入偏向锁。偏向锁是对轻量级锁的进一步优化，轻量级锁优化了并发时串行化执行的场景，而偏向锁是对并发时”单线程”场景的优化。 默认JVM是开启偏向锁特性，但是默认JVM启动后的的头4秒钟这个feature是被禁止的，这也意味着在此期间，prototype MarkWord会将它们的bias位设置为0，以禁止实例化的对象被偏向。4秒钟之后，所有的prototype MarkWord的bias位会被重设为1，如此新的对象就可以被偏向锁定了，当然也可以通过如下方式缩短这个延迟： 1-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 偏向锁的MarkWord信息如下： 批量重偏向&amp;批量撤销 存在如下两种情况：​ 1、对于存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者&#x2F;消费者队列，生产者线程获得了偏向锁，消费者线程再去获得锁的时候，就涉及到这个偏向锁的撤销(revoke)操作，而这个撤销是比较昂贵的，而且在多生产者、多消费者情况下，这种状况更加糟糕，而且可能程序中使用了大量的这种队列，解决方案就是：识别出这些对象并禁止它们使用偏向锁特性；​ 2、还存在这样对象集，它们偏向的线程并不合适，但是重新偏向另外线程确实合适的，例如线程t1初始化了大量对象obj，然后对每个对象执行了用于初始化的同步方法，这样导致这组对象集偏向锁中的threadID都指向了t1，但是如果另外一个线程开始真正指向obj对象集上的同步方法，这就导致了大量偏向锁的revoke操作 怎么判断对象是否适合偏向锁呢？解决方案是：jvm采用以class类为单位的做法，其内部为每个类维护一个偏向锁计数器，对其对象进行偏向锁的撤销操作进行计数。当这个值达到指定阈值的时候，jvm就认为这个类的偏向锁有问题，需要进行重偏向（rebias），对所有属于这个类的对象进行重偏向的操作叫批量重偏向（bulk rebias）。 之前的做法是对heap进行遍历，但是这种实现方式如果堆增加到很大时是会存在性能问题的，后来便引入epoch。Class实例中包含了MarkWord原型–mark_prototype属性，该属性中的bias决定了该类型的对象是否允许被偏向锁定，与此同时，当前的epoch位也被保留在mark_prototype中。当需要bulk rebias时，对这个类的epcho值加1，以后分配这个类的对象的时候mark字段里就是这个epoch值了，同时还要对当前已经获得偏向锁的对象的epoch值加1，当然是在线程处于安全点时停止线程执行更新。对于那些正在运行且持有偏向锁的线程，由于没法更新导致对象头中的epoch和mark_prototype的epoch值不匹配，即偏向锁状态失效，下一个试图获取锁对象的线程使用原子CAS指令可将该锁对象绑定于当前线程。 偏向撤销(revoke)：如果一个新线程申请偏向锁，发现该对象已经处于偏向锁状态，就会去判断epoch是否有效且线程ID是否指向自己，如果无效或线程ID并没有指向自己，需要让偏向锁撤销并重新偏向自己。在重新偏向自己之前，还回去判断之前线程是否还在运行，如果还在运行是否还在继续使用锁，如果还在继续使用锁则产生锁竞争，偏向锁会被膨胀为轻量级锁，否则，新线程通过CAS原子操作将对象头中的线程ID重新偏向新线程。 批量重偏向导致对象头中的线程ID指向被重置为null，即线程重新通过CAS操作获取偏向锁。简单理解：批量重偏向是对当前类型下的对象偏向锁的一次校正，因为当前该类型的偏向锁存在大量的revoke被JVM判定是存在问题的偏向锁，批量重偏向后这个类的revoke计数器会被重置，如果这个类的revoke计数器继续增加到一个阈值，可能会继续进行一次批量重偏向，也可能不再继续批量重偏向，就这样继续1到多次批量重偏向后，jvm就认为这个类不适合偏向锁了，就要进行批量撤销(bulk revoke)，将该类的Class的mark_prototype中的bias属性设置成0，表示该类型下所有对象不允许被偏向锁定，同时将已存在的偏向锁膨胀为轻量级锁。 在批量重偏向(bulk rebias)的操作中，prototype的epoch位将会被更新；在批量吊销(bulk revoke)的操作中，prototype将会被置成不可偏向的状态——bias位被置0。 下面通过如下同步代码块分析下偏向锁实现的大致流程： 1234public class Obj &#123; public synchronized void fun1()&#123; &#125;&#125; 1、检测对象类型class中的bias设置是否允许偏向锁特性，只有开启此特性才能使用偏向锁​ 2、检测Obj对象头中MarkWord锁标识位等于01，代表无锁状态或已处于偏向锁状态，否则不能进行偏向锁设置；​ 3、检测Obj对象头中MarkWord偏向标识位，如果等于0，表示当前对象处于无锁状态，通过一次CAS原子操作将对象头线程ID设置成当前线程ID，设置成功则获取偏向锁成功​ 4、检测对象头中MarkWord偏向标识位，如果等于1表示当前已处于偏向锁状态，然后检测MarkWord中的线程ID是否等于当前线程ID，不等于则进入步骤(5)，等于会再进行判断epoch是否等于Obj类型的Class实例中的epoch，不等于说明该偏向锁失效，进入步骤(5)，等于则表明获取偏向锁成功，进入同步方法​ 5、监测偏向锁指向的线程是否还在运行，没有运行则执行步骤(6)，否则继续判断该线程是否还在持有锁，如果没有持有则执行步骤(6)，如果线程还在持有锁，则说明产生了锁竞争，会在持有偏向锁线程运行到全局安全点（这个时间点上没有正在执行的代码）时挂起运行线程，并将偏向锁膨胀为轻量级锁​ 6、使用CAS原子操作将对象头MarkWord中的线程ID设置成当前线程ID 偏向锁的核心思想是，锁不存在多线程竞争，且一个线程获取锁后接下来继续获取该锁的概率更大，可见偏向锁模式下线程是不会主动去释放偏向锁，只有其它线程来竞争该偏向锁时才会考虑撤销或膨胀。偏向锁解决了一次CAS操作可以实现任意多次调用，节省了每次调用申请锁、释放锁性能消耗，避免了轻量级锁产生大量的CAS操作导致的性能消耗，从而提升锁性能。和轻量级锁一样，偏向锁并不能解决锁竞争问题，一旦遇到锁竞争偏向锁就会膨胀为轻量级锁，轻量级锁也不能解决锁竞争问题，为什么不直接膨胀为重量级锁呢？如果锁竞争不是很激烈或者竞争时间非常短暂，前面介绍过轻量级锁有个自旋模式，可以通过自旋模式补救避免因偶然的误差导致直接膨胀为重量级锁。如果自旋模式也无法解决，说明说竞争可能确实激烈，轻量级锁也无能为力了，只能膨胀为重量级锁。 另外，偏向锁也不适合像生产者&#x2F;消费者这种线程交替获取锁模式，这样可能会导致产生大量的偏向锁撤销和重偏向操作，得不偿失。 重量级锁通过前面分析发现，无论是轻量锁还是偏向锁，都不能代替重量锁，都只是在无锁竞争或者竞争不是很激烈的情况下进行的一些性能优化，减少重量锁产生的性能消耗，并不能真正解决锁竞争问题。轻量锁和偏向锁都是重量锁的乐观并发优化，因为它们都是通过CAS原子操作尝试性获取锁，在锁竞争不是很激烈情况下，尝试性获取锁的概率当然就会很大，避免了由用户态切换到内核态，借助系统的Mutex Lock互斥锁实现线程协调的过程，但是一旦锁竞争激烈，还是需要借助于重量级锁特性才能解决。 synchronized的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么synchronized效率低的原因。 当锁被膨胀为重量级锁后，锁标识位会被设置成10，同时对象头会指向一个monitor对象，它会管理协调这些竞争锁资源的线程们。大致示意图如下： 流程如下： 1、如果线程A执行Obj对象的同步方法，通过对象头查找到Monitor的位置，然后线程A会进入WaitQueue区域，该区域主要是用于存储所有竞争锁资源的线程，多个线程同时竞争锁资源，只会有一个线程竞争成功，其它线程就会存储到该区域中，该区域主要维护两个队列：​ a.Contention List：所有请求锁的线程将被首先放置到该竞争队列中​ b.Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List，这个设计一方面也是从性能方面考虑：Contention List在高并发场景下不断的有新线程加入该队列，并且存在多个线程同时操作Content List，所以要进行同步控制，如果锁释放时直接从Contention List获取线程显然存在并发访问问题。所以，Owner线程首先会从Contention List迁移出一批线程到Entry List中，锁资源释放时从Entry List中获取线程，一般都是将Entry List的head赋值给OnCheck，Entry List不会存在并发访问问题，因为只有Owner线程才会从Entry List中提取数据，且也只有Owner才能从Contention List迁移线程到Entry List中，所以性能更好，只有等Entry List使用完为空时，Owner线程会再次从Contention List迁移一批线程放入到Entry List中 2、Ready Thread区域主要是存储下一个可以参与竞争锁资源的线程，等锁资源释放时让OnCheck指向的线程参与锁竞争，OnCheck一般指向的是Entry List的head位置。注意：等待队列中只会有一个线程参与竞争，一般是FIFO方式参与竞争，避免所有等待线程一起竞争锁资源造成性能问题。 OnCheck要竞争锁资源，而不是将Owner的锁资源直接传递给OnCheck线程，OnCheck只代表有资格竞争锁资源的线程，竞争锁资源就意味着可能会失败，失败就意味着这是一种非公平锁的实现机制。到底哪些线程会和OnCheck线程竞争锁资源呢？就是当前新加入申请锁资源的线程们，因为我们知道，只有申请锁资源失败的线程才会放入到Contention List，现在假如新加入的线程还在刚申请，走了狗屎运这时刚好Owner线程释放了锁资源，这就导致了这些新加入线程会和OnCheck一起竞争锁资源，这些新加入的线程可能优先竞争到锁资源，这就是非公平性的体现。这么做主要是从性能方面考虑，毕竟新线程如果竞争失败要做一大堆初始化工作然后放入到等待队列Contention List中，而OnCheck线程竞争失败只需要重新阻塞即可，显然工作量要小很多。但是，进入等待队列中的线程基本上是按照先进先出FIFO策略获取到锁资源的，因此，这种机制只会牺牲一定的公平性。另外，至少OnCheck线程还可以参与竞争，而不是从性能考虑直接让新线程获取到锁，避免等待队列中线程饿死现象。这里的实现和之前分析的ReentrantLock的思想基本一致，可以参考之前ReentrantLock实现机制加深对这块的理解。 3、Running Thread区域主要是存储当前获取到锁后正在运行的线程，使用Owner指向当前运行线程 4、Blocking Queue区域主要是存储那些获取到锁资源但是调用wait等方法被阻塞的线程，由于wait操作会释放当前锁，即Owner会被重置为null，当前线程进入WaitSet中，同时OnCheck线程参与锁竞争获取锁资源，等被阻塞的线程被唤醒后会被移入Entry List重新等待获取锁资源 只有获取到某个对象的锁时才能调用该对象的wait()让当前线程挂起，也就是如下代码： 1234567&gt; Object obj = new Object();&gt; public void fun2() throws InterruptedException &#123;&gt; synchronized (obj)&#123;&gt; obj.wait();&gt; &#125;&gt; &#125;&gt; &gt; 也就是只有获取obj对象的锁才能调用obj.wait()让当前线程挂起到obj对象上，同样唤醒该对象时也只有先获取obj锁时才能调用obj.notify()或obj.notifyAll()唤醒obj对象上阻塞的线程。这种设计是如何实现的呢？通过这里对Monitor结构的分析，你可能很容易就想到：​ 1、Monitor是线程私有的，也就是只会被当前锁资源持有线程就是Monitor对象的拥有者，即Owner指向的线程​ 2、只有Monitor的拥有者才能调用wait()方法释放监视锁，该线程进入阻塞队列，其它竞争锁资源新线程重新拥有Monitor线程​ 3、同理，只有Monitor拥有者才能调用notify()&#x2F;notifyAll()，这时会从Blocking Queue队列中将阻塞线程移入到Entry List，等待重新获取锁​ 4、wait()、notify()和notifyAll()都是只有Monitor的拥有者线程才能调用，而Monitor的拥有者线程就是当前持有obj对象锁的线程 多个线程竞争锁资源借助底层系统的Mutex Lock互斥锁实现，需要由用户态切换到内核态，由内核协调哪个线程获取到锁，哪些线程无法获取到锁，获取锁失败的线程会被内核进行阻塞，线程阻塞才能释放CPU资源。系统执行完后，会由内核态重新切换到用户态，将CPU的控制权交给获取锁的线程进行执行。 内核切换属于操作系统范畴，想了解的可以自行搜索资料学习。这里大致简单描述下：​ 1、程序经过编译最终会被翻译成机器指令进行执行​ 2、如果程序执行的是“1+1”这种简单指令，CPU获取到这个指令后直接执行加操作即可，这时CPU处于用户态下，相当于用户进程调用CPU执行指令​ 3、但是如果程序执行的是读取外围设备IO、线程休眠、线程唤醒等操作，这种操作涉及到用户无法访问内存某些区域，出于安全考虑，用户进程需要将CPU的控制权交由内核，由内核代替用户进行执行这些操作，这就是用户态向内核态切换，内核代替用户执行完这些敏感指令后，然后再将CPU控制权重新交给用户进程，用户进程获得CPU控制权后继续执行后续指令，你可以简单认为：处于内核态时，CPU可以执行更多操作指令​ 4、你会发现，涉及到内核切换一般至少要切换两次，即：由用户态切换到内核态，将CPU控制权交给内核，内核执行完后，再由内核态切换到用户态，用户进程重新获取CPU控制权继续向下执行，内核切换还是比较耗费性能的，所以，synchronized底层优化才会出现偏向锁、轻量级锁等 JVM中通过对象监视器Monitor实现重量级锁，也大致了解了Monitor结构，对Monitor进一步抽象可以总结为：其核心就是两个队列，竞争锁队列和信号阻塞队列，前者用于线程互斥，后者用于线程协调。 上图非常形象生动的描述了Monitor本质，图中圆圈代表线程， 左边区域是竞争锁的线程排队区域，简称等待区，右边是曾经获取过锁由于wait()等操作导致线程挂起锁被剥夺排队区域，简称阻塞区，它们中的线程都拼命的争夺进入中心舞台的入场券，而且这张入场券只有一张，这就导致中心舞台只能同时容纳一个线程，当中心区域的线程任务执行完成后，退出时会把它持有的入场券交出来，此时，等待区和阻塞区中的线程又开始竞争，如此往复。 锁总结JVM底层实现synchronized同步时依赖的偏向锁、轻量级锁和重量级锁的大致原理也分析完成了，还记得轻量级锁中对象头指向Lock Record和重量级锁中对象头指向Monitor，可能你会比较好奇它们之间有什么区别吗？这里我试着总结下，主要区别如下：​ 1、Lock Record存储在线程栈的栈帧中，如果你了解栈帧应该知道，栈帧代表的是一个方法调用，当方法调用完成，该栈帧也会从栈中出栈，因此，如果线程执行完同步方法后释放锁时Lock Record也就不复存在了，这时的对象头会被恢复至之前的MarkWord内容，可以说Lock Record是线程独有的；​ 2、Monitor是线程私有，Monitor中Owner指向的线程就是Monitor的拥有者，注意这里的线程私有和上面Lock Record线程独有是有区别的：Lock Record随线程同步方法执行完成会被销毁，新线程获得锁后继续在自己的线程栈的栈中重新创建一个Lock Record，并让对象头指向自己即获得锁；而Monitor拥有者在进行锁释放时，是不会销毁Monitor对象的，而只会把Monitor中的Owner重置为null，表示当前没有线程持有锁，然后其它线程竞争锁资源，竞争成功的线程会被设置到Owner上，Monitor不会随着线程执行完同步方法而被销毁，这就表明Monitor不可能存储在线程栈中，而是存储在堆上；​ 3、Lock Record和Monitor在释放锁时的行为也存在很大差别：Lock Record释放锁时会被销毁，对象头会被重置为之前的MarkWord内容，然后有新线程申请锁时会重新创建Lock Record让对象头指向，而Monitor释放锁时，只会把Monitor中的Owner重置为null，也就是说Monitor释放锁时对象头是不会变化的​ 4、Monitor结构明显比Lock Record复杂，Lock Record主要保存对象头的MarkWord信息，由于结构太过简单导致Lock Record没法维护由于锁竞争导致的等待线程，最多也就是让它们自旋几下，并没有存储它们的区域，这就是轻量级锁无法解决锁竞争问题的本质。Monitor不但要保存对象头的MarkWord信息，还要使用队列维护等待线程和阻塞线程，因此，产生锁竞争时只能用重量级锁处理。另外，Lock Record结构简单才可以每次释放锁时销毁，申请锁时重新创建，而Monitor创建代价大的多，所以，一旦对象膨胀为重量级锁，初始化完Monitor后会被对象头一直指向该Monitor​ 5、由于重量级锁维护着复杂的Monitor结构，同时还要使用底层系统的Mutex Lock导致用户态&#x2F;内核态之间的多次切换对性能的损耗，所以才出现偏向锁，轻量级锁优化在锁竞争不激烈时的性能，情不得已时才会启用重量级锁 锁是并发编程中非常重要的一个内容，解决了高并发场景下非原子操作导致的状态不一致问题，通过上篇博文 《并发编程锁之ReentrantLock总结》及这篇博文，已经对Java中锁的两种主要实现机制进行大致的分析，再去理解偏向锁、轻量级锁、重量级锁、自旋锁、重入锁、悲观锁、乐观锁等一堆曾经困扰我很久的锁概念时，可以非常清晰的、简明扼要的表达出它们之间的本质区别。 偏向锁、轻量级锁、重量级锁都是JVM底层实现synchronized同步时引入的概念，最开始synchronized采用的是重量级锁机制实现，采用复杂的Monitor锁+底层系统Mutex Lock，由于太过复杂的Monitor结构和频繁的用户态&#x2F;内核态间的切换导致性能不足，JVM工程师们在JDK1.6版本中引入了偏向锁、轻量级锁对重量级锁进行优化。 偏向锁和轻量级锁都是解决无锁竞争场景下锁的性能问题，因为它们都无法维护由于锁竞争导致的线程等待问题，所以遇到锁竞争就懵逼了，还是只能用重量级锁来处理。首先来看下轻量级锁，主要是解决线程间交替访问同步块问题，由于是线程交替访问而不是同时访问，所以并不会产生锁竞争，就没有必要使用笨重的重量级锁；再来看下偏向锁，偏向锁就更极端了，偏向锁认为不但没有锁竞争，而且在一段时间t1内都是线程A访问同步块，另一段时间t2内都是另一个线程B访问同步块，这样t1时间段内线程A通过一次CAS获取锁后，即使访问完同步块也不用去释放锁，不管线程A调用同步块多少次，都只需要第一次调用时申请锁，后面通过简单的判断直接进入，用完后即可离开，不需考虑锁申请和释放的问题，直到时间t2线程B过来访问，这时会把锁重偏向到线程B即可。 偏向锁锁解决的是一个周期内“单线程”访问共享资源问题，连CAS操作都是能节省就尽量节省，轻量级锁解决的是一个周期内多线程交替访问共享资源问题，使用CAS操作消除底层系统的互斥，而重量级锁解决的是一个周期内同时访问共享资源问题，需要管理等待线程以及依赖于底层系统互斥指令。 再来说说自旋锁，自旋锁不是锁的种类，而是锁的一项特性，如同重入锁一样，自旋的目的无非是优化性能，比如轻量级锁膨胀为重量级锁及ReentrantLock在真正进入休眠之前都会进行自旋，因为一旦轻量级锁膨胀为重量级锁或ReentrantLock中的线程进入休眠状态，对锁的性能都会造成很大的影响，自旋是为了极力挽救避免锁进入更糟糕的情况。但是自旋也会带来一个问题，自旋状态下会一直占用CPU资源，如果长时间无法获取锁而一直自旋下去，对系统资源造成很大的浪费，但是到底自旋多久比较合适呢，这还真是一个比较难拿捏的问题，好在JDK已经引入了自适应自旋，JVM会根据它的监控统计信息进行优化，自动动态的计算出自旋的周期，而不再简单的一个固定值。另外，自旋锁在单核系统下是没有意义的，因为自旋线程占用了CPU希望其它线程尽快释放锁才好结束自旋，其它持有锁的线程由于无法获取到CPU资源所以在自旋期间不可能获取到锁，但是现在一般不可能是单核系统，所以，JDK已经默认开启了自旋特性。 重入锁也是锁的一项特性，而非种类，其实Java中的锁基本都是重入锁，不可重入性锁会导致自己锁死自己的问题，而且出现一旦锁死再也无法解锁的严重问题，重入锁就是线程获取锁期间可以继续获取该锁，主要是通过在锁中设置一个计数器count，用于统计重入次数，同理在释放锁时，只有释放同样次数情况下才可能完全释放锁。重入锁的代码大致如下： 12345public synchronized void fun1()&#123;//synchronized方法已保证进入方法中线程已经获取到当前对象的锁 synchronized (this)&#123;//这里再次获取当前对象锁，而且会成功，这就是重入锁特性 System.out.println(&quot;test&quot;); &#125;&#125; 最后，再来看下乐观锁和悲观锁，这是从另一个维度对锁进行的分类，乐观锁、悲观锁与具体编程语言无关，基本所有的编程语言以及涉及到并发编程的系统中都会存在悲观锁和乐观锁，比如redis、oracle、elasticsearch等中都存在悲观锁和乐观锁的身影。乐观锁借助系统的原子性指令，对共享资源进行操作，即其在操作前并不会加锁控制同步块，而是乐观认为不会存在锁竞争所以没必要加锁，但是一旦操作失败就表示出现了锁竞争，乐观锁一般通过多次自旋方式进行多次尝试，直到操作成功，具体可以参看ReentrantLock源码中CAS+无限循环方式，这就是典型的乐观锁在Java中的实现。而悲观锁有如其名，悲观的认为操作一定会出现多线程竞争导致的同步问题，所以在对同步块操作之前，先锁起来，只有自己能操作共享资源，其它线程此时是无法访问共享资源的，这种控制多线程串行化访问共享资源方式虽然解决了线程安全问题，但是效率肯定是不高的。乐观锁在竞争不是太激烈的情况下，性能一般是高于悲观锁的，但是一旦在高并发下多线程竞争激烈，由于乐观锁失败的概率增加从而乐观锁不断尝试获取锁导致效率降低，性能反而可能会低于悲观锁，但在一般的生产中，大多数线程都是竞争不太激烈的情况，所以乐观锁的使用概率还是非常大的。 偏向锁和轻量级锁都是借助于CAS操作完成，可以理解为是乐观锁的一种实现，而重量级锁借助于底层系统互斥，可以看成是悲观锁的实现。 回过头来，对比synchronized和ReentrantLock实现机制，会发现它们在很多实现思想上如出一辙，虽然它们实现方式不一样，只有提炼出它们的设计思想才能掌握它们的核心本质，同时提升对并发编程的驾驭能力。 本文作者： zhang 本文链接： http://blog.reactor.top/2018/02/07/并发编程锁之synchronized总结/ 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"锁","slug":"锁","permalink":"http://jinyu.host/tags/%E9%94%81/"},{"name":"并发","slug":"并发","permalink":"http://jinyu.host/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"多线程","permalink":"http://jinyu.host/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Windows部署minio注册成服务在后台保持运行","slug":"22b43cc2-387b-4368-9c70-50044bac3d50","date":"2020-08-29T00:23:16.000Z","updated":"2020-08-29T00:23:16.000Z","comments":true,"path":"2020/08/29/22b43cc2-387b-4368-9c70-50044bac3d50/","link":"","permalink":"http://jinyu.host/2020/08/29/22b43cc2-387b-4368-9c70-50044bac3d50/","excerpt":"","text":"最近在使用minio做资源存储，要求把minio部署到wondows上使用，发现官方提供的运行命令：.\\minio.exe server .\\data运行后，关闭cmd窗口，服务就会关闭 所以需要通过winsw注册服务的方式，把minio注册成服务运行 WinSW下载配置： 地址：https://github.com/winsw/winsw/releases 将WinSW.exe复制到自定义的目录，并重命名为自己想命名的服务名称minio-server.exe 同目录下创建minio-server.xml，特别注意，xml和exe必须同名 配置minio-server.xml文件 使用minio-server.exe install安装服务 安装完后，去服务中启动服务，启动成功就可以正常使用minio啦 使用minio-server.exe uninstall卸载服务 具体配置：123456789101112131415161718&lt;service&gt; &lt;id&gt;minio-server&lt;/id&gt; &lt;name&gt;minio-server&lt;/name&gt; &lt;description&gt;minio文件存储服务器&lt;/description&gt; &lt;!-- 可设置环境变量 --&gt; &lt;env name=&quot;HOME&quot; value=&quot;%BASE%&quot;/&gt; &lt;executable&gt;%BASE%\\minio.exe&lt;/executable&gt; &lt;arguments&gt;server &quot;%BASE%\\data&quot;&lt;/arguments&gt; &lt;!-- &lt;logmode&gt;rotate&lt;/logmode&gt; --&gt; &lt;logpath&gt;%BASE%\\logs&lt;/logpath&gt; &lt;log mode=&quot;roll-by-size-time&quot;&gt; &lt;sizeThreshold&gt;10240&lt;/sizeThreshold&gt; &lt;pattern&gt;yyyyMMdd&lt;/pattern&gt; &lt;autoRollAtTime&gt;00:00:00&lt;/autoRollAtTime&gt; &lt;zipOlderThanNumDays&gt;5&lt;/zipOlderThanNumDays&gt; &lt;zipDateFormat&gt;yyyyMMdd&lt;/zipDateFormat&gt; &lt;/log&gt;&lt;/service&gt; 原文链接 https://www.cnblogs.com/zys-blog/p/13164197.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Minio","slug":"Minio","permalink":"http://jinyu.host/tags/Minio/"},{"name":"Windows","slug":"Windows","permalink":"http://jinyu.host/tags/Windows/"}]},{"title":"The username you provided is not allowed to use the text-based Tomcat Manager (error 403)","slug":"3da6888a-b6ff-4cc7-a3cf-e40efbb943d5","date":"2020-08-29T00:16:49.000Z","updated":"2020-08-29T00:16:49.000Z","comments":true,"path":"2020/08/29/3da6888a-b6ff-4cc7-a3cf-e40efbb943d5/","link":"","permalink":"http://jinyu.host/2020/08/29/3da6888a-b6ff-4cc7-a3cf-e40efbb943d5/","excerpt":"","text":"1.背景及现象在配置Jenkins的自动部署功能，手动构建时报“The username you provided is not allowed to use the text-based Tomcat Manager (error 403)”错误，如图： ![](https://gitee.com/jinyu52370/images/raw/master/images/The username you provided is not allowed to use the text-based Tomcat Manager (error 403).jpg) 2.原因用于tomcat7自动部署的管理用户必须具有manager-script角色,manager-gui角色是不够的，不然会有错误出现：The username you provided is not allowed to use the text-based Tomcat Manager (error 403)在&#x2F;etc&#x2F;tomcat7&#x2F;tomcat-users.xml文件中为管理用户添加manager-script角色即可。 3.解决方法 进入到tomcat的conf目录下，编辑tomcat-users.xml配置文件 ![](https://gitee.com/jinyu52370/images/raw/master/images/tomcat manager-script.png) 1234&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;admin-gui,manager-gui,manager-script&quot;/&gt; 进入到tomcat的webapps&#x2F;manager&#x2F;META_INF&#x2F;context.xml文件，将文件中对访问的来源受限设置注释 12345678&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt;&lt;!--注释掉此代码--&gt; &lt;!-- &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;--&gt; &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\\.lang\\.(?:Boolean|Integer|Long|Number|String)|org\\.apache\\.catalina\\.filters\\.CsrfPreventionFilter\\$LruCache(?:\\$1)?|java\\.util\\.(?:Linked)?HashMap&quot;/&gt;&lt;/Context&gt; 重启tomcat，再次构建即可 原文链接 https://www.cnblogs.com/wanghy898/p/11257574.html 原文链接 https://blog.csdn.net/Jay_1989&#x2F;article&#x2F;details&#x2F;52861620?utm_source&#x3D;blogxgwz2","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://jinyu.host/tags/Tomcat/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://jinyu.host/tags/Jenkins/"}]},{"title":"Build step 'Invoke top-level Maven targets' marked build as failure Finished","slug":"c49478bb-79a0-4a4c-91b4-fca9116bdfcd","date":"2020-08-29T00:03:11.000Z","updated":"2020-08-29T00:03:11.000Z","comments":true,"path":"2020/08/29/c49478bb-79a0-4a4c-91b4-fca9116bdfcd/","link":"","permalink":"http://jinyu.host/2020/08/29/c49478bb-79a0-4a4c-91b4-fca9116bdfcd/","excerpt":"","text":"Jenkins部署项目时，调用maven打包时报错： ![](https://gitee.com/jinyu52370/images/raw/master/images/Build step ‘Invoke top-level Maven targets’ marked build as failure Finished.png) 猜想是运行jenkins的Tomcat内存溢出导致，修改bin&#x2F;catalina.sh，加上 1JAVA_OPTS=&quot;-Xms256m -Xmx512m -Xss1024K -XX:PermSize=128m -XX:MaxPermSize=256m&quot; 重启Tomcat，再次构建，问题解决 原文链接 https://blog.csdn.net/shenjuntao520/article/details/103048287","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://jinyu.host/tags/Jenkins/"},{"name":"Maven","slug":"Maven","permalink":"http://jinyu.host/tags/Maven/"}]},{"title":"Jenkins + Gitee搭建持续集成环境","slug":"76a9a626-f1df-4341-8f60-56f760ddd3fd","date":"2020-08-28T21:33:05.000Z","updated":"2020-08-28T21:33:05.000Z","comments":true,"path":"2020/08/29/76a9a626-f1df-4341-8f60-56f760ddd3fd/","link":"","permalink":"http://jinyu.host/2020/08/29/76a9a626-f1df-4341-8f60-56f760ddd3fd/","excerpt":"","text":"1.前置环境 Java环境 Tomcat 2.下载并部署jenkins的war包 下载jenkins.war 1wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war 将下好的jenkinx.war放在tomcat下的webapps，重启tomcat ip:8080/jenkins即可访问 3.修改default.json以加快插件下载速度出现Unlock Jenkins页面时关闭tomcat，然后编辑jenkins的default.json 1vim ~/.jenkins/updates/default.json 替换updates.jenkins-ci.org/download为mirrors.tuna.tsinghua.edu.cn/jenkins 然后把www.google.com修改成www.baidu.com 此处为已经改好的default.json，覆盖原文件即可 修改好default.json后重启tomcat 4.配置jenkins4.1.登录默认admin密码在~/.jenkins/secrets/initialAdminPassword 4.2.插件配置选择推荐安装插件，之后进入jenkins界面后，点击系统管理 -&gt; 插件管理 -&gt; 可选插件，搜索gitee，安装后重启jenkins； 系统管理 -&gt; 系统配置 -&gt; Gitee配置： 链接名：自定义 Gitee 域名 URL：https://gitee.com 证书令牌：根据提示添加令牌 系统管理 -&gt; 全局工具配置： 添加Maven配置 添加JDK 添加Maven 5.新建任务 构建一个自由风格的软件项目 ![](https://gitee.com/jinyu52370/images/raw/master/images/jinyu-blog Config [Jenkins].png) 参考链接 https://www.cnblogs.com/Christine-ting/p/10501515.html 参考链接 https://blog.csdn.net/u013788943/article/details/103822785","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://jinyu.host/tags/Jenkins/"}]},{"title":"vim永久显示行号","slug":"44145d69-cff6-4517-adcc-a1e206614c4f","date":"2020-08-28T03:44:55.000Z","updated":"2020-08-28T03:44:55.000Z","comments":true,"path":"2020/08/28/44145d69-cff6-4517-adcc-a1e206614c4f/","link":"","permalink":"http://jinyu.host/2020/08/28/44145d69-cff6-4517-adcc-a1e206614c4f/","excerpt":"","text":"编辑vim个人配置 1vim ~/.vimrc 添加set nu，保存退出 原文链接 https://blog.csdn.net/ouyang_peng&#x2F;article&#x2F;details&#x2F;83379407","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"vim","slug":"vim","permalink":"http://jinyu.host/tags/vim/"}]},{"title":"Docker安装Minio存储服务器","slug":"09a7931e-a93b-47d2-a861-b15156bd132f","date":"2020-08-28T03:40:14.000Z","updated":"2020-08-28T03:40:43.000Z","comments":true,"path":"2020/08/28/09a7931e-a93b-47d2-a861-b15156bd132f/","link":"","permalink":"http://jinyu.host/2020/08/28/09a7931e-a93b-47d2-a861-b15156bd132f/","excerpt":"","text":"1.拉取镜像1docker pull minio/minio 2.启动与安装镜像2.1.普通安装这种安装方式并没有指定 ACCESS_KEY 和 SECRET_KEY 进行设置，安装后可以进行 echo命令设置, 12# -it 表示运行参数，-p 表示暴露端口 ，-d 表示后台运行，data 指定目录存放文件docker run -it -p 9000:9000 -d minio/minio server /data echo 命令设置 ACCESS_KEY 和 SECRET_KEY 12echo &quot;minio&quot; | docker secret create access_key -echo &quot;minio&quot; | docker secret create secret_key - 2.2.自定义用户和秘钥安装这种安装方式 MinIO 自定义 Access 和 Secret 密钥要覆盖 MinIO 的自动生成的密钥，您可以将 Access 和 Secret 密钥设为环境变量。MinIO 允许常规字符串作为 Access 和 Secret 密钥 1234567docker run -p 9000:9000 --name minio \\-d --restart=always \\-e &quot;MINIO_ACCESS_KEY=admin&quot; \\-e &quot;MINIO_SECRET_KEY=admin123456&quot; \\-v /home/data:/data \\-v /home/config:/root/.minio \\minio/minio server /data 3.查看安装logs信息1docker logs minio minio安装的日志信息，其中AccessKey和SecretKey是登陆minio客户端的用户名和秘钥 1234567891011121314Endpoint: http://172.17.0.5:9000 http://127.0.0.1:9000AccessKey: 4RUAAMD4JVDTSYFZAIIUSecretKey: mn5fYWV2CPtENTS6XHQqRB+j+NNjI3w79qcdQ4VZBrowser Access:http://172.17.0.5:9000 http://127.0.0.1:9000Command-line Access: https://docs.min.io/docs/minio-client-quickstart-guide$ mc config host add myminio http://172.17.0.5:9000 4RUAAMD4JVDTSYFZAIIUmn5fYWV2CPtENTS6XHQqRB+j+NNjI3w79qcdQ4VZObject API (Amazon S3 compatible):Go: https://docs.min.io/docs/golang-client-quickstart-guideJava: https://docs.min.io/docs/java-client-quickstart-guidePython: https://docs.min.io/docs/python-client-quickstart-guideJavaScript: https://docs.min.io/docs/javascript-client-quickstart-guide.NET: https://docs.min.io/docs/dotnet-client-quickstart-guide 4.登录客户端访问ip:9000即可 原文链接 https://www.jianshu.com/p/52dbc679094a","categories":[{"name":"Docker部署App","slug":"Docker部署App","permalink":"http://jinyu.host/categories/Docker%E9%83%A8%E7%BD%B2App/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"},{"name":"Minio","slug":"Minio","permalink":"http://jinyu.host/tags/Minio/"}]},{"title":"Docker部署Nacos-Server(单机版)","slug":"c23b6d6f-7386-4c4b-ad02-cc30b5f54f14","date":"2020-08-28T02:23:23.000Z","updated":"2020-08-28T02:43:56.000Z","comments":true,"path":"2020/08/28/c23b6d6f-7386-4c4b-ad02-cc30b5f54f14/","link":"","permalink":"http://jinyu.host/2020/08/28/c23b6d6f-7386-4c4b-ad02-cc30b5f54f14/","excerpt":"","text":"方式一仅部署nacos-server,不使用prometheus&#x2F;grafana等监控组件 1. 拉取镜像 1docker pull nacos/nacos-server 2.启动容器 12345678910docker run \\--name nacos -d \\-p 8848:8848 \\--privileged=true \\--restart=always \\-e JVM_XMS=256m \\-e JVM_XMX=256m \\-e MODE=standalone \\-e PREFER_HOST_MODE=hostname \\nacos/nacos-server 3.进入容器修改配置 1docker exec -it nacos bash 12cd confvim application.properties 然后添加数据库的信息 保存退出后，在nacos设置的mysql中新建数据库nacos_config，然后执行nacos-mysql.sql 方式二通过docker-compose部署,包含prometheus&#x2F;grafana等监控组件 1.拉取仓库 1git clone --depth 1 https://github.com/nacos-group/nacos-docker.git 2.运行docker-compose 12cd nacos-dockerdocker-compose -f example/standalone-derby.yaml up -d 原文链接 https://www.jianshu.com/p/3d3e17bc629f","categories":[{"name":"Docker部署App","slug":"Docker部署App","permalink":"http://jinyu.host/categories/Docker%E9%83%A8%E7%BD%B2App/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"},{"name":"Nacos","slug":"Nacos","permalink":"http://jinyu.host/tags/Nacos/"}]},{"title":"使用js美化Markdown文档","slug":"7f6f748b-2b84-4ff0-b369-55169f13911e","date":"2020-08-28T00:43:18.000Z","updated":"2020-08-28T00:43:18.000Z","comments":true,"path":"2020/08/28/7f6f748b-2b84-4ff0-b369-55169f13911e/","link":"","permalink":"http://jinyu.host/2020/08/28/7f6f748b-2b84-4ff0-b369-55169f13911e/","excerpt":"","text":"引入strapdown.js 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/sandstone/bootstrap.min.css&quot;&gt;&lt;xmp theme=&quot;sandstone&quot;&gt;&lt;!--M↓文本--&gt;xxxxxx&lt;/xmp&gt;&lt;/body&gt;&lt;script src=&quot;http://strapdownjs.com/v/0.2/strapdown.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 主题的修改方式：打开上面的链接，strapdown.js中会有不同的主题，粘贴主题名并改为小写，复制到link标签的href（只需替换4.5.2和bootstrap.min.css中间的主题名）和xmp标签的theme即可；此例使用的主题为：sandstone 原文链接 https://zhuanlan.zhihu.com/p/37690583?native.theme=7","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://jinyu.host/tags/Markdown/"}]},{"title":"CentOS7安装zsh配置oh-my-zsh","slug":"98f43741-13b2-4b4c-8ea1-16da41826cc0","date":"2020-08-28T00:25:10.000Z","updated":"2020-08-28T00:25:10.000Z","comments":true,"path":"2020/08/28/98f43741-13b2-4b4c-8ea1-16da41826cc0/","link":"","permalink":"http://jinyu.host/2020/08/28/98f43741-13b2-4b4c-8ea1-16da41826cc0/","excerpt":"","text":"1.查看当前shell1echo $SHELL 结果： 1bin/bash 2.安装zsh1yum install -y zsh 3.在root用户下设置zsh为默认shell1chsh -s /bin/zsh 4.zsh需要git支持1yum install -y git 5.安装oh-my-zsh自动安装： 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 手动安装： 下载源码： 1git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 复制配置： 1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 6.配置主题1vim ~/.zshrc 修改ZSH_THEME即可 原文链接 https://www.jianshu.com/p/4ce7d511bc13","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"zsh","slug":"zsh","permalink":"http://jinyu.host/tags/zsh/"}]},{"title":"Tomcat访问路径去掉项目名","slug":"6af2baee-79c4-4f16-9e51-ca4a087f94b6","date":"2020-08-25T20:30:19.000Z","updated":"2020-08-25T20:30:19.000Z","comments":true,"path":"2020/08/26/6af2baee-79c4-4f16-9e51-ca4a087f94b6/","link":"","permalink":"http://jinyu.host/2020/08/26/6af2baee-79c4-4f16-9e51-ca4a087f94b6/","excerpt":"","text":"将项目重命名为ROOT.war，放入tomcat/webapps（不推荐） 修改tomcat/conf/server.xml： docBase：项目实际路径 path：要修改成的访问路径 原文链接 https://blog.csdn.net/liyifan687/article/details/80040121","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://jinyu.host/tags/Tomcat/"}]},{"title":"Linux修改hosts","slug":"c0a480fa-50af-4262-bc0d-a3ef51f36625","date":"2020-08-23T02:35:37.000Z","updated":"2020-08-23T02:35:37.000Z","comments":true,"path":"2020/08/23/c0a480fa-50af-4262-bc0d-a3ef51f36625/","link":"","permalink":"http://jinyu.host/2020/08/23/c0a480fa-50af-4262-bc0d-a3ef51f36625/","excerpt":"","text":"编辑hosts： 1vim /etc/hosts 添加需要的信息，保存后退出，然后重启hosts： 1/etc/init.d/network restart 可以查看是否修改成功： 1cat /etc/hosts","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"Linux开机自启应用","slug":"9f4e62c2-0112-429f-91c3-80b33e0d8586","date":"2020-08-23T01:46:03.000Z","updated":"2020-08-23T01:46:03.000Z","comments":true,"path":"2020/08/23/9f4e62c2-0112-429f-91c3-80b33e0d8586/","link":"","permalink":"http://jinyu.host/2020/08/23/9f4e62c2-0112-429f-91c3-80b33e0d8586/","excerpt":"","text":"以tomcat为例创建脚本tomcat_start.sh并编辑： 123456#!/bin/sh#chkconfig: 2345 80 90#description:tomcat_start.shexport JAVA_HOME=/@app/jdk1.8.0_221cd /@app/tomcat/binnohup ./startup.sh 说明： 1234567891011121314151617# 是指此脚本使用/bin/sh来解释执行#!/bin/sh# 2345表示系统运行级别是2，3，4或者5时都启动此服务，20，是启动的优先级，80是关闭的优先级，如果启动优先级配置的数太小时如0时，则有可能启动不成功，因为此时可能其依赖的网络服务还没有启动，从而导致自启动失败。#chkconfig: 2345 80 90# 描述信息#description:tomcat_start.sh# 指定java环境变量export JAVA_HOME=/usr/local/java/jdk1.8.0_65# 进入tomcat目录cd /usr/local/software/apache-tomcat-8.5.0/bin/# 启动脚本nohup ./startup.sh :wq!保存退出后 使用chmod设置可执行权限： 1chmod +x tomcat_start.sh 然后将其拷贝到&#x2F;etc&#x2F;init.d&#x2F;目录下，否则添加服务不成功： 1cp tomcat_start.sh /etc/init.d/ 添加到系统服务： 1chkconfig --add tomcat_start.sh 设置开机启动： 1chkconfig tomcat_start.sh on 然后重启即可： 1reboot 重启之后连接查看效果： 1ps -ef | grep tomcat 原文链接 https://blog.csdn.net/abcwanglinyong/article/details/84638125","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://jinyu.host/tags/Tomcat/"}]},{"title":"docker logs－查看docker容器日志","slug":"6ad8c6b0-7ee9-4b8f-9cfe-d422a0e2e0d0","date":"2020-08-22T21:26:17.000Z","updated":"2020-08-22T21:26:17.000Z","comments":true,"path":"2020/08/23/6ad8c6b0-7ee9-4b8f-9cfe-d422a0e2e0d0/","link":"","permalink":"http://jinyu.host/2020/08/23/6ad8c6b0-7ee9-4b8f-9cfe-d422a0e2e0d0/","excerpt":"","text":"通过docker logs命令可以查看容器的日志命令格式：12345678$ docker logs [OPTIONS] CONTAINER Options: --details 显示更多的信息 -f, --follow 跟踪实时日志 --since string 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟） --tail string 从日志末尾显示多少行日志， 默认是all -t, --timestamps 显示时间戳 --until string 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟） 例子：查看指定时间后的日志，只显示最后100行： 1$ docker logs -f -t --since=&quot;2018-02-08&quot; --tail=100 CONTAINER_ID 查看最近30分钟的日志: 1$ docker logs --since 30m CONTAINER_ID 查看某时间之后的日志： 1$ docker logs -t --since=&quot;2018-02-08T13:23:37&quot; CONTAINER_ID 查看某时间段日志： 1$ docker logs -t --since=&quot;2018-02-08T13:23:37&quot; --until &quot;2018-02-09T12:23:37&quot; CONTAINER_ID 原文链接 https://www.jianshu.com/p/1eb1d1d3f25e","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"}]},{"title":"[ERR] 1273 - Unknown collation: 'utf8mb4_0900_ai_ci'","slug":"dc1110f2-bfd5-46b3-96b5-6ff2d30291a8","date":"2020-08-20T03:42:43.000Z","updated":"2020-08-21T02:34:19.000Z","comments":true,"path":"2020/08/20/dc1110f2-bfd5-46b3-96b5-6ff2d30291a8/","link":"","permalink":"http://jinyu.host/2020/08/20/dc1110f2-bfd5-46b3-96b5-6ff2d30291a8/","excerpt":"","text":"使用navicate12运行sql文件出错 报错：1[ERR] 1273 - Unknown collation: &#x27;utf8mb4_0900_ai_ci&#x27; 报错原因：生成转储文件的数据库版本为8.0,要导入sql文件的数据库版本为5.6,因为是高版本导入到低版本，引起1273错误 解决方法：打开sql文件，将文件中的所有utf8mb4_0900_ai_ci替换为utf8_general_ci、utf8mb4替换为utf8保存后再次运行sql文件，运行成功 原文链接 https://blog.csdn.net/yinzitun7947/article/details/89917611","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://jinyu.host/tags/MySQL/"},{"name":"Navicat","slug":"Navicat","permalink":"http://jinyu.host/tags/Navicat/"}]},{"title":"Redlock（redis分布式锁）原理分析","slug":"28b38cee-8734-4732-8de7-47f9f99b3f13","date":"2020-08-19T21:24:20.000Z","updated":"2020-08-19T21:24:20.000Z","comments":true,"path":"2020/08/20/28b38cee-8734-4732-8de7-47f9f99b3f13/","link":"","permalink":"http://jinyu.host/2020/08/20/28b38cee-8734-4732-8de7-47f9f99b3f13/","excerpt":"","text":"原文链接 https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://jinyu.host/tags/Redis/"}]},{"title":"正则表达式中?=和?:和?!的理解","slug":"32fa69eb-cb95-4b2e-ac55-7525e2f26545","date":"2020-08-16T00:52:30.000Z","updated":"2020-08-16T00:52:30.000Z","comments":true,"path":"2020/08/16/32fa69eb-cb95-4b2e-ac55-7525e2f26545/","link":"","permalink":"http://jinyu.host/2020/08/16/32fa69eb-cb95-4b2e-ac55-7525e2f26545/","excerpt":"","text":"要理解?=和?!，首先需要理解前瞻，后顾，负前瞻，负后顾四个概念： 1234567891011// 前瞻：查找exp2前面的exp1exp1(?=exp2) // 后顾：查找exp2后面的exp1(?&lt;=exp2)exp1 // 负前瞻：查找后面不是exp2的exp1exp1(?!exp2) // 负后顾：查找前面不是exp2的exp1(?&lt;!exp2)exp1 举例： 12&quot;中国人&quot;.replace(/(?&lt;=中国)人/, &quot;rr&quot;) // 匹配中国人中的人，将其替换为rr，结果为 中国rr&quot;法国人&quot;.replace(/(?&lt;=中国)人/, &quot;rr&quot;) // 结果为 法国人，因为人前面不是中国，所以无法匹配到 要理解?:则需要理解捕获分组和非捕获分组的概念： 12()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来 举例： 12// 数字格式化 1,123,000&quot;1234567890&quot;.replace(/\\B(?=(?:\\d&#123;3&#125;)+(?!\\d))/g,&quot;,&quot;) // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\\B) 原文链接 https://blog.csdn.net/csm0912/article/details/81206848","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://jinyu.host/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"java使用正则表达式对字符串去重","slug":"3c97de7c-78c9-4a4a-81d6-2caa615938b8","date":"2020-08-16T00:37:48.000Z","updated":"2020-08-16T00:37:48.000Z","comments":true,"path":"2020/08/16/3c97de7c-78c9-4a4a-81d6-2caa615938b8/","link":"","permalink":"http://jinyu.host/2020/08/16/3c97de7c-78c9-4a4a-81d6-2caa615938b8/","excerpt":"","text":"1234567/* * \\\\n：表示匹配第n个括号内匹配到的内容 * ?=：前瞻：exp1(?=exp2) 查找exp2前面的exp1 * * 总体表示：贪婪匹配所有前面出现过的字符，然后用api替换其为空串 */str.replaceAll(&quot;(.)(?=.*\\\\1)&quot;, &quot;&quot;)；","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://jinyu.host/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Springboot 全局日期格式化，只需要几行小代码","slug":"4a8f11b1-081b-4d00-84f1-43b06501940a","date":"2020-08-08T01:51:12.000Z","updated":"2020-08-08T01:51:12.000Z","comments":true,"path":"2020/08/08/4a8f11b1-081b-4d00-84f1-43b06501940a/","link":"","permalink":"http://jinyu.host/2020/08/08/4a8f11b1-081b-4d00-84f1-43b06501940a/","excerpt":"","text":"场景数据库时间字段的类型： 12createTime datetimeupdateTime datetime 实体类时间字段类型： 12private Date createTime;private Date updateTime; 从数据库中查询返回的数据： 1234&#123; &quot;create_time&quot;: &quot;2020-08-08T09:27:07.000+08:00&quot;, &quot;update_time&quot;: &quot;2020-08-08T09:27:09.000+08:00&quot;&#125; 希望得到的数据： 1234&#123; &quot;create_time&quot;: &quot;2020-08-08 09:27:07&quot;, &quot;update_time&quot;: &quot;2020-08-08 09:27:09&quot; &#125; 解决方案 取出字段进行格式转换： 12DateTimeFormatterSimpleDateFormat 使用格式化注解进行转换： 1@JsonFormat(locale = &quot;zh&quot;, timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) 在数据库sql语句动手脚进行格式转换 1SELECT DATE_FORMAT(createTime,&quot;%Y-%m-%d %H:%i:%s&quot;) 简单直接的方案在application.yml上 加上四行配置项代码即可： 123456spring: jackson: #时区，默认为格林尼治时间，即少8小时，所以我们需要+8 time-zone: GMT+8 #时间格式转换定义 date-format: yyyy-MM-dd HH:mm:ss 原文链接 https://blog.csdn.net/qq_35387940&#x2F;article&#x2F;details&#x2F;107249735","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jinyu.host/tags/SpringBoot/"},{"name":"yml","slug":"yml","permalink":"http://jinyu.host/tags/yml/"}]},{"title":"mysql的limit和offset用法","slug":"359ea5a7-f2f6-4e14-983e-f0af5ae48868","date":"2020-08-07T01:51:59.000Z","updated":"2020-08-07T01:51:59.000Z","comments":true,"path":"2020/08/07/359ea5a7-f2f6-4e14-983e-f0af5ae48868/","link":"","permalink":"http://jinyu.host/2020/08/07/359ea5a7-f2f6-4e14-983e-f0af5ae48868/","excerpt":"","text":"mysql里分页一般用limit来实现， 1.例子：123#这两种写法都表示取2,3,4三条条数据select* from article LIMIT 1,3select * from article LIMIT 3 OFFSET 1 2.参数说明 当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量， 例如：select* from article LIMIT 1,3，就是跳过1条数据，从第2条数据开始取，取3条数据，也就是取2,3,4三条数据 当 limit后面跟一个参数的时候，该参数表示要取的数据的数量 例如：select* from article LIMIT 3，表示直接取前三条数据，类似sqlserver里的top语法。 当limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量，offset表示要跳过的数量 例如：select * from article LIMIT 3 OFFSET 1，表示跳过1条数据，从第2条数据开始取，取3条数据，也就是取2,3,4三条数据 原文链接 https://www.cnblogs.com/dongml/p/10953846.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://jinyu.host/tags/MySQL/"}]},{"title":"centos 删除多余的内核启动项","slug":"21858b64-075b-41b4-9861-edde9212542e","date":"2020-08-07T01:40:00.000Z","updated":"2020-08-07T01:40:00.000Z","comments":true,"path":"2020/08/07/21858b64-075b-41b4-9861-edde9212542e/","link":"","permalink":"http://jinyu.host/2020/08/07/21858b64-075b-41b4-9861-edde9212542e/","excerpt":"","text":"1.列出系统中正在使用的内核1uname -a 12# 结果4.4.31-1.el7.elrepo.x86_64 2.查询系统中全部的内核1rpm -qa | grep kernel 1234567# 结果kernel-lt-4.4.31-1.el7.elrepo.x86_64kernel-tools-libs-3.10.0-514.10.2.el7.x86_64kernel-3.10.0-514.10.2.el7.x86_64kernel-tools-3.10.0-514.10.2.el7.x86_64kernel-3.10.0-327.36.3.el7.x86_64kernel-headers-3.10.0-514.10.2.el7.x86_64 3.删除不使用的版本号1yum remove kernel-tools-libs-3.10.0-514.10.2.el7.x86_64 kernel-3.10.0-514.10.2.el7.x86_64 kernel-tools-3.10.0-514.10.2.el7.x86_64 kernel-3.10.0-327.36.3.el7.x86_64 kernel-headers-3.10.0-514.10.2.el7.x86_64 注：其实可以用通配符 1yum remove kernel-tools-libs-3.1* kernel-3.1* kernel-tools-3.1* kernel-3.10.0-327.36.3.el7.x86_64 kernel-headers-3.1* 4.删除所有相关的文件1234cd /bootrm -rf *3.10.0-123.4.4.el7*cd /lib/modules/rm -rf 3.10.0-123.4.4.el7 最后 1grub2-mkconfig -o /boot/grub2/grub.cfg 一般新内核在grub的list最高位所以直接grub2-set-default 0，然后重启，一般就可以了 原文链接 https://www.cnblogs.com/sfissw/p/6119889.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"CentOS7","slug":"CentOS7","permalink":"http://jinyu.host/tags/CentOS7/"}]},{"title":"CentOS 7命令行安装GNOME、KDE图形界面","slug":"33dd2b8c-44bf-4d94-ad55-9ba33b017098","date":"2020-08-05T23:17:33.000Z","updated":"2020-08-05T23:17:33.000Z","comments":true,"path":"2020/08/06/33dd2b8c-44bf-4d94-ad55-9ba33b017098/","link":"","permalink":"http://jinyu.host/2020/08/06/33dd2b8c-44bf-4d94-ad55-9ba33b017098/","excerpt":"","text":"CentOS 7 默认是没有图形化界面的，但我们很多人在习惯了 Windows 的图形化界面之后，总是希望有一个图形化界面从而方便我们使用，这里介绍一下 CentOS７安装图形化桌面系统的方法。 1.进入 root 模式因为权限限制，所以我们需要进入 root 模式，开机使用 root 登陆或者系统运行中切换为 root 用户均可。 2.安装X窗口系统2.1.首先安装X(X Window System)，命令为1yum groupinstall &quot;X Window System&quot; 然后系统会自动寻找最近的网络进行相关文件的下载 选择 y ，然后开始下载需要的 package； 选择 y，开始进行安装； 当出现 Complete！说明这里安装成功了。 在这里我们可以检查一下我们已经安装的软件以及可以安装的软件，命令为 1yum grouplist 3.安装图形界面软件 GNOME然后我们开始安装我们需要的图形界面软件，GNOME(GNOME Desktop) 特别注意！！！！ 一定要注意名称必须对应，否则会出现No packages in any requested group available to install or update 的错误。这是因为不同版本的CentOS的软件名可能不同（其他 Linux 系统也是类似的） 如上图，安装命令为： 1yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot; 选择 y 开始下载需要安装的 package； 到这里就安装完成了。 这时，我们可以通过命令startx进入图形界面，第一次进入会比较慢，请耐心等待。（可能需要重启，命令为reboot） ps： 如果安装完成后，虚拟机无法打开，我们需要调整虚拟机分配内存大小（注意不是磁盘大小），1024M基本够用。 如果安装完成后，虚拟机报错0x0000005c，请关闭虚拟机的3D加速功能（取消勾选） 4.更新系统的默认运行级别经过上面的操作，系统启动默认还是命令行页面的，需要我们进行切换。如果想要使系统启动即为图形化窗口，需要执行下面的命令 1ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 原文链接 https://www.linuxidc.com/Linux/2018-04/152000.htm","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"CentOS7","slug":"CentOS7","permalink":"http://jinyu.host/tags/CentOS7/"},{"name":"gnome","slug":"gnome","permalink":"http://jinyu.host/tags/gnome/"}]},{"title":"CentOS7自动以root身份登陆gnome桌面","slug":"81bc987a-e7d7-4c32-b7ea-ba269ad55470","date":"2020-08-05T01:41:52.000Z","updated":"2020-08-05T01:41:52.000Z","comments":true,"path":"2020/08/05/81bc987a-e7d7-4c32-b7ea-ba269ad55470/","link":"","permalink":"http://jinyu.host/2020/08/05/81bc987a-e7d7-4c32-b7ea-ba269ad55470/","excerpt":"","text":"CentOS 7自动以root身份登录gnome桌面 刚刚在虚拟机中成功的安装上了CentOS 7 64位，发现在登录gnome桌面时必须创建一个普通用户，否则不让登录。 重启CentOS发现下方藏有一个使用其他用户登录选项，可以输入用户名使用root登录。 流畅且犀利的操作了一会儿，感觉很爽XD。想以后都用root登录，反正不是用于生产环境的服务器而是VMware虚拟机，有着强大的快照功能，随时可以恢复到上一个快照。好，赶紧进入正文。 1. 配置root自动登录gnome在配置的时候会遇到GDM： GDM是什么？ GDM (The GNOME Display Manager)是GNOME显示环境的管理器，并被用来替代原来的X Display Manager。与其竞争者(X3DM,KDM,WDM)不同，GDM是完全重写的，并不包含任何XDM的代码。GDM可以运行并管理本地和远程登录的X服务器(通过XDMCP)。 gdm仅仅是一个脚本，实际上是通过他来运行GDM二进制可执行文件。 gdm-stop是用来迅速终止当前正在运行的gdm守护进程的一个脚本。 gdm-restart脚本将迅速重启当前守护进程。 gdm-safe-restart会当所有人都注销后再重启。 gdmsetup是一种可以很简单的修改多数常用选项的图形化界面工具。 百度上搜到的都是RHEL、CentOS 6的配置方法，并不适用于CentOS 7。我在此贴出供各位看官参考： 在CentOS 6较新版本的Linux发行版中预设不允许以root账号登入gnome图形用户桌面，因此一般使用者登入后，可以在终端机以su root，暂时取得root权限； 如果一定要以root登入图形界面，可以修改/etc/pam.d/gdm以及 /etc/pam.d/gdm-passwd，把这行auth required pam_succeed_if.so user != root quiet加上#注释掉，保存后就可以用root账号了。 对于**CentOS 7**的用户，可参见RedHat的官方帮助文档： 14.3.6. Configuring Automatic Login 简单来说就是：vi /etc/gdm/custom.conf然后在[daemon]下面添加： 123[daemon]AutomaticLoginEnable=TrueAutomaticLogin=root #你想自动登录的用户名123 保存并重启，重启的时候已经以root用户登录了。 2. 删除用户删除用户可参见： CentOS 7用户账户配置 例如： userdel danyl 只删除用户，不删除相关的文件以及目录； userdel -rf danyl 强制删除danyl用户的所有文件及目录，请谨慎操作。 原文链接 https://blog.csdn.net/zdy1127/article/details/50659327?utm_source&#x3D;blogxgwz3","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"CentOS7","slug":"CentOS7","permalink":"http://jinyu.host/tags/CentOS7/"},{"name":"gnome","slug":"gnome","permalink":"http://jinyu.host/tags/gnome/"}]},{"title":"/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14' not found","slug":"0e37680e-b61a-4080-9cda-366518708bab","date":"2020-08-05T01:34:45.000Z","updated":"2020-08-05T01:34:45.000Z","comments":true,"path":"2020/08/05/0e37680e-b61a-4080-9cda-366518708bab/","link":"","permalink":"http://jinyu.host/2020/08/05/0e37680e-b61a-4080-9cda-366518708bab/","excerpt":"","text":"1.查看gcc版本中包含哪些库 1strings /usr/lib64/libstdc++.so.6 | grep GLIBC 1234567891011121314151617181920GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBC_2.2.5GLIBC_2.3GLIBC_2.4GLIBC_2.3.2GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH 可以看出不包含GLIBCXX_3.4.14 2.从网上下载高版本的libstdc++.so.6.0.13以上的版本，比如libstdc++.so.6.0.17 3.把libstdc++.so.6.0.17拷贝到&#x2F;usr&#x2F;lib64目录下 1cp libstdc++.so.6.0.17 /usr/lib64/ 4.删除libstdc++.so.6符号连接。 1rm libstdc++.so.6 5.新建里符号连接。 1ln -s libstdc++.so.6.0.17 libstdc++.so.6 6.再次查看就没有问题了。 原文链接 https://www.cnblogs.com/kumufengchun/p/10455537.html","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"VMware Workstation 与 Device/Credential Guard 不兼容.在禁用 Device/Credenti","slug":"7a33925a-f807-42a5-baba-00337d37a018","date":"2020-08-03T21:15:38.000Z","updated":"2020-08-03T21:15:38.000Z","comments":true,"path":"2020/08/04/7a33925a-f807-42a5-baba-00337d37a018/","link":"","permalink":"http://jinyu.host/2020/08/04/7a33925a-f807-42a5-baba-00337d37a018/","excerpt":"","text":"原文链接 https://www.cnblogs.com/navysummer/p/12792401.html","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jinyu.host/tags/Windows/"},{"name":"VMware","slug":"VMware","permalink":"http://jinyu.host/tags/VMware/"}]},{"title":"linux下查看端口占用","slug":"5eba6efc-5c95-4df9-bb2c-35b917e3acf2","date":"2020-08-03T20:50:30.000Z","updated":"2020-08-03T20:51:23.000Z","comments":true,"path":"2020/08/04/5eba6efc-5c95-4df9-bb2c-35b917e3acf2/","link":"","permalink":"http://jinyu.host/2020/08/04/5eba6efc-5c95-4df9-bb2c-35b917e3acf2/","excerpt":"","text":"1. lsof -i:端口号 用于查看某一端口的占用情况需要注意的是，centos默认是没有安装lsof（list open files）的，需要手动安装 1yum install lsof 各列代表的含义： COMMAND：进程的名称 PID：进程标识符 USER：进程所有者 FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等 TYPE：文件类型，如DIR、REG等 DEVICE：指定磁盘的名称 SIZE：文件的大小 NODE：索引节点（文件在磁盘上的标识） NAME：打开文件的确切名称 2. netstat -tunlp | grep 端口号，用于查看指定端口号的进程情况几个参数含义 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 原文链接 https://www.cnblogs.com/zjfjava/p/10513399.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"docker怎么导出导入镜像","slug":"7a329e6d-7623-4923-8a72-2fd44acc87e4","date":"2020-08-03T20:43:51.000Z","updated":"2020-08-03T20:43:51.000Z","comments":true,"path":"2020/08/04/7a329e6d-7623-4923-8a72-2fd44acc87e4/","link":"","permalink":"http://jinyu.host/2020/08/04/7a329e6d-7623-4923-8a72-2fd44acc87e4/","excerpt":"","text":"导出镜像如果要存出镜像到本地文件，可以使用docker save命令，例如，存储本地的ubuntu:14.04镜像为文件ubuntu_14.04.tar： 1sudo docker save -o /home/user/images/ubuntu_14.04.tar ubuntu:14.04 导入镜像可以使用docker load从存储的本地文件中再导入到本地镜像库，例如把文件ubuntu_14.04.tar导入镜像到本地镜像列表： 12345docker load --input /home/user/images/ubuntu_14.04.tar或docker load -i /home/user/images/ubuntu_14.04.tar或docker load &lt; /home/user/images/ubuntu_14.04.tar 原文链接 https://www.cnblogs.com/gcgc/p/10496059.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"}]},{"title":"Linux下使Shell命令脱离终端在后台运行","slug":"40684909-3919-426f-b59d-48e16f117a44","date":"2020-08-03T20:37:31.000Z","updated":"2020-08-03T20:37:31.000Z","comments":true,"path":"2020/08/04/40684909-3919-426f-b59d-48e16f117a44/","link":"","permalink":"http://jinyu.host/2020/08/04/40684909-3919-426f-b59d-48e16f117a44/","excerpt":"","text":"你是否遇到过这样的情况：从终端软件登录远程的Linux主机，将一堆很大的文件压缩为一个.tar.gz文件，连续压缩了半个小时还没有完成，这时，突然你断网了，你登录不上远程Linux主机了，那么前面的半个小时就会前功尽弃，你非常气愤…… 在Linux下，如果你要执行的shell命令耗时特别长，并且：（1）你的网络不稳定，随时可能断网；或者（2）你在执行了shell命令之后必须要关闭终端软件（例如SecureCRT）。 那么你就需要以脱离终端的方式在后台运行这个shell命令。 方法如下： 输入命令： 1nohup 你的shell命令 &amp; 回车，使终端回到shell命令行； 输入exit命令退出终端； 现在可以关闭你的终端软件了，等过足够的时间，让你的shell命令执行完了再上去看结果吧。 其中，nohup命令可以让你的shell命令忽略SIGHUP信号，即可以使之脱离终端运行；“&amp;”可以让你的命令在后台运行。 以脱离终端的方式在后台运行shell命令有这样几个好处：只要你执行过了命令，那么你的网络中断不会对你有任何影响，并且你就可以关闭终端软件了。 原文链接 http://www.linuxidc.com/Linux/2011-05/35723.htm","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"配置Linux终端走代理","slug":"959d97e6-4663-4fae-b334-dee6ffbc4721","date":"2020-08-03T20:31:32.000Z","updated":"2020-08-03T20:31:32.000Z","comments":true,"path":"2020/08/04/959d97e6-4663-4fae-b334-dee6ffbc4721/","link":"","permalink":"http://jinyu.host/2020/08/04/959d97e6-4663-4fae-b334-dee6ffbc4721/","excerpt":"","text":"以zsh为例： 1vim ~/.zshrc 添加如下配置： 1234# proxy list# 注意这里的端口号，要写成你自己的alias proxy=&#x27;exportalias proxy=&#x27;export all_proxy=socks5://127.0.0.1:1080&#x27;alias unproxy=&#x27;unset all_proxy&#x27; 输入下面的命令进行更新： 1source ~/.zshrc 在终端中执行命令，查看当前的IP地址： 1curl cip.cc 可以看到当前的IP地址 接着输入: 12proxycurl cip.cc 可以看到代理的地址，但可能还是原来的地址 不需要走代理的时候，可以在命令行输入unproxy进行关闭。 原文链接","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Proxy","slug":"Proxy","permalink":"http://jinyu.host/tags/Proxy/"},{"name":"zsh","slug":"zsh","permalink":"http://jinyu.host/tags/zsh/"}]},{"title":"Docker 部署 V2Ray","slug":"aa929808-2c37-4486-8813-69811a6f81ac","date":"2020-08-03T19:57:06.000Z","updated":"2020-08-03T19:57:06.000Z","comments":true,"path":"2020/08/04/aa929808-2c37-4486-8813-69811a6f81ac/","link":"","permalink":"http://jinyu.host/2020/08/04/aa929808-2c37-4486-8813-69811a6f81ac/","excerpt":"","text":"Docker 技术是一种新的虚拟化技术，和传统的虚拟化技术不同。V2Ray 同样提供 Docker 部署方式，并且通过 Docker 来部署 V2Ray 会非常轻松高效。 Docker 只能部署在 KVM 或者 XEN 架构的 VPS中 首先安装 Docker： 1$ sudo apt-get install -y docker 安装完 Docker 后我们从 DockerHub 通过搜索找到 V2Ray 官方提供的镜像， 链接在此. 找到拉取镜像的的命令并复制下来，在网页右侧我们可以看到命令为 docker pull v2ray/official ，我们将其复制下来回到命令行中粘贴并执行： 1$ sudo docker pull v2ray/official 待 V2Ray 的 Docker 镜像拉取完成后就可以进入下一个部署阶段. 在此之前，你需要在 &#x2F;etc 目录下新建一个文件夹 v2ray， 并把你的配置写好后命名为 config.json 放入 v2ray 文件夹内. 待配置文件准备就绪后键入以下命令进行部署，部署前请记下配置文件中你所设置的端口号，在部署时需要将其映射到宿主机上. 否则将无法访问. 此处假设设定的端口号为8888，需要映射到宿主机的8888端口上. 则命令为： 1$ sudo docker run -d --name v2ray -v /etc/v2ray:/etc/v2ray -p 8888:8888 v2ray/official v2ray -config=/etc/v2ray/config.json 键入以上命令后，命令行会出现一串字符，代表容器部署成功，可以立即通过客户端连接并开始使用了. 如果还不放心，键入以下命令来查看容器的运行状态： 1$ sudo docker container ls 如果看到输出的结果中有以下字段代表容器成功运行： 123$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2a7sdo87kdf3 v2ray/official &quot;v2ray -config=/et...&quot; 3 minutes ago Up 3 minutes 0.0.0.0:8888-&gt;8888/tcp v2ray 通过以下命令来启动 V2Ray： 1$ sudo docker container start v2ray 停止 V2Ray： 1$ sudo docker container stop v2ray 重启 V2Ray： 1$ sudo docker container restart v2ray 查看日志： 1$ sudo docker container logs v2ray 更新配置后，需要重新部署容器，命令如下： 123$ sudo docker container stop v2ray$ sudo docker container rm v2ray$ sudo docker run -d --name v2ray -v /etc/v2ray:/etc/v2ray -p 8888:8888 v2ray/official v2ray -config=/etc/v2ray/config.json 假如你的配置换了端口号，那么相应的端口映射也要更改，假如你在配置文件中把监听端口改为了9999，则’-p’参数应该这样写： 1-p 9999:9999 假如你想将容器中的端口映射到本机的端口，则命令应该这样写 1-p 127.0.0.1:端口号:端口号 如果 V2Ray 用的传输层协议是 mKCP，由于 mKCP 基于 UDP，那么需要指定映射的端口是 UDP： 1-p 9999:9999/udp 除非你打算使用Nginx来转发Websocket否则不需要映射到本地，直接填写端口号:端口号的形式即可 另外，如果开启了动态端口，-p 标记可以多次使用来绑定多个端口. 具体用法是在指令中再加上多个 -p 标记即可。 更新 V2Ray 的 Docker 镜像： 1$ docker pull v2ray/official 更新完之后，你需要重新部署容器，方法见上。 原文链接 https://toutyrater.github.io/app/docker-deploy-v2ray.html#docker-部署-v2ray","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"},{"name":"V2Ray","slug":"V2Ray","permalink":"http://jinyu.host/tags/V2Ray/"}]},{"title":"如何给docker设置http代理","slug":"cc8a0bdb-ce18-4d8a-bbc0-b16ab9e329a2","date":"2020-08-03T19:51:13.000Z","updated":"2020-08-03T19:51:13.000Z","comments":true,"path":"2020/08/04/cc8a0bdb-ce18-4d8a-bbc0-b16ab9e329a2/","link":"","permalink":"http://jinyu.host/2020/08/04/cc8a0bdb-ce18-4d8a-bbc0-b16ab9e329a2/","excerpt":"","text":"公司网络使用代理服务器上外网。在ubuntu上用docker pull出现错误 1234$sudo docker pull busyboxUsing default tag: latestPulling repository docker.io/library/busyboxNetwork timed out while trying to connect to https://index.docker.io/v1/repositories/library/busybox/images. You may want to check your internet connection or if you are behind a proxy. 但是我明明已经为ubuntu设置了http_proxy了。 查了试了半天，才知道还需要给docker单独设代理，以下是步骤。 First, create a systemd drop-in directory for the docker service: 1mkdir /etc/systemd/system/docker.service.d Now create a file called /etc/systemd/system/docker.service.d/http-proxy.conf that adds the HTTP_PROXY environment variable: 12[Service]Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot; If you have internal Docker registries that you need to contact without proxying you can specify them via the NO_PROXY environment variable: 12Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.0/8,docker-registry.somecorporation.com&quot; Flush changes: 1$ sudo systemctl daemon-reload Verify that the configuration has been loaded: 12$ sudo systemctl show docker --property EnvironmentEnvironment=HTTP_PROXY=http://proxy.example.com:80/ Restart Docker: 1$ sudo systemctl restart docker 现在好使了。 123456$sudo docker pull busyboxUsing default tag: latestlatest: Pulling from library/busybox8ddc19f16526: Pull completeDigest: sha256:a59906e33509d14c036c8678d687bd4eec81ed7c4b8ce907b888c607f6a1e0e6Status: Downloaded newer image for busybox:latest 原文链接 https://blog.csdn.net/chang_harry&#x2F;article&#x2F;details&#x2F;52116305?utm_source&#x3D;blogxgwz2","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"},{"name":"Proxy","slug":"Proxy","permalink":"http://jinyu.host/tags/Proxy/"}]},{"title":"scp 报错 not a regular file","slug":"559fc0e3-7c13-4e34-9b54-6968a53782e0","date":"2020-08-03T02:09:27.000Z","updated":"2020-08-03T02:09:27.000Z","comments":true,"path":"2020/08/03/559fc0e3-7c13-4e34-9b54-6968a53782e0/","link":"","permalink":"http://jinyu.host/2020/08/03/559fc0e3-7c13-4e34-9b54-6968a53782e0/","excerpt":"","text":"原因：这样相当于下载文件夹，而非文件解决办法：添加参数 -r 1scp -r D:\\testFile root@192.168.0.129:~ 原文链接 https://blog.csdn.net/dafei4/article/details/79494324","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"解决 VMware 克隆或复制的虚拟机，同时只有一台能上网问题","slug":"2e64b2d4-e06b-4db0-96cf-c4ca1f9497d1","date":"2020-08-02T03:41:17.000Z","updated":"2020-08-02T03:41:17.000Z","comments":true,"path":"2020/08/02/2e64b2d4-e06b-4db0-96cf-c4ca1f9497d1/","link":"","permalink":"http://jinyu.host/2020/08/02/2e64b2d4-e06b-4db0-96cf-c4ca1f9497d1/","excerpt":"","text":"VMware 克隆或复制虚拟机后，发现不能上网。多次调试后，确定是克隆或复制的虚拟机与原虚拟机，同时只能有一台能上网。 原因是：克隆或复制的虚拟机，网卡 MAC 地址一样导致。 重新分配的新 MAC 地址即可，方法如下： 打开 Vmware Workstation（相关虚拟机在关闭的状态）。 编辑虚拟机设置 “硬件” 选项卡 网络适配器 右侧 “高级” 按钮 MAC 地址，点击 “生成” 按钮，重新生成 MAC 地址 一路确定，即可。 原文链接 https://blog.csdn.net/JohnnySun2015/article/details/106069760/","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"VMware","slug":"VMware","permalink":"http://jinyu.host/tags/VMware/"}]},{"title":"Linux开机自启Docker和容器","slug":"44c2e98a-c4e3-490a-a35c-9f514b0fa6f2","date":"2020-08-02T03:34:11.000Z","updated":"2020-08-02T03:34:11.000Z","comments":true,"path":"2020/08/02/44c2e98a-c4e3-490a-a35c-9f514b0fa6f2/","link":"","permalink":"http://jinyu.host/2020/08/02/44c2e98a-c4e3-490a-a35c-9f514b0fa6f2/","excerpt":"","text":"设置docker开机自启 1systemctl enable docker 设置容器开机自启 1docker update [containerName or containerID] --restart=always 关闭容器开机自启 1docker update [containerName or containerID] --restart=no","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"}]},{"title":"Error response from daemon: conflict: unable to delete","slug":"fc2e44a0-ca11-43da-a17f-80897f8d9f15","date":"2020-08-02T03:00:44.000Z","updated":"2020-08-02T03:00:44.000Z","comments":true,"path":"2020/08/02/fc2e44a0-ca11-43da-a17f-80897f8d9f15/","link":"","permalink":"http://jinyu.host/2020/08/02/fc2e44a0-ca11-43da-a17f-80897f8d9f15/","excerpt":"","text":"使用 1docker rmi -f [image_ID] 原文链接 https://blog.csdn.net/weixin_40720226&#x2F;article&#x2F;details&#x2F;88997521","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"}]},{"title":"查看并修改Linux主机名","slug":"08af8884-1254-416d-bf50-da6a57650093","date":"2020-08-01T01:48:52.000Z","updated":"2020-08-01T01:48:52.000Z","comments":true,"path":"2020/08/01/08af8884-1254-416d-bf50-da6a57650093/","link":"","permalink":"http://jinyu.host/2020/08/01/08af8884-1254-416d-bf50-da6a57650093/","excerpt":"","text":"查看 1cat /etc/hostname 修改 1hostnamectl set-hostname [hostname]","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"windows的cmd使用ssh连接很慢","slug":"c487ed33-99c0-4147-b35c-3945b5decb02","date":"2020-07-30T18:43:45.000Z","updated":"2020-07-30T18:46:30.000Z","comments":true,"path":"2020/07/31/c487ed33-99c0-4147-b35c-3945b5decb02/","link":"","permalink":"http://jinyu.host/2020/07/31/c487ed33-99c0-4147-b35c-3945b5decb02/","excerpt":"","text":"1.DNS反向解析的问题OpenSSH在用户登录的时候会验证IP，它根据用户的IP使用反向DNS找到主机名，再使用DNS找到IP地址，最后匹配一下登录的IP是否合法。如果客户机的IP没有域名，或者DNS服务器很慢或不通，那么登录就会很花时间。 解决办法：只需修改 &#x2F;etc&#x2F;ssh&#x2F;sshd_config ，设置UseDNS为no即可： 1sed -i &quot;s/#UseDNS yes/UseDNS no/&quot; /etc/ssh/sshd_config 2.gssapi的问题用ssh -v user@server 可以看到登录时有如下信息： 12debug1: Next authentication method: gssapi-with-micdebug1: Unspecified GSS failure. Minor code may provide more information 解决办法： 登录时，添加参数，使GSSAPIAuthentication为no 1ssh -o GSSAPIAuthentication=no user@server 也可以修改 &#x2F;etc&#x2F;ssh&#x2F;sshd_config ，设置GSSAPIAuthentication no 3.编辑完后重启ssh服务1service sshd restart 参考链接1 参考链接2 参考链接3","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jinyu.host/tags/Windows/"},{"name":"SSH","slug":"SSH","permalink":"http://jinyu.host/tags/SSH/"}]},{"title":"修改npm镜像地址为国内淘宝镜像","slug":"ca715dab-add9-4031-a357-6f3045986752","date":"2020-07-30T01:40:15.000Z","updated":"2020-07-30T01:40:21.000Z","comments":true,"path":"2020/07/30/ca715dab-add9-4031-a357-6f3045986752/","link":"","permalink":"http://jinyu.host/2020/07/30/ca715dab-add9-4031-a357-6f3045986752/","excerpt":"","text":"1npm config set registry https://registry.npm.taobao.org 原文链接 https://blog.csdn.net/weixin_38201728&#x2F;article&#x2F;details&#x2F;105130578","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://jinyu.host/tags/npm/"}]},{"title":"nodejs下载安装及配置环境","slug":"6e3eca24-a447-4eb7-97d7-5835c5de6460","date":"2020-07-30T01:38:32.000Z","updated":"2020-07-30T01:38:32.000Z","comments":true,"path":"2020/07/30/6e3eca24-a447-4eb7-97d7-5835c5de6460/","link":"","permalink":"http://jinyu.host/2020/07/30/6e3eca24-a447-4eb7-97d7-5835c5de6460/","excerpt":"","text":"https://blog.csdn.net/qq_43285335/article/details/90696126","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://jinyu.host/tags/Node-js/"}]},{"title":"vue利用vue ui命令创建项目","slug":"05ad2ff9-b521-4780-a8e2-a049124ffbfe","date":"2020-07-30T01:37:14.000Z","updated":"2020-07-30T01:37:14.000Z","comments":true,"path":"2020/07/30/05ad2ff9-b521-4780-a8e2-a049124ffbfe/","link":"","permalink":"http://jinyu.host/2020/07/30/05ad2ff9-b521-4780-a8e2-a049124ffbfe/","excerpt":"","text":"https://blog.csdn.net/weixin_40688217/article/details/88321322","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://jinyu.host/tags/Vue/"}]},{"title":"Git提交时出现Merge branch 'master' of ...之解决方法","slug":"e767438b-a2d3-4e45-9f2e-51cefcf8125e","date":"2020-07-30T01:35:23.000Z","updated":"2020-07-30T01:35:23.000Z","comments":true,"path":"2020/07/30/e767438b-a2d3-4e45-9f2e-51cefcf8125e/","link":"","permalink":"http://jinyu.host/2020/07/30/e767438b-a2d3-4e45-9f2e-51cefcf8125e/","excerpt":"","text":"多人协作开发项目，在上传代码时通常会先pull一下远程代码，使本地与远程同步更新，但是如果远程此时与自己代码存在冲突，在解决冲突后提交有时会出现“Merge branch ‘master’ of …”这条信息。这是因为pull其本质是fetch+Merge的结合。通常会分为以下两种情况： 1.如果远程分支超前于本地分支，并且本地也没有commit操作，此时pull会采用’fast-forward’模式，该模式不会产生合并节点，也即不产生”Merge branch ‘master’ of …”信息。 2.如果本地有commit提交，此时若存在冲突，pull拉取代码时远程和本地会出现分叉，会进行分支合并，就会产生”Merge branch ‘master’ of …”信息。 解决方法 使用git pull –rebase命令，如果没有冲突,则会直接合并，如果存在冲突，手动解决冲突即可，不会再产生那条多余的信息。如果你不想每次都rebase，可以在git bash里执行 1git config --global pull.rebase true 这个配置就是告诉git在每次pull前先进行rebase操作。 原文链接 https://blog.csdn.net/weixin_44202659&#x2F;article&#x2F;details&#x2F;103841807","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"git","slug":"git","permalink":"http://jinyu.host/tags/git/"}]},{"title":"Module build failed: Error: Node Sass does not yet support your current environment: OS X 64-bit wit","slug":"1eb4449c-70fd-4949-804a-f4ca2b9945c0","date":"2020-07-30T01:26:45.000Z","updated":"2020-07-30T01:32:07.000Z","comments":true,"path":"2020/07/30/1eb4449c-70fd-4949-804a-f4ca2b9945c0/","link":"","permalink":"http://jinyu.host/2020/07/30/1eb4449c-70fd-4949-804a-f4ca2b9945c0/","excerpt":"","text":"解决办法其实很简单，就是sass不支持当前的环境，那么在当前环境重新安装一下就好了 先卸载：（如果卸载不成功，直接找到node-sass文件夹，删除） 1npm uninstall --save node-sass 再安装 123npm install --save node-sass# 或cnpm install --save node-sass 安装cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 作者：triumphperson链接：https://www.jianshu.com/p/bc31cc894de2來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://jinyu.host/tags/Vue/"},{"name":"Node.js","slug":"Node-js","permalink":"http://jinyu.host/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"http://jinyu.host/tags/npm/"}]},{"title":"Windows开机自启VMware和虚拟机","slug":"c28dbf42-9bee-481c-9f31-a44e13ed51b3","date":"2020-07-30T01:01:42.000Z","updated":"2020-07-30T01:01:42.000Z","comments":true,"path":"2020/07/30/c28dbf42-9bee-481c-9f31-a44e13ed51b3/","link":"","permalink":"http://jinyu.host/2020/07/30/c28dbf42-9bee-481c-9f31-a44e13ed51b3/","excerpt":"","text":"1.编辑脚本文件找到VMware的安装目录和虚拟机存放的目录： 1234# VMwareD:\\@Software\\vmware\\# CentOS7D:\\@VM\\CentOS7_64_1\\ 新建文件vm_start.bat，并编辑 1&quot;D:\\@Software\\vmware\\vmrun.exe&quot; start &quot;D:\\@VM\\CentOS7_64_1\\CentOS7_1.vmx&quot; nogui 2.登录脚本win+r -&gt; gpedit.msc -&gt; 用户配置 -&gt; windows设置 -&gt; 脚本(登录&#x2F;注销) -&gt; 添加","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jinyu.host/tags/Windows/"},{"name":"VMware","slug":"VMware","permalink":"http://jinyu.host/tags/VMware/"},{"name":".bat","slug":"bat","permalink":"http://jinyu.host/tags/bat/"}]},{"title":"windows系统如何查看端口被占用、杀进程","slug":"dfac4456-1ebd-439b-a266-e0b6b695a1d2","date":"2020-07-16T21:16:28.000Z","updated":"2020-07-16T21:16:28.000Z","comments":true,"path":"2020/07/17/dfac4456-1ebd-439b-a266-e0b6b695a1d2/","link":"","permalink":"http://jinyu.host/2020/07/17/dfac4456-1ebd-439b-a266-e0b6b695a1d2/","excerpt":"","text":"打开cmd，查看指定端口 1netstat -ano |findstr &quot;端口号&quot; 通过上句命令获得pid，可以根据pid找到进程名 1tasklist |fidstr &quot;进程id&quot; 想要杀掉进程可以根据进程id或进程名 1taskkill /f /t /im &quot;进程id/进程名&quot; 杀掉占用端口进程后再次查看此端口是否已空闲 1netstat -ano |findstr &quot;端口号&quot; 原文链接 https://jingyan.baidu.com/article/fdffd1f89a0c8af3e98ca10e.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jinyu.host/tags/Windows/"},{"name":"cmd","slug":"cmd","permalink":"http://jinyu.host/tags/cmd/"}]},{"title":"分布式事务之深入理解什么是2PC、3PC及TCC协议？","slug":"1c5fbe93-aacc-40db-a4f5-b15f8baaba22","date":"2020-07-12T01:16:45.000Z","updated":"2020-07-12T01:16:45.000Z","comments":true,"path":"2020/07/12/1c5fbe93-aacc-40db-a4f5-b15f8baaba22/","link":"","permalink":"http://jinyu.host/2020/07/12/1c5fbe93-aacc-40db-a4f5-b15f8baaba22/","excerpt":"","text":"0.导读在上一篇文章《【分布式事务】基于RocketMQ搭建生产级消息集群？》中给大家介绍了基于RocketMQ如何搭建生产级消息集群。因为本系列文章最终的目的是介绍基于RocketMQ的事物消息来解决分布式系统中的数据一致性问题，所以先给大家率先介绍了RocketMQ消息集群的搭建。 原本是想着在这篇文章中直接介绍RocketMQ的事务消息特性，但是在梳理的过程中作者发现对于分布式事务的概念，可能还会有很多同学不理解或者理解得不是很深刻的地方，而跳过这些基本概念直接去学习上层的实践可能并不是一件很好的事情，因此在这篇文章中，作者打算重点给大家先介绍下分布式事务相关的基本概念，诸如分布式事务、2PC、3PC、TCC之类的基本问题，之后再单独去介绍RocketMQ事务消息相关的实践。 1.数据库事务的概念在讲述分布式事务的概念之前，我们先来回顾下事务相关的一些概念。 1.1.事务的基本概念：就是一个程序执行单元，里面的操作要么全部执行成功，要么全部执行失败，不允许只成功一半另外一半执行失败的事情发生。例如一段事务代码做了两次数据库更新操作，那么这两次数据库操作要么全部执行成功，要么全部回滚。 1.2.事务的基本特性：我们知道事务有4个非常重要的特性，即我们常说的（ACID）。 Atomicity（原子性）:是说事务是一个不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作出错，回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态。 Consistency（一致性）：是说事务执行前后，数据从一个状态到另一个状态必须是一致的，比如A向B转账（ A、B的总金额就是一个一致性状态），不可能出现A扣了钱，B却没收到的情况发生。 Isolation（隔离性）： 多个并发事务之间相互隔离，不能互相干扰。关于事务的隔离性，可能不是特别好理解，这里的并发事务是指两个事务操作了同一份数据的情况；而对于并发事务操作同一份数据的隔离性问题，则是要求不能出现脏读、幻读的情况，即事务A不能读取事务B还没有提交的数据，或者在事务A读取数据进行更新操作时，不允许事务B率先更新掉这条数据。而为了解决这个问题，常用的手段就是加锁了，对于数据库来说就是通过数据库的相关锁机制来保证。 Durablity（持久性）：事务完成后，对数据库的更改是永久保存的，不能回滚。 关于数据库事务的基本概念大家可以去网上搜一下，这里只是给大家回顾下事务的基本概念及特性，诸如事务并发问题、事务隔离级别等大家如有遗忘可以去回顾下（tips：面试经常会问到的问题哦）。 1.3.什么是分布式事务？以上内容我们回顾了下事务的基本概念，那么分布式事务又是个什么概念呢？它与数据库事务之间又有什么区别呢？ 其实分布式事务从实质上看与数据库事务的概念是一致的，既然是事务也就需要满足事务的基本特性（ACID），只是分布式事务相对于本地事务而言其表现形式有很大的不同。举个例子，在一个JVM进程中如果需要同时操作数据库的多条记录，而这些操作需要在一个事务中，那么我们可以通过数据库提供的事务机制（一般是数据库锁）来实现。 而随着这个JVM进程（应用）被拆分成了微服务架构，原本一个本地逻辑执行单元被拆分到了多个独立的微服务中，这些微服务又分别操作不同的数据库和表，服务之间通过网络调用。 举个例子：服务A收到一笔购物下单请求后，需要调用服务B去支付，支付成功则处理购物订单为待发货状态，否则就需要将购物订单处理为失败状态。（如图所示） 在上面这个例子中会不会出现服务B支付成功了，但是由于网络调用的问题没有通知到服务A，导致用户付了钱，但是购物订单无法显示支付成功的状态呢？ 答案是这种情况是普遍存在的，因为服务B在处理成功后需要向服务A发送网络请求，而这个过程是极有可能失败的。那么如何确保“服务A-&gt;服务B”这个过程能够组成一个事务，要么全部成功、要么全部失败呢？而这就是典型的需要通过分布式事务解决的问题。 分布式事务是为了解决微服务架构（形式都是分布式系统）中不同节点之间的数据一致性问题。这个一致性问题本质上解决的也是传统事务需要解决的问题，即一个请求在多个微服务调用链中，所有服务的数据处理要么全部成功，要么全部回滚。当然分布式事务问题的形式可能与传统事务会有比较大的差异，但是问题本质是一致的，都是要求解决数据的一致性问题。 而分布式事务的实现方式有很多种，最具有代表性的是由Oracle Tuxedo系统提出的XA分布式事务协议。XA协议包括两阶段提交（2PC）和三阶段提交（3PC）两种实现，接下来我们分别来介绍下这两种实现方式的原理。 1.3.1.两阶段提交（2PC）两阶段提交又称2PC（two-phase commit protocol）,2pc是一个非常经典的强一致、中心化的原子提交协议。这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（partcipant）。 下面我们就以一个尽量贴近实际业务场景的操作来举例：”假设在一个分布式架构的系统中事务的发起者通过分布式事务协调者（如RocketMQ，在早期RocketMQ版本不提供事务消息特性时，有些公司会自己研发一个基于MQ的可靠消息服务来实现一定的分布式事务的特性）分别向应用服务A、应用服务B发起处理请求，二者在处理的过程中会分别操作自身服务的数据库，现在要求应用服务A、应用服务B的数据处理操作要在一个事务里”? 在上面这个例子中如果采用两阶段提交来实现分布式事务，那么其运行原理应该是个什么样的呢？（如?）： 第一阶段：请求&#x2F;表决阶段（点击放大） 既然称为两阶段提交，说明在这个过程中是大致存在两个阶段的处理流程。第一个阶段如?图所示，这个阶段被称之为请求&#x2F;表决阶段。是个什么意思呢？ 就是在分布式事务的发起方在向分布式事务协调者（Coordinator）发送请求时，Coordinator首先会分别向参与者（Partcipant）节点A、参与这节点（Partcipant）节点B分别发送事务预处理请求，称之为Prepare，有些资料也叫”Vote Request“。 说的直白点就是问一下这些参与节点”这件事你们能不能处理成功了“，此时这些参与者节点一般来说就会打开本地数据库事务，然后开始执行数据库本地事务，但在执行完成后并不会立马提交数据库本地事务，而是先向Coordinator报告说：“我这边可以处理了&#x2F;我这边不能处理”。 如果所有的参与这节点都向协调者作了“Vote Commit”的反馈的话，那么此时流程就会进入第二个阶段了。 第二阶段：提交&#x2F;执行阶段（正常流程） 如果所有参与者节点都向协调者报告说“我这边可以处理”，那么此时协调者就会向所有参与者节点发送“全局提交确认通知（global_commit）”，即你们都可以进行本地事务提交了，此时参与者节点就会完成自身本地数据库事务的提交，并最终将提交结果回复“ack”消息给Coordinator，然后Coordinator就会向调用方返回分布式事务处理完成的结果。 第二阶段：提交&#x2F;执行阶段（异常流程） 相反，在二阶段除了所有的参与者节点都反馈“我这边可以处理了”的情况外，也会有节点反馈说“我这边不能处理”的情况发生，此时参与者节点就会向协调者节点反馈“Vote_Abort”的消息。此时分布式事务协调者节点就会向所有的参与者节点发起事务回滚的消息（“global_rollback”），此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送“ack”确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果。 以上就是两阶段提交的基本过程了，那么按照这个两阶段提交协议，分布式系统的数据一致性问题就能得到满足吗？ 实际上分布式事务是一件非常复杂的事情，两阶段提交只是通过增加了事务协调者（Coordinator）的角色来通过2个阶段的处理流程来解决分布式系统中一个事务需要跨多个服务节点的数据一致性问题。但是从异常情况上考虑，这个流程也并不是那么的无懈可击。 假设如果在第二个阶段中Coordinator在接收到Partcipant的**”Vote_Request”后挂掉了或者网络出现了异常，那么此时Partcipant节点就会一直处于本地事务挂起的状态，从而长时间地占用资源**。当然这种情况只会出现在极端情况下，然而作为一套健壮的软件系统而言，异常Case的处理才是真正考验方案正确性的地方。 以下几点是XA-两阶段提交协议中会遇到的一些问题： 性能问题。从流程上我们可以看得出，其最大缺点就在于它的执行过程中间，节点都处于阻塞状态。各个操作数据库的节点此时都占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大。 协调者单点故障问题。事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚的通知，从而导致参与者节点始终处于事务无法完成的中间状态。 丢失消息导致的数据不一致问题。在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题。 既然两阶段提交有以上问题，那么有没有其他的方案来解决呢？ 1.3.2.三阶段提交（3PC）三阶段提交又称3PC，其在两阶段提交的基础上增加了CanCommit阶段，并引入了超时机制。一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。 但是性能问题和不一致问题仍然没有根本解决。下面我们还是一起看下三阶段流程的是什么样的？ 第一阶段：CanCommit阶段 这个阶段类似于2PC中的第二个阶段中的Ready阶段，是一种事务询问操作，事务的协调者向所有参与者询问“你们是否可以完成本次事务？”，如果参与者节点认为自身可以完成事务就返回“YES”，否则“NO”。而在实际的场景中参与者节点会对自身逻辑进行事务尝试，其实说白了就是检查下自身状态的健康性，看有没有能力进行事务操作。 第二阶段：PreCommit阶段 在阶段一中，如果所有的参与者都返回Yes的话，那么就会进入PreCommit阶段进行事务预提交。此时分布式事务协调者会向所有的参与者节点发送PreCommit请求，参与者收到后开始执行事务操作，并将Undo和Redo信息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。 否则，如果阶段一中有任何一个参与者节点返回的结果是No响应，或者协调者在等待参与者节点反馈的过程中超时（2PC中只有协调者可以超时，参与者没有超时机制）。整个分布式事务就会中断，协调者就会向所有的参与者发送“abort”请求。 第三阶段：DoCommit阶段 在阶段二中如果所有的参与者节点都可以进行PreCommit提交，那么协调者就会从“预提交状态”-》“提交状态”。然后向所有的参与者节点发送**”doCommit”请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”**消息，协调者收到所有参与者的Ack消息后完成事务。 相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。 看到这里，你是不是会疑惑**”3PC相对于2PC而言到底优化了什么地方呢?”** 相比较2PC而言，3PC对于协调者（Coordinator）和参与者（Partcipant）都设置了超时时间，而2PC只有协调者才拥有超时机制。这解决了一个什么问题呢？这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。 另外，通过CanCommit、PreCommit、DoCommit三个阶段的设计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的。 以上就是3PC相对于2PC的一个提高（相对缓解了2PC中的前两个问题），但是3PC依然没有完全解决数据不一致的问题。 1.3.3.补偿事务（TCC）说起分布式事务的概念，不少人都会搞混淆，似乎好像分布式事务就是TCC。实际上TCC与2PC、3PC一样，只是分布式事务的一种实现方案而已。 TCC（Try-Confirm-Cancel）又称补偿事务。其核心思想是：”针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）”。它分为三个操作： Try阶段：主要是对业务系统做检测及资源预留。 Confirm阶段：确认执行业务操作。 Cancel阶段：取消执行业务操作。 TCC事务的处理流程与2PC两阶段提交类似，不过2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。 而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口还必须实现幂等。 TCC的具体原理图如?： 1.3.4.消息队列MQ事务在前面介绍2PC、3PC的时候我们说没有根本解决性能问题，而如果通过MQ的事务消息来进行异步解耦，并实现系统的数据的最终一致性的话会不会好很多呢？实际上这就是我们下一篇文章要继续讲述的《分布式事务之如何基于RocketMQ的事务消息特性实现分布式系统的最终一致性？》。敬请期待！ 原文链接 https://www.cnblogs.com/wudimanong/p/10340948.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"分布式事务","slug":"分布式事务","permalink":"http://jinyu.host/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"}]},{"title":"GC分代年龄为什么是15？","slug":"b9eb422e-ff4e-4104-8a0f-1c35a4d1f922","date":"2020-07-11T22:19:09.000Z","updated":"2020-07-12T01:17:01.000Z","comments":true,"path":"2020/07/12/b9eb422e-ff4e-4104-8a0f-1c35a4d1f922/","link":"","permalink":"http://jinyu.host/2020/07/12/b9eb422e-ff4e-4104-8a0f-1c35a4d1f922/","excerpt":"","text":"在JVM中，对象在Eden区诞生，当内存不够用时触发GC进行对象回收，但不是所有的对象都可以被回收，当一个对象还在被引用时就无法回收，此时JVM会将其移动到“幸存者区”。 幸存者区内部又分为“From区”和“To区”，在幸存者区，对象仍然要面临GC，每经历一次GC，对象就要在From区和To区之间来回移动，每移动一次对象的GC年龄就加1，当年龄加到15时(不绝对)，JVM会将对象移动到老年区。 JAVA对象结构对象的GC年龄肯定和对象相关，信息肯定保存在对象的某块区域，我们平时看不到是因为Java对开发者屏蔽了一些数据。 我们平时写代码，编写的只是对象的实例数据，但其实Java对象除了自身的实例数据外，还包括头信息和对齐字节，如下图所示： 对象的GC年龄就保存在对象的头信息里，除此之外，头信息还记录了对象的锁标记，大家常常说的“Java锁的是对象而不是代码”就是这个道理，上锁修改的是头信息中的锁标记。 对象的头信息内存分配不同的JVM实现不一样，一般来说32位占8字节，64位占16字节(开启压缩指针占12字节)。 头信息分为以下两个部分： Mark Word Klass Pointer Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向的线程ID等数据。 由于需要考虑到JVM的空间效率，节省内存，Mark Word 被设计成在一个“非固定的数据结构”，以便在极小的空间内记录更多的数据。 简而言之：不同的标记位表示Mark Word存储的数据意义不同，如下图： 我在Mac上测试，显示Mark Word占用8个字节。 Klass PointerKlass Pointer是一个指向了实例的类元数据指针，JVM通过这个指针来判断对象属于哪一个类的实例。 内存固定，在64位JVM上采用4个字节存储。 如何证明上面说的只是理论，直到现在我们都没有看到对象的头信息，对齐字节，对象的年龄，如何来证明理论是对的呢？ OpenJDK提供了一个工具包，可以输出对象的结构布局信息。 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt; 编写一段测试代码，如下：123456789101112131415161718192021222324/** * @Author: pch * @Date: 2019/12/23 09:08 * @Description: 查看对象的头信息 */public class HeaderTest &#123; public static void main(String[] args) throws InterruptedException &#123; Person p = new Person(); //不调用hashCode() 不会记录哈希码 int hashCode = p.hashCode(); //转16进制输出，与头信息中HashCode进行比较 String hex = Integer.toHexString(hashCode); System.out.println(&quot;HashCode十六进制:&quot;+hex); print(p); &#125; static void print(Person p)&#123; System.err.println(ClassLayout.parseInstance(p).toPrintable()); &#125;&#125;class Person&#123; private boolean flag;&#125; 控制台输出如下： 至于为什么数据是倒着存储的，请参考“大小端模式”。 笔者对控制台输出的内容作了部分注释，其实到这里答案已经有了。 GC分代年龄为什么最大为15？因为Object Header采用4个bit位来保存年龄，4个bit位能表示的最大数就是15！ 如何证明GC后年龄会加1手动触发一次GC即可。 测试代码如下： 1234Person p = new Person();//手动触发GCSystem.gc();print(p); 控制台输出： 不是必须到达15岁才会晋升为老年代，JVM采用动态年龄计算，以防止老年代内存过于宽裕，而新生代内存被撑爆。 原文链接 https://blog.csdn.net/qq_32099833&#x2F;article&#x2F;details&#x2F;103721326","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://jinyu.host/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"http://jinyu.host/tags/GC/"}]},{"title":"Runnable 和Callable区别","slug":"55392537-cb68-47d2-af11-2a98a70c0ae8","date":"2020-07-11T22:01:05.000Z","updated":"2020-07-12T01:17:07.000Z","comments":true,"path":"2020/07/12/55392537-cb68-47d2-af11-2a98a70c0ae8/","link":"","permalink":"http://jinyu.host/2020/07/12/55392537-cb68-47d2-af11-2a98a70c0ae8/","excerpt":"","text":"Java 提供了三种创建线程的方法 通过实现Runnable接口 通过继承Thread接口 通过Callable和Future创建线程 通过实现 Runnable 接口来创建线程123456789101112131415161718192021222324public class RunnableDemo &#123; public static void main(String[] args) &#123; new Thread(new MyThread(),&quot;线程1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125; &#125;,&quot;线程2&quot;).start(); &#125;&#125;/** * 实现 Runnable 接口的线程类 */class MyThread implements Runnable&#123; /** * 重写run方法 */ @Override public void run() &#123; // TODO Auto-generated method stub &#125;&#125; 通过继承Thread类123456789101112131415161718public class ThreadDemo &#123; public static void main(String[] args) &#123; new MyThread().start(); new Thread(new MyThread(), &quot;线程2&quot;).start(); &#125;&#125;class MyThread extends Thread&#123; /** * 重写run方法 */ @Override public void run() &#123; // TODO Auto-generated method stub super.run(); &#125;&#125; 通过Callable和Future创建线程1234567891011121314151617181920212223242526272829303132public class FutureDemo &#123; public static void main(String[] args) &#123; //创建 Callable 实现类的实例 MyCallable myCallable = new MyCallable(); //使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值 FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(myCallable); String res = null; try &#123; //使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程 //没这句，下句代码获取不到结果，会一直等待执行结果 new Thread(futureTask,&quot;线程1&quot;).start(); //调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值 res = futureTask.get(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(res); &#125;&#125;/** * 创建 Callable 接口的实现类，并实现 call() 方法 */class MyCallable implements Callable&lt;String&gt;&#123; /** * 该call()方法将作为线程执行体，并且有返回值 */ @Override public String call() throws Exception &#123; return &quot;success&quot;; &#125;&#125; Runnable 和Callable区别 方法名 ExecutorService的执行方法 ExecutorService.submit()返回值 返回的Future调用get()方法 线程体 取消执行 Runnable execute和submit Future null run() 不能 Callable 只能是submit Future Future定义的泛型T call() Future.cancel能取消执行 原文链接：https://blog.csdn.net/u012894692/article/details/80215140","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"http://jinyu.host/tags/Thread/"}]},{"title":"从单例模式到Happens-Before","slug":"dffd3f88-7baa-4f10-8d15-d9d8b1fc0c2a","date":"2020-07-11T21:52:15.000Z","updated":"2020-07-12T01:17:17.000Z","comments":true,"path":"2020/07/12/dffd3f88-7baa-4f10-8d15-d9d8b1fc0c2a/","link":"","permalink":"http://jinyu.host/2020/07/12/dffd3f88-7baa-4f10-8d15-d9d8b1fc0c2a/","excerpt":"","text":"本文主要从简单的单例模式为切入点，分析单例模式可能存在的一些问题，以及如何借助Happens-Before分析、检验代码在多线程环境下的安全性。 知识准备为了后面叙述方便，也为了读者理解文章的需要，先在这里解释一下牵涉到的知识点以及相关概念。 线程内表现为串行的语义 Within Thread As-If-Serial Semantics 定义普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 举个小栗子看代码 123int a = 1;int b = 2;int c = a + b; 大家看完代码没准就猜到我想要说什么了。 假如没有重排序这个东西，CPU肯定会按照从上往下的执行顺序执行：先执行 a = 1、然后b = 2、最后c = a + b，这也符合我们的阅读习惯。 但是，上文也提及了：CPU为了提高运行效率，在执行时序上不会按照刚刚所说的时序执行，很有可能是b = 2 a = 1 c = a + b。对，因为只需要在变量c需要变量a``b的时候能够得到正确的值就行了，JVM允许这样的行为。 这种现象就是线程内表现为串行的语义。 重排序定义指令重排序 为了提高运行效率，CPU允许讲多条指令不按照程序规定的顺序分开发送给各相应电路单元处理。 这里需要注意的是指令重排序并不是将指令任意的发送给电路单元，而是需要满足线程内表现为串行的语义 现象参照线程内表现为串行的语义一节中举的小栗子。 注意任何代码都有可能出现指令重排序的现象，与是否多线程条件下无关。在单线程内感受不到是因为单线程内会有线程内表现为串行的语义的限制。 Happens-Before（先行发生）什么是Happens-BeforeHappens-Before原则是判断数据是否存在竞争、线程是否安全的主要依据。 为了叙述方便，如果操作X Happens-Before 操作Y，那么我们记为 hb(X,Y)。 如果存在hb(a,b)，那么操作a在内存上面所做的操作（如赋值操作等）都对操作b可见，即操作a影响了操作b。 是Java内存模型中定义的两项操作之间的偏序关系，满足偏序关系的各项性质 我们都知道偏序关系中有一条很重要的性质：传递性，所以Happens-Before也满足传递性。这个性质非常重要，通过这个性质可以推导出两个没有直接联系的操作之间存在Happens-Before关系，如： 如果存在hb(a,b)和hb(b,c)，那么我们可以推导出hb(a,c)，即操作a Happens-Before 操作c。 是判断数据是否存在竞争、线程是否安全的主要依据 这是《深入理解Java虚拟机》，375页的例子 12345i = 1; //在线程A中执行 j = i; //在线程B中执行 i = 2; //在线程C中执行 假设线程A中的操作i = 1先行发生线程B的操作j = i，那么可以确定在线程B的操作执行后，变量j的值一定等于1，得出这个结论的依据有两个：一是根据先行发生原则，i = 1的结果可以被观察到；二是线程C还没有“登场“，线程A操作结束之后没有其他的线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和线程B之间的先行发生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少呢？答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。 通过这个例子我相信读者对Happens-Before已经有了一定的了解。 这里再重复一下Happens-Before的作用： 如果存在hb(a,b)，那么操作a在内存上面所做的操作（如赋值操作等）都对操作b可见，即操作a影响了操作b。 Java 原生存在的Happens-Before这些是Java 内存模型下存在的原生Happens-Before关系，无需借助任何同步器协助就已经存在，可以在编码中直接使用。 程序次序规则（Program Order Rule） 在一个线程内，按照程序代码顺序，书写在前面的操作Happens-Before书写在后面的操作 管程锁定规则（Monitor Lock Rule） An unlock on a monitor happens-before every subsequent lock on that monitor. 一个unlock操作Happens-Before后面对同一个锁的lock操作。 volatile变量规则（volatile Variable Rule） A write to a volatile field happens-before every subsequent read of that volatile. 对一个volatile变量的写入操作Happens-Before后面对这个变量的读操作。 线程启动规则（Thread Start Rule） Thread对象的start()方法Happens-Before此线程的每一个动作。 线程终止规则（Thread Termination Rule） 线程中的所有操作都Happens-Before对此线程的终止检测。 线程中断规则（Thread Interruption Rule） 对线程interrupt()方法的调用Happens-Before被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。 对象终结规则（Finalizer Rule） 一个对象的初始化完成（构造函数执行结束）Happens-Before它的finalize()方法的开始。 传递性（Transitivity） 偏序关系的传递性：如果已知hb(a,b)和hb(b,c)，那么我们可以推导出hb(a,c)，即操作a Happens-Before 操作c。 这些规则都很好理解，在这里就不进行过多的解释了。 Java语言中无需任何同步手段保障就能成立的先行发生规则就只有上面这些了。 还存在其它的Happens-Before吗Java中原生满足Happens-Before关系的规则就只有上述8条，但是我们还可以通过它们推导出其它的满足Happens-Before的操作，如： 将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作 将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作 在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作 释放Semaphore许可的操作Happens-Before获得许可操作 Future表示的任务的所有操作Happens-Before Future#get()操作 向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作 如果两个操作之间不存在上述的Happens-Before规则中的任意一条，并且也不能通过已有的Happens-Before关系推到出来，那么这两个操作之间就没有顺序性的保障，虚拟机可以对这两个操作进行重排序！ 重要的事情说三遍：如果存在hb(a,b)，那么操作a在内存上面所做的操作（如赋值操作等）都对操作b可见，即操作a影响了操作b。 volatile初学者很容易将synchronized和volatile混淆，所以在这里有必要再两者的作用说明一下。 一谈起多线程编程我们往往会想到原子性、可见性，其实还有一个有序性常常被大家忘记。其实也不怪大家，因为只要能够保证原子性和可见性，就基本上能够保证有序性了，所以常常被大家忽略。 原子性 是指某个操作要么执行完要不不执行，不会出现执行到一半的情况。 synchronized和java.util.concurrent包中的锁都能够保证操作的原子性。 可见性 即上一个操作所做的更改是否对下一个操作可见，注意：这里讨论的顺序是指时间上的顺序。 一个被volatile修饰的变量能够保证任意一个操作所做的更改都能够对下一个操作可见 上一条中讨论的原子操作都能对下一次相同的原子操作可见可以参照Happens-Before原则的第二、第三条规则 有序性 Java中的有序性可以概括成一句话： 如果再本线程内观察，所有的操作都是有序的；如果再一个线程中观察另一个线程，所有的操作都是无序的。 前半句是指线程内表现为串行的语义（Within Thread As-If-Serial Semantics），后半句是指指令重排序现象和工作内存与主内存同步延迟现象。 首先volatile关键字本身就包含了禁止指令重排序的语义，而synchronized（及其它的锁）是通过“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块智能串行的进入。 注意：指令重排序在任何时候都有可能发生，与是否为多线程无关，之所以在单线程下感觉没有发生重排序，是因为线程内表现为串行的语义的存在。 volatile如何保证可见性可见性问题的由来大家都知道CPU的处理速度非常快，快到内存都无法跟上CPU的速度而且差距非常大，而这个地方不加以处理通常会成为CPU效率的瓶颈，为了消除速度差带来的影响，CPU通常自带了缓存：一级、二级甚至三级缓存（我们可以在电脑描述信息上面看到）。JVM也是出于同样的道理给每个线程分配了工作内存（Woking Memory，注意：不是主内存）。我们要知道线程对变量的修改都会反映到工作内存中，然后JVM找一个合适的时刻将工作内存上的更改同步到主内存中。正是由于线程更改变量到工作内存同步到主内存中存在一个时间差，所以这里会造成数据一致性问题，这就是可见性问题的由来。 volatile采取的措施volatile采取的措施其实很好理解：只要被volatile修饰的变量被更改就立即同步到主内存，同时其它线程的工作内存中变量的值失效，使用时必须从主内存中读取。 换句话说，线程的工作内存“不缓存”被volatile修饰的变量。 volatile如何禁止重排序这个问题稍稍有点复杂，要结合汇编代码观察有无volatile时的区别。 下面结合《深入理解Java虚拟机》第370页的例子（本想自己生成汇编代码，无奈操作有点复杂）： 图中标红的lock指令是只有在被volatile修饰时才会出现，至于作用，书中是这样解释的：这个操作相当于一个内存屏障（Memory Barrier，重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或者更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。 重复一下：指令重排序在任何时候都有可能发生，与是否为多线程无关，之所以在单线程下感觉没有发生重排序，是因为线程内表现为串行的语义的存在。 分析双重检测锁（DCL）哎，说了这么久终于到了双重检测锁（Double Check Lock，DCL）了，都说累了。大家是不是迫不及待的读下去了呢，嗯，我也迫不及待的写下去了。 这篇文章用happen-before规则重新审视DCL的作者在开头说到： 虽然99%的Java程序员都知道DCL不对，但是如果让他们回答一些问题，DCL为什么不对？有什么修正方法？这个修正方法是正确的吗？如果不正确，为什么不正确？对于此类问题，他们一脸茫然，或者回答也许吧，或者很自信但其实并没有抓住根本。 我觉得很对，记得一年前学习单例模式时，我也不懂为什么要加上volatile关键字，只是依葫芦画瓢跟着大家分析了一番，其实当时是不知道原因的。我相信有很多程序员也是我那时的心态。（偷笑 为了叙述方便，先把DCL的示例代码放在这里，后面分析时需要用到 12345678910111213141516171819202122232425262728/** * Created by liumian on 2016/12/13. */public class DCL &#123; private static volatile DCL instance; private int status; private DCL()&#123; status = 1; //1 &#125; private DCL getInstance()&#123; if (instance == null)&#123; //2 synchronized (DCL.class)&#123; //3 if (instance == null)&#123; //4 instance = new DCL(); //5 &#125; &#125; &#125; return instance; //6 &#125; public int getStatus()&#123; return status; //7 &#125;&#125; 在volatile的视角审视DCL如果获取实例的方法使用synchronized修饰 1private synchronized DCL getInstance() 这样在多线程下肯定是没有问题的而且不需要加volatile修饰变量，但是会丧失部分性能，因为每次调用方法获取实例时JVM都需要执行monitorenter、monitorexit指令来进入和推出同步块，而我们真正需要同步的时刻只有一个：第一次创建实例，其余因为同步而花费的时间纯属浪费。所以缩小同步范围成为了提高性能的手段：只需要在创建实例时进行同步！于是将synchronized放入第一个if判断语句中并在同步代码块中在进行一次判空操作。那么问题来了： 假如没有volatile修饰变量会怎样？ 大家可能会说应该没啥问题啊，就是一行代码嘛：创建一个对象并把引用赋值给变量。没错，在我们看来就是一行代码，它的功能也很简单，但是，但是对于JVM来说可没那么简单了，至少有三个步骤（指令）： 在堆中开辟一块内存（new） 然后调用对象的构造函数对内存进行初始化（invokespecial） 最后将引用赋值给变量（astore） 情形是不是跟上面重排序的例子很相似了呢？没错，假如没有volatile修饰，这些操作有可能发生重排序！JVM有可能这样做： 先在堆中开辟一块内存（new） 马上将引用赋值给变量（astore） 最后才是调用对象的构造方法进行初始化（invokespecial） 好像在单线程下还是没问题，那我们把问题放在多线程情况下考虑（结合上面的DCL示例代码）： 假设有两条线程：T1、T2，当前时刻T1执行到语句1、T2执行到语句4，有可能会发生下面这个执行时序： T2先执行，执行到语句5，但是此时JVM将三条指令进行了重排序：在时间上先执行new、astore、最后才是invokespecial 执行线程T2的CPU刚刚执行完new、astore指令，还没有来得及执行invokespecial指令就被切换出去了 线程T1现在登场了，执行if (instance == null)，因为线程T2已经执行了astore指令：将引用赋值给了变量，所以该判断语句有可能返回为false。如果返回为false，那么成功拿到对象引用。因为该引用所指向的内存地址还没有进行初始化（执行invokespecial指令），所以只要调用对象的任何方法，就会出错（会不会是NullPointerException？） 这就是不加volatile修饰为什么出错的一个过程。这时候有同学就会有疑问，按道理我不加volatile其它线程应该对我刚刚所做的修改（赋值操作）不可见才对呀。如果同学们这么想，我猜刚刚一定是把大家绕糊涂了：线程做的修改不应该对其它线程可见么？应该可见才对，理应可见。而volatile只是保证了可见性，就算没有它，可见性依然存在（不会保证一定可见）。 如果不了解volatile在DCL中的作用，很容易漏写volatile。这是我查资料时在百度百科上面发现的： 后面我给它加上去了： 利用Happens-Before分析DCL经过前面的铺垫终于到了本片博客的第二个主题：利用Happens-Before分析DCL。 先举个例子在这篇文章中（happens-before俗解），作者提及到没有volatile修饰的DCL是不安全的，原因是（为了读者阅读方便，特将原文章的解释结合本文的代码）：语句1和语句7之间不存在Happens-Before的关系，大意是构造方法与普通方法之间不存在Happens-Before关系。为什么该篇文章作者提出这样的观点？我们来分析一下（注意此时没有volatile修饰）： 先抛出一个问题：语句7和哪些语句存在Happens-Before关系？ 我认为在线程T1中语句2与语句7存在Happens-Before关系，为什么？（这里只考虑发生线程安全问题的情况，如果执行到语句4了，就一定不会出现线程安全问题）请参照Happens-Before的第一条规则：程序次序规则（Program Order Rule），在一个线程内，按照程序代码顺序，书写在前面的操作Happens-Before 书写在后面的操作。准确的说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 而语句2与语句7满足第一条规则，因为要执行语句7必须得语句2返回为false才能获取到对象的实例。然后语句2与语句6存在Happens-Before关系，原因同上。根据偏序关系的传递性，语句7与语句6存在Happens-Before关系，此外再也不能推出其它语句与语句7之间是否存在Happens-Before关系了，读者可以尝试推导一下。因为语句7与语句1，换句话说，普通方法与构造方法之间不存在Happens-Before关系，就算构造方法执行了，调用普通方法（如本例的getStatus()）也依然有可能得不到正确的返回值！JVM不保证构造方法所做的更改对普通方法（如本例的getStatus()）可见！ volatile对Happens-Before的影响既然我们已经找到无volatile的DCL出现线程安全问题的原因了，解决起来就很轻松了，最简单的一个办法就是用volatile关键字修饰单例对象。（难道还有不使用volatile的解决办法？嗯，当然有，具体操作请留意后续博客） 现在我们来分析一下拥有volatile修饰的DCL带来了哪些不同？ 最显著的变化就是给变量（instance）带来了Happens-Before关系！请参考Happens-Before的第三条规则：volatile变量规则（Volatile Variable Rule），对一个volatile变量的写操作Happens-Before后面对这个变量的读操作，这里的“后面”指的是时间上的先后顺序。 有了volatile的加持，我们就可以推导出语句2 Happens-Before 语句5，只要执行了instance = new DCL();一定会被语句2instance == null观察到。读者此时可能又有疑问，上面就是因为语句5对语句2“可见”才出现问题的呀？怎么现在因为同样的原因反倒变成线程安全的了？别急，听我慢慢分析。嗯，刚刚的“可见”是打了双引号的，其实并不是整个语句5对语句2可见，而是语句5中的一条指令 – astore对语句2可见，并不包含invokespecial指令！因为volatile具有禁止重排序的语义，所以invokespecial一定在astore前面执行，换句话说构造方法一定在赋值语句之前执行，所以存在hb(语句1,语句5)，又因为hb(语句5,语句2)、hb(语句2,语句7)，所以推出hb(语句1,语句7) ——语句1 Happens-Before 语句7。现在将本例中的getStatus()方法和构造方法链接起来了，同理可以推出构造方法Happens-Before其它普通方法。 总结本文分为两部分。 第一部分介绍了这几个知识点及相关概念： 线程内表现为串行的语义 重排序 Happens-Before 第二部分通过两个角度（volatile、Happens-Before）对双重检测锁（DCL）进行了分析，分析为什么无volatile时会存在线程安全问题： volatile 因为指令重排序，而造成还没有构造完成就将对象发布了 Happens-Before 因为普通方法与构造方法之间不存在Happens-Before关系 双重检测锁（DCL）所出现的安全问题的根本原因是对象没有正确（安全）的发布出去。 而解决这个问题的一种简单的方法就是使用volatile关键字修饰单例对象，从而解决线程安全问题。 读者可能会问，听你这么说，难道还有其它解决办法？我在上面也提到过，确实是还有其它方法，请留意后续博客，我将给大家带来不使用volatile关键字而保证线程安全的另一种方法。 参考资料 《深入理解Java虚拟机》第二版 《Java并发编程实战》 用happen-before规则重新审视DCL happens-before俗解 原创文章，转载请注明： 转载自并发编程网 – ifeve.com本文链接地址: 从单例模式到Happens-Before","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://jinyu.host/tags/JVM/"},{"name":"volatile","slug":"volatile","permalink":"http://jinyu.host/tags/volatile/"},{"name":"Happens-Before","slug":"Happens-Before","permalink":"http://jinyu.host/tags/Happens-Before/"}]},{"title":"什么是wall clock time","slug":"02909323-3a09-4a42-86a5-70abe42ac24c","date":"2020-07-11T21:05:15.000Z","updated":"2020-07-11T21:05:15.000Z","comments":true,"path":"2020/07/12/02909323-3a09-4a42-86a5-70abe42ac24c/","link":"","permalink":"http://jinyu.host/2020/07/12/02909323-3a09-4a42-86a5-70abe42ac24c/","excerpt":"","text":"在一些系统调用中需要指定时间是用CLOCK_MONOTONIC还是CLOCK_REALTIME，以前总是搞不太清楚它们之间的差别，现在终于有所理解了。 CLOCK_MONOTONIC：monotonic time CLOCK_REALTIME：wall time monotonic time字面意思是单调时间，实际上它指的是系统启动以后流逝的时间，这是由变量jiffies来记录的。系统每次启动时jiffies初始化为0，每来一个timer interrupt，jiffies加1，也就是说它代表系统启动后流逝的tick数。jiffies一定是单调递增的，因为时间不够逆嘛！ wall time字面意思是挂钟时间，实际上就是指的是现实的时间，这是由变量xtime来记录的。系统每次启动时将CMOS上的RTC时间读入xtime，这个值是”自1970-01-01起经历的秒数、本秒中经历的纳秒数”，每来一个timer interrupt，也需要去更新xtime。 以前我一直想不明白，既然每个timer interrupt，jiffies和xtime都要更新，那么不都是单调递增的吗？那它们之间使用时有什么区别呢？昨天看到一篇文章，终于明白了，wall time不一定是单调递增的。因为wall time是指现实中的实际时间，如果系统要与网络中某个节点时间同步、或者由系统管理员觉得这个wall time与现实时间不一致，有可能任意的改变这个wall time。最简单的例子是，我们用户可以去任意修改系统时间，这个被修改的时间应该就是wall time，即xtime，它甚至可以被写入RTC而永久保存。一些应用软件可能就是用到了这个wall time，比如以前用vmware workstation，一启动提示试用期已过，但是只要把系统时间调整一下提前一年，再启动就不会有提示了，这很可能就是因为它启动时用gettimeofday去读wall time，然后判断是否过期，只要将wall time改一下，就可以欺骗过去了。 原文链接 https://blog.csdn.net/dyzhen/article/details/52813099","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"在VMware安装CentOS7虚拟机并安装redis","slug":"bac7fc33-d277-4f8f-a465-684decf4ad8d","date":"2020-07-11T03:49:12.000Z","updated":"2020-07-11T03:51:26.000Z","comments":true,"path":"2020/07/11/bac7fc33-d277-4f8f-a465-684decf4ad8d/","link":"","permalink":"http://jinyu.host/2020/07/11/bac7fc33-d277-4f8f-a465-684decf4ad8d/","excerpt":"","text":"0.简介最近了解了下Redis分布式锁中的RedLock，所以想要建上3~5个节点做一下测试，安装的CentOS7都最简洁的、很随意的安装，但是对于初学者来说，想要有一个学习Linux的优良环境还是推荐安装CentOS7的Everything版本，最小安装虽然能自己去主动的去安装软件，但会遇到很多麻烦的问题。 1.安装CentOS7虚拟机首先下载镜像http://mirrors.aliyun.com/centos/7/isos/x86_64&#x2F; 我选择的是最小安装(Minimal) 下载完毕后，打开VMware进行安装 基本只需要调节自己需要的虚拟机参数，到网络类型时，选择NAT，此处有一个坑，之后会讲到。 然后就会进入CentOS7的安装界面，选择第一个：Install CentOS 7 进入安装UI界面后，选择语言，安装位置选择自动分区，然后点击开始安装，此时在CentOS的安装之余可以设置一下root的密码，可以不用创建用户直接使用root用户。安装完毕后选择重启，之后会进入CentOS的登录页面，输入用户名root和密码即可。 2.配置网络首先，点击VMware的 编辑 -&gt; 虚拟网络编辑器 NAT模式的子网地址为192.168.0.0，说明本机是192.168.0.1，网关是192.168.0.2，则虚拟机的ip可以是3~254。 注意：这里的子网地址是可以更改的，点击有管理员权限图标的更改设置 若直接使用后续指令dhclient分配的IP地址，和虚拟网络编辑器未修改的子网地址不再同一网段的话，之后是无法连接外网的。 记录好虚拟网络编辑器的NAT模式的子网地址后，输入dhclient分配ip地址，然后使用ip addr可以查看到ipv4的地址 记录下来这个地址，开始配置网络 1vi /etc/sysconfig/network-scripts/ifcfg-ens33 然后输入红框中的ip，子网掩码，网关，dns 保存退出后重启网络 1service network restart ping一下本机，外网试试 成功！ 3.更换国内的镜像源网易：http://mirrors.163.com/.help/CentOS7-Base-163.repo 阿里云：http://mirrors.aliyun.com/repo/Centos-7.repo 下载yum源配置文件需要使用wget命令，最小安装默认没有，所以先下载wget的rpm包 yum安装： 1yum install -y wget rpm安装 http://mirrors.163.com/centos/6.2/os/x86_64&#x2F;Packages&#x2F;wget-1.12-1.4.el6.x86_64.rpm 下载后传到CentOS并安装 1rpm -ivh wget-1.12-1.4.el6.x86_64.rpm 装好wget后进入配置yum源文件的文件夹 1cd /etc/yum.repos.d/ 备份初始的yum源配置文件 1mv CentOS-Base.repo CentOS-Base.repo.backup 下载国内的yum源配置文件 1wget http://mirrors.aliyun.com/repo/Centos-7.repo 下载完毕后修改文件名字覆盖掉初始的yum源配置文件 1mv -f Centos-7.repo CentOS-Base.repo 生成缓存 1yum makecache 4.安装redis下载redis的tar包，在官网即可 我是在本机win10下载的，下载完毕后复制到CentOS上并解压，我放在了 &#x2F;usr&#x2F;local&#x2F;@app&#x2F; 1tar -zxf redis-6.0.5.tar.gz 解压完毕后，进入redis并安装 123cd redis-6.0.5/make 此时可能会有错误，需要升级gcc 123456789yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash #注意：scl命令启用只是临时的，退出xshell或者重启就会恢复到原来的gcc版本，#如果要长期生效的话，执行如下：echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile 可能还有错误：zmalloc.h:50:31: 致命错误：jemalloc&#x2F;jemalloc.h：没有那个文件或目录 make后面加上MALLOC&#x3D;libc即可 1make MALLOC=libc 安装完毕后需要修改一下配置文件：如果只用于本地访问无需修改，如果需要外网访问需要将bind 127.0.0.1注释掉或改成 bind 0.0.0.0（允许所有ip访问)，若指定ip访问修改成 bind 指定ip 还可以设置redis的密码 保存退出后需要在VMware上配置端口映射 点击有管理员权限图标的更改设置 点击NAT模式和NAT设置 点击添加 添加完毕端口映射后进入CentOS关闭防火墙或开放6379端口 1systemctl disable firewalld 然后进入redis目录的src并开启redis服务 12cd src/./redis-server 使用客户端连接时需要密码 1./redis-cli -a [password] 或者直接连接 1./redis-cli 进入redis后执行指令会出现此提示 1(error) NOAUTH Authentication required. 输入密码即可 1auth [password] 关闭redis 1./redis-cli -p 6379 -a [password] shutdown","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"CentOS7","slug":"CentOS7","permalink":"http://jinyu.host/tags/CentOS7/"},{"name":"VMware","slug":"VMware","permalink":"http://jinyu.host/tags/VMware/"},{"name":"Redis","slug":"Redis","permalink":"http://jinyu.host/tags/Redis/"}]},{"title":"TCP/IP三次握手，四次分手","slug":"005d9673-b680-45f0-95cf-b6fd952825f0","date":"2020-07-08T03:59:06.000Z","updated":"2020-07-09T04:02:48.000Z","comments":true,"path":"2020/07/08/005d9673-b680-45f0-95cf-b6fd952825f0/","link":"","permalink":"http://jinyu.host/2020/07/08/005d9673-b680-45f0-95cf-b6fd952825f0/","excerpt":"","text":"1.引出问题与www.baidu.com建立连接 1exec 9&lt;&gt; /dev/tcp/www.baidu.com/80 任何程序都有IO(fd为文件描述符，可以理解为Java中的new出来的File变量) 图中fd为9u的连接是由内核建立的socket连接 将符合HTTP协议的字符串，通过标准输出重定向到9，字符串就会通过9这个socket发送到百度的服务器(给百度发送了HTTP协议的请求头“文本”) 1echo -e &quot;GET /HTTP/1.0\\n&quot; 1&gt;&amp; 9 读取9，得到百度的主页 1cat 0&lt;&amp; 9 由上例可以得出，连接无需人来操作；而连接上以后，B&#x2F;S之间的通信，发送的数据就需要协议了(HTTP协议) 2.什么是连接，如何建立？应用层想要发送HTTP，这时需要一个连接，应用层阻塞并调用了传输控制层。 2.1.传输控制层协议：UDP，TCP Q：什么是TCP协议？ 面向连接 可靠的传输协议 Q：什么是TCP的三次握手、四次分手？ 三次握手： S处于监听状态，此时C发送一个数据包syn(由传输控制层发送)到S； S收到C发送的数据包syn后，返回一个数据包syn+ack； C收到S发送的数据包syn+ack，返回一个数据包ack。 均由两端内核的传输控制层来通信； 三次握手可以确认双方的通信是畅通的，三次握手后，双方为对方在内存中开辟资源(物理)，资源为对方提供响应服务，此时便是创建了一个连接； 三次握手的确认机制使得TCP是一个可靠的传输协议。 三次握手之后才允许传输数据，传输控制层进入阻塞状态，调用网络层 socket：四元组：C:ip:port + S:ip:port，称为一个套接字，对这个四元组使用了一个文件描述符来代表，比如9，可以对9进行读写操作， 四次分手(为了释放资源)： C向S发送数据包fin，发出释放连接请求； S向C发送数据包fin+ack，返回确认请求； S向C发送数据包fin，发出释放连接请求； C向S发送数据包ack，返回确认请求； 2.2.网络层IP route表：路由表是为了寻找下一跳 例： 首先会将需要连接的ip地址和路由表中每一条数据的子网掩码进行与操作，得到的结果再和路由表中每一条数据的destination进行对比： 若需要连接的ip为局域网内的ip，则ip和路由表的第一条数据的子网掩码进行与操作，其结果在上图的路由表中的destination中找到了，所以不需要走网关，即网关为0.0.0.0，直连； 若需要连接的ip若外网的ip，比如上图的ping www.baidu.com操作，则ip和路由表的第一条数据的子网掩码进行与操作，其结果为61.135.169.0，在路由表中的destination中找不到，所以继续和路由表的第二条数据的子网掩码进行与操作，得到结果0.0.0.0，可以再destination中找到，所以需要走网关192.168.150.2(一般为连接外网的路由器)，此时发现一个问题，需要发送的数据包中应当包含下一跳的地址(即网关192.168.150.2)，和目标地址61.135.169.125，由此引入了**数据链路层** 2.3.数据链路层一个数据包应当包含：网关地址(MAC)，目标ip，目标port 链路层的ARP协议会请求MAC地址，FF:FF:FF:FF:FF:FF广播发送数据包，只有正确的MAC地址会响应","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://jinyu.host/tags/TCP-IP/"}]},{"title":"IllegalArgumentException: The main resource set specified ... is not valid","slug":"e68a8fb3-1201-4891-906f-3c950ad6ab75","date":"2020-07-03T20:04:17.000Z","updated":"2020-07-03T22:18:01.000Z","comments":true,"path":"2020/07/04/e68a8fb3-1201-4891-906f-3c950ad6ab75/","link":"","permalink":"http://jinyu.host/2020/07/04/e68a8fb3-1201-4891-906f-3c950ad6ab75/","excerpt":"","text":"删除tomcat的webapps下的项目，再启动tomcat时出现错误 原文链接 https://blog.csdn.net/chengyuqiang/article/details/80311882","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://jinyu.host/tags/Tomcat/"}]},{"title":"Maven__ERROR__target/surefire-reports for the individual test results.","slug":"5d1cac50-270a-4ca0-a184-c7a4125d7310","date":"2020-07-03T19:56:49.000Z","updated":"2020-07-03T19:56:49.000Z","comments":true,"path":"2020/07/04/5d1cac50-270a-4ca0-a184-c7a4125d7310/","link":"","permalink":"http://jinyu.host/2020/07/04/5d1cac50-270a-4ca0-a184-c7a4125d7310/","excerpt":"","text":"解决办法一: 在POM.xml文件里增加跳过测试配置 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 解决办法二: 使用命令编译工程时, 指定跳过测试代码的语句 1mvn clean package -Dmaven.test.skip -DskipTests=true 原文链接 https://www.jianshu.com/p/f8494e18c695","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://jinyu.host/tags/Maven/"}]},{"title":"Linux启动tomcat并查看启动日志","slug":"d02737f5-f830-403a-be92-05fe257f4a7e","date":"2020-07-03T19:14:13.000Z","updated":"2020-07-03T22:04:21.000Z","comments":true,"path":"2020/07/04/d02737f5-f830-403a-be92-05fe257f4a7e/","link":"","permalink":"http://jinyu.host/2020/07/04/d02737f5-f830-403a-be92-05fe257f4a7e/","excerpt":"","text":"1.在tomcat的bin目录下输入123./startup.sh; tailf ../logs/catalina.out或./startup.sh &amp;&amp; tail -f ../logs/catalina.out 2.进入 tomcat的日志目录12cd/tomcat/logstail -f catalina.out tail 命令可用于查看文件的内容，常用参数 -f 用于查阅正在改变的日志文件。 tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，(Ctrl-C)组合键停止显示，只要 filename 更新就可以看到最新的文件内容。 原文链接 https://blog.csdn.net/qq_42324086&#x2F;article&#x2F;details&#x2F;99860343","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://jinyu.host/tags/Tomcat/"}]},{"title":"离开和回到页面时改变网页的标题","slug":"f2ac9bfe-5536-44dd-a23d-ff27d06ab2ec","date":"2020-07-03T03:26:53.000Z","updated":"2020-07-03T19:22:09.000Z","comments":true,"path":"2020/07/03/f2ac9bfe-5536-44dd-a23d-ff27d06ab2ec/","link":"","permalink":"http://jinyu.host/2020/07/03/f2ac9bfe-5536-44dd-a23d-ff27d06ab2ec/","excerpt":"","text":"12345678910document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.visibilityState === &#x27;hidden&#x27;) &#123; initialTitle = document.title; document.title = &#x27;|･ω･｀)藏...&#x27;; &#125; else &#123; document.title = &#x27;(｡･ω･｡)ﾉ被发现啦！&#x27;; //延时1.5秒改回原标题 setTimeout(function () &#123;document.title = initialTitle;&#125;,1500); &#125;&#125;); 参考链接 https://www.cnblogs.com/ChouXiaoShou/p/page_leave.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jinyu.host/tags/JavaScript/"}]},{"title":"Swagger2异常：Illegal DefaultValue null for parameter type integer","slug":"e56d1295-8aea-4e71-b68a-2dfa9bf624cd","date":"2020-07-02T22:01:57.000Z","updated":"2020-07-03T19:18:36.000Z","comments":true,"path":"2020/07/03/e56d1295-8aea-4e71-b68a-2dfa9bf624cd/","link":"","permalink":"http://jinyu.host/2020/07/03/e56d1295-8aea-4e71-b68a-2dfa9bf624cd/","excerpt":"","text":"1.异常分析12Illegal DefaultValue null for parameter type integerNumberFormatException: For input string: &quot;&quot; 从上面这两句可以看出，有个默认值是空字符串的变量转换成Integer类型时异常。 1at io.swagger.models.parameters.AbstractSerializableParameter.getExample(AbstractSerializableParameter.java:412) ~[swagger-models-1.5.20.jar:1.5.20] 根据上面这句报错信息，点进去AbstractSerializableParameter.java:412可以看到 123if(BaseIntegerProperty.TYPE.equals(type))&#123; return Long.valueOf(example);&#125; 就是说如果实体属性类型是Integer，就把example转为Long类型，而example默认为””，导致转换错误。 2.解决方法实体类中，Integer类型的属性加@ApiModelProperty时，必须要给example参数赋值，且值必须为数字类型。 12@ApiModelProperty(value = &quot;主键&quot;, example = &quot;0&quot;)private Integer id; 原文链接 https://www.cnblogs.com/ampl/p/11426687.html","categories":[{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"Swagger","slug":"Swagger","permalink":"http://jinyu.host/tags/Swagger/"}]},{"title":"Linux解压文件时的参数 -zxvf","slug":"8319ac22-acdd-4a7c-a558-0148ad29fd87","date":"2020-07-02T01:14:05.000Z","updated":"2020-07-03T19:18:52.000Z","comments":true,"path":"2020/07/02/8319ac22-acdd-4a7c-a558-0148ad29fd87/","link":"","permalink":"http://jinyu.host/2020/07/02/8319ac22-acdd-4a7c-a558-0148ad29fd87/","excerpt":"","text":"z：表示tar包是被gzip压缩过的，所以解压时需要用gunzip解压 x：从tar包中把文件提取出来 v：显示详细信息 f xxx.tar.gz : 指定被处理的文件是xxx.tar.gz 原文链接 https://zhidao.baidu.com/question/397860961.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"}]},{"title":"Docker快速安装RabbitMQ","slug":"75897e3e-77e6-4d75-afad-6535635dd75e","date":"2020-06-30T02:26:54.000Z","updated":"2020-07-03T19:20:46.000Z","comments":true,"path":"2020/06/30/75897e3e-77e6-4d75-afad-6535635dd75e/","link":"","permalink":"http://jinyu.host/2020/06/30/75897e3e-77e6-4d75-afad-6535635dd75e/","excerpt":"","text":"1.获取镜像12#指定版本，该版本包含了web控制页面docker pull rabbitmq:management 2.运行镜像12345#方式一：默认，用户名和密码都是guestdocker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management#方式二：主动设置用户名和密码docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=[用户名] -e RABBITMQ_DEFAULT_PASS=[密码] -p 15672:15672 -p 5672:5672 rabbitmq:management 3.访问UI页面1http://localhost:15672/ 原文链接 https://www.cnblogs.com/angelyan/p/11218260.html","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://jinyu.host/tags/RabbitMQ/"}]},{"title":"使用小丸工具箱压缩视频","slug":"c68afef5-0956-4a6c-a462-17c067ea006f","date":"2020-06-16T01:29:20.000Z","updated":"2020-06-21T18:46:03.000Z","comments":true,"path":"2020/06/16/c68afef5-0956-4a6c-a462-17c067ea006f/","link":"","permalink":"http://jinyu.host/2020/06/16/c68afef5-0956-4a6c-a462-17c067ea006f/","excerpt":"","text":"1.主要方法是计算2Pass中的码率 2.计算方法： 此视频的时长为 30 s， 比特率为 317 kbps ∴ 码率 &#x3D; 需要压缩到的大小(Mb) × 8 ÷ 30(时长) × 1024 - 317(比特率) 例：压缩到10M以内，则公式为：10 × 8 ÷ 30 ×1024 - 317 ≈ 2414 3.压缩后的视频情况：","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"多媒体处理","slug":"多媒体处理","permalink":"http://jinyu.host/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86/"}]},{"title":"HttpServletRequest获取有关项目的一些参数","slug":"ce6f1a27-c6e2-4d6a-8085-1eca2747cb2f","date":"2020-06-13T03:39:19.000Z","updated":"2020-06-21T18:46:20.000Z","comments":true,"path":"2020/06/13/ce6f1a27-c6e2-4d6a-8085-1eca2747cb2f/","link":"","permalink":"http://jinyu.host/2020/06/13/ce6f1a27-c6e2-4d6a-8085-1eca2747cb2f/","excerpt":"","text":"协议：http 1request.getScheme(); ip地址：127.0.0.1 1request.getServerName(); 端口：8080 1request.getServerPort(); 项目名 1request.getContextPath(); url 1String url = scheme + &quot;://&quot; + serverName + &quot;:&quot; + serverPort + contextPath;","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"}]},{"title":"头像裁剪上传","slug":"7ac01cac-f24b-4edb-a6fe-ce11b45280b9","date":"2020-06-11T03:03:01.000Z","updated":"2020-06-21T18:45:47.000Z","comments":true,"path":"2020/06/11/7ac01cac-f24b-4edb-a6fe-ce11b45280b9/","link":"","permalink":"http://jinyu.host/2020/06/11/7ac01cac-f24b-4edb-a6fe-ce11b45280b9/","excerpt":"","text":"1.引入插件及页面中的写法图片裁剪插件 canvas转换为image插件 1.1.引入样式1&lt;link rel=&quot;stylesheet&quot; href=&quot;../../static/lib/simple-crop-master/template-1.css&quot;&gt; 1.2.引入相关依赖和组件源代码1234567&lt;!--引入图片裁剪插件--&gt;&lt;script src=&quot;../../static/lib/simple-crop-master/prefix-umd.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../../static/lib/simple-crop-master/exif.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../../static/lib/simple-crop-master/transformation-matrix.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../../static/lib/simple-crop-master/index.js&quot;&gt;&lt;/script&gt;&lt;!--引入canvas转换为image插件--&gt;&lt;script src=&quot;../../static/js/Canvas2Image.js&quot;&gt;&lt;/script&gt; 1.3.初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546var simpleCrop = new SimpleCrop(&#123; title: &#x27;选择头像&#x27;, //标题 // src: &#x27;src/mian/resource/static/images/514.png&#x27;, //裁剪图片地址 size: &#123; //裁剪尺寸 width: 600, height: 600 &#125;, visible: false, //打开页面时不显示裁剪弹窗 cropSizePercent: 0.65, //裁剪框显示比例 scaleSlider: true, //是否显示滑动控制条 maxScale: 3, //最大缩放倍数 borderWidth: 1, //裁剪框边框宽度 funcBtns: [&#x27;close&#x27;, &#x27;crop&#x27;, &#x27;upload&#x27;], //功能按钮配置 borderColor: &quot;#fff&quot;, //裁剪框边框颜色 coverColor: &#x27;rgba(0,0,0,.5)&#x27;, //裁剪框遮罩颜色 startAngle: -360, //旋转刻度盘开始角度 endAngle: 360, //旋转刻度盘结束角度 cropCallback: function ($resultCanvas) &#123; //图片裁剪完成回调函数 /* * 原作者将裁剪后的图片追加到body上； * 而我需要其base64值转换为图片存储到硬盘上， * 再将地址复制给user.avatar，所以注释掉 * * console.log(&#x27;cropCallback&#x27;); * $resultCanvas.style.marginRight = &#x27;10px&#x27;; * $resultCanvas.style.width = &#x27;50%&#x27;; * document.body.appendChild($resultCanvas); */ /* * 测试Canvas2Image插件 * document.body.appendChild(Canvas2Image.convertToJPEG($resultCanvas, 600, 600)); */ /* * 在表单中设置了一个隐藏域&lt;input id=&quot;avatar&quot; type=&quot;hidden&quot; name=&quot;avatar&quot;&gt;， * 为其赋值裁剪后的图片的base64值 */ $(&#x27;#avatar&#x27;).val(Canvas2Image.convertToJPEG($resultCanvas, 600, 600).src); &#125;, uploadCallback: function (src) &#123; //上传裁剪图片成功回调函数 // 注意：此处的src是原图片的base64值 // console.log(&#x27;uploadCallback &#x27; + src); &#125;, closeCallback: function () &#123; //关闭组件回调函数 // console.log(&#x27;closeCallback&#x27;); &#125;&#125;); 1.4.选取裁剪图片1&lt;input id=&quot;upload&quot; type=&quot;file&quot; accept=&quot;image/png,image/jpeg&quot;&gt; 12345678var $upload = document.querySelector(&#x27;#upload&#x27;);$upload.addEventListener(&#x27;change&#x27;, function (evt) &#123; var files = evt.target.files; if (files.length &gt; 0) &#123; simpleCrop.show(files[0]); //显示 &#125; $upload.value = &#x27;&#x27;; //清空 input value属性&#125;); 1.5.更新组件参数123456&lt;!--原readme的写法--&gt;&lt;button id=&quot;update&quot;&gt;组件更新&lt;/button&gt;&lt;!--我加了一些自己的样式，参考即可--&gt;&lt;button type=&quot;reset&quot; id=&quot;update&quot; class=&quot;ui violet button j-padded-z-6 j-text-thin-500&quot;&gt; 重新裁剪&lt;/button&gt; 1234567891011121314var $update = document.querySelector(&#x27;#update&#x27;);$update.addEventListener(&#x27;click&#x27;, function () &#123; simpleCrop.updateBox(&#123; //更新裁剪框尺寸和显示比例 cropSizePercent: 0.7, size: &#123; width: 600, height: 600, &#125; &#125;); simpleCrop.initBoxBorder(&#123; //更新裁剪框边框样式 borderColor: &quot;#0BFF00&quot;, &#125;); simpleCrop.show(); //显示&#125;); 2.Controller的写法表单提交到这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@PostMapping(&quot;/setting&quot;)public String setting(User user, HttpServletRequest request)&#123; //在初始化中，已经给隐藏域中的id为avatar的input赋过值了(line:37) String base64Avatar = user.getAvatar(); //base64头像非空时，存储头像并将路径赋值给user.avatar if (base64Avatar != null &amp;&amp; !&quot;&quot;.equals(base64Avatar)) &#123; //剪切后的头像的文件名 String avatarOriginalFilename = System.currentTimeMillis() + &quot;.jpg&quot;; /* * 注意：使用springboot时，内置的tomcat的request.getServletContext().getRealPath(&quot;/&quot;) * 得到的不是当前项目的路径，可以使用new File(BLOG_STATIC_IMAGES_PATH).getAbsoluteFile()来得到 * * BLOG_STATIC_IMAGES_PATH = * linux : &quot;WEB-INF/classes/static/images/&quot; * 本地win10的IDEA开发 : &quot;src/main/resources/static/images&quot; */ //剪切后头像的绝对路径 String avatarAbsolutePath = request.getServletContext().getRealPath(&quot;/&quot;) + BLOG_STATIC_IMAGES_PATH + avatarOriginalFilename; try &#123; /* * 在此处 http://sharehoo.cn/topic/detail/414 找到 * 解决IllegalArgumentException: Illegal base64 character 3a异常的方法： * * 前端将文件转换后，结构为这样： * data:image/png;base64,iVBORw0AAAAA... * 需要将没用的字符串剪切掉：data:image/png;base64，从&quot;,&quot;号开始切割，只留数据部分即可。 */ // Base64解码 if (base64Avatar.contains(&quot;,&quot;)) &#123; String encodedImg = base64Avatar.split(&quot;,&quot;)[1]; byte[] decodedImg = Base64.getDecoder().decode(encodedImg.getBytes(StandardCharsets.UTF_8)); /* * 在此处 https://blog.csdn.net/qq_36964933/article/details/98474021 找到 * 解决将byte[]转换为MultipartFile对象的方法 */ //将base64编码转换为的字节数组decodedImg，再转换为MultipartFile对象 MultipartFile avatarFile = new MockMultipartFile(MediaType.APPLICATION_OCTET_STREAM_VALUE, new ByteArrayInputStream(decodedImg)); //写文件 avatarFile.transferTo(new File(avatarAbsolutePath)); //给当前用户设置剪切后的头像 user.setAvatar(&quot;/images/&quot; + avatarOriginalFilename); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;文件上传失败&quot;); &#125; &#125; //重定向到返回页面的get方法 return &quot;redirect:/admin/setting/&quot; + userService.saveUser(user).getId();&#125; 返回页面的get方法： 1234567@GetMapping(&quot;/setting/&#123;userId&#125;&quot;)public String setting(@PathVariable Long userId, Model model, HttpSession session) &#123; User user = userService.getUser(userId); model.addAttribute(&quot;user&quot;, user); session.setAttribute(&quot;user&quot;, user); return &quot;admin/setting&quot;;&#125;","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jinyu.host/tags/JavaScript/"},{"name":"GitHub","slug":"GitHub","permalink":"http://jinyu.host/tags/GitHub/"}]},{"title":"JavaSE","slug":"7d33be76-c292-4a37-9e5b-564f869db5f8","date":"2020-06-08T00:41:16.000Z","updated":"2020-06-21T18:45:03.000Z","comments":true,"path":"2020/06/08/7d33be76-c292-4a37-9e5b-564f869db5f8/","link":"","permalink":"http://jinyu.host/2020/06/08/7d33be76-c292-4a37-9e5b-564f869db5f8/","excerpt":"","text":"对象类型转换： 高级的基本数据类型 ——&gt; 低级数据类型 强制类型转化：int i &#x3D; (int) long; 低级的基本数据类型 ——&gt; 高级数据类型 自动类型转化：long l &#x3D; int; 父类 ——&gt; 子类 向下转型，强制，用instanceof判断：Student s &#x3D; (Student) Person; 子类 ——&gt; 父类 向上转型，自动：Person p &#x3D; Student; &#x3D;&#x3D; &amp; equals： equals可重写 对象： 特殊的类，如String、File、Date &#x3D;&#x3D; 比较的是对象(对象的地址) equals比较的是内容 其他的普通类的对象 &#x3D;&#x3D; 和 equals均比较的是对象(对象的地址) String对象的创建 字面量创建对象时，只在常量池中创建一个对象；new的时候，常量池创建对象，堆中也创建对象。 所以字面量比new更省内存 字面量创建String对象 12345678//常量池中添加&quot;abc&quot;对象，返回引用地址给s1对象String s1 = &quot;abc&quot;;//通过equals()方法判断常量池中已有值为abc的对象，返回相同的引用String s2 = &quot;abc&quot;; //trueSystem.out.println(s1 == s2); new创建String对象 12345//在常量池中添加&quot;def&quot;对象，在堆中创建值为&quot;def&quot;的对象s3，返回指向堆中s3的引用String s3 = new String(&quot;def&quot;);//常量池中已有值为&quot;def&quot;的对象，不做处理，在堆中创建值为&quot;def&quot;的对象，返回指向堆中s4的引用String s4 = new String(&quot;def&quot;); 12//经过JVM优化，直接在常量池中添加&quot;xy&quot;对象String s5 = &quot;x&quot; + &quot;y&quot;; 12//通过StringBuilder实现，在常量池中添加&quot;1&quot;和&quot;2&quot;对象，在堆中创建值为&quot;112&quot;的对象，把引用地址给s6String s6 = new String(&quot;1&quot;) + new String(&quot;1&quot;) + new String(&quot;3&quot;); 单例(Singleton)设计模式 饿汉式 123456789101112131415public class EagerSingleton &#123; /** * 私有构造：调用这个类时无法使用new来创建实例 */ private EagerSingleton()&#123;&#125; /** * 私有的Singleton类型的类变量 */ private static EagerSingleton eagerSingleton = new EagerSingleton(); public static EagerSingleton getInstance()&#123; return eagerSingleton; &#125;&#125; 懒汉式 123456789101112131415161718public class LazySingleton &#123; /** * 私有构造 */ private LazySingleton()&#123;&#125; /** * 私有的Singleton类型的类变量 */ private static LazySingleton lazySingleton = null; public static LazySingleton getInstance()&#123; if (lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; new对象时的构造顺序 类的属性默认初始化和显示初始化 静态代码块(只执行一次；多个按顺序执行) 执行代码块(多个按顺序执行) 执行构造器 模板设计模式 抽象类&#x2F;模板 1234567891011121314151617public abstract class AbstractTimeTemplate &#123; /** * 子类具体的代码 */ public abstract void code(); /** * 获得代码的执行时间 */ public final void getTime()&#123; long start = System.currentTimeMillis(); code(); long end = System.currentTimeMillis(); System.out.println(&quot;code()执行时间：&quot; + (end - start)); &#125;&#125; 子类 123456public class CodeTest extends AbstractTimeTemplate&#123; @Override public void code() &#123; Stream.iterate(0, t -&gt; t + 1).limit(1024).forEach(System.out::println); &#125;&#125; 工厂方法(FactoryMethod)可以使用内部类来变相实现类的多重继承Java集合集合类存放于java.util包中 只能存放对象，如int类型的1放入集合，自动转换为Integer 类型set HashSet &lt;- Set &lt;- Collection 无序、不可重复、非线程安全、可null 存入一个元素时，会调用该对象的hashCode()方法得到hashCode值，根据hashCode值决定存放位置 TreeSet &lt;- NavigableSet &lt;- SortedSet &lt;- Set &lt;- Collection 有序 自然排序（调用接元素的compareTo(Objecet obj)方法，比较后asc） this &gt; obj 1 this &lt; obj -1 this &#x3D; obj 0 必须放入同样的类的对象（泛型约束） 定制排序 list ArrayList &lt;- List &lt;- Collection sublist(, ) [ ) 非线程安全（Vector线程安全，但为了保证List线程安全也不推荐使用Vector） map HashMap 非线程安全 允许null作为key&#x2F;value Hashtable（古老，不建议使用） 线程安全 不允许null作为key&#x2F;value TreeMap 保持有序 自然排序：所有的key继续实现Comparable接口且为同一类的对象，否则抛出ClassCastException 定制排序：创建一个TreeMap时，传入一个Comparator对象，key无需实现Comparable接口 java中的泛型，只会在编译阶段有效，不会进入到运行时阶段每个枚举对象都是单例模式Java的IO 文件流：基于文件的操作 缓冲流：基于内存的操作 文件编码格式TXT&#x2F;Java编码 ISO8859-1，西欧编码，不适于汉字 GBK和UTF-8，中英皆可 反射前提：已经加载过这个类，即可通过类名来寻找这个类的相关信息 java.lang.Classjava.lang.reflect.Methodjava.lang.reflect.Fieldjava.lang.reflect.Constructor多线程创建线程的两种方式 继承Thread类 定义子类继承Thread类 重写 run() 方法 创建了Tread子类对象，即创建了线程对象 调用线程对象 start()方法：启动线程，调用run()方法 （常用）实现Runnable接口 实现接口方式的好处 避免了单继承的局限性 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程处理同一份资源","categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"}]}],"categories":[{"name":"学习日志","slug":"学习日志","permalink":"http://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"错误日志","slug":"错误日志","permalink":"http://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"},{"name":"Docker部署App","slug":"Docker部署App","permalink":"http://jinyu.host/categories/Docker%E9%83%A8%E7%BD%B2App/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jinyu.host/tags/Java/"},{"name":"锁","slug":"锁","permalink":"http://jinyu.host/tags/%E9%94%81/"},{"name":"并发","slug":"并发","permalink":"http://jinyu.host/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"多线程","permalink":"http://jinyu.host/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Minio","slug":"Minio","permalink":"http://jinyu.host/tags/Minio/"},{"name":"Windows","slug":"Windows","permalink":"http://jinyu.host/tags/Windows/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://jinyu.host/tags/Tomcat/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://jinyu.host/tags/Jenkins/"},{"name":"Linux","slug":"Linux","permalink":"http://jinyu.host/tags/Linux/"},{"name":"Maven","slug":"Maven","permalink":"http://jinyu.host/tags/Maven/"},{"name":"vim","slug":"vim","permalink":"http://jinyu.host/tags/vim/"},{"name":"Docker","slug":"Docker","permalink":"http://jinyu.host/tags/Docker/"},{"name":"Nacos","slug":"Nacos","permalink":"http://jinyu.host/tags/Nacos/"},{"name":"Markdown","slug":"Markdown","permalink":"http://jinyu.host/tags/Markdown/"},{"name":"zsh","slug":"zsh","permalink":"http://jinyu.host/tags/zsh/"},{"name":"MySQL","slug":"MySQL","permalink":"http://jinyu.host/tags/MySQL/"},{"name":"Navicat","slug":"Navicat","permalink":"http://jinyu.host/tags/Navicat/"},{"name":"Redis","slug":"Redis","permalink":"http://jinyu.host/tags/Redis/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://jinyu.host/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jinyu.host/tags/SpringBoot/"},{"name":"yml","slug":"yml","permalink":"http://jinyu.host/tags/yml/"},{"name":"CentOS7","slug":"CentOS7","permalink":"http://jinyu.host/tags/CentOS7/"},{"name":"gnome","slug":"gnome","permalink":"http://jinyu.host/tags/gnome/"},{"name":"VMware","slug":"VMware","permalink":"http://jinyu.host/tags/VMware/"},{"name":"Proxy","slug":"Proxy","permalink":"http://jinyu.host/tags/Proxy/"},{"name":"V2Ray","slug":"V2Ray","permalink":"http://jinyu.host/tags/V2Ray/"},{"name":"SSH","slug":"SSH","permalink":"http://jinyu.host/tags/SSH/"},{"name":"npm","slug":"npm","permalink":"http://jinyu.host/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://jinyu.host/tags/Node-js/"},{"name":"Vue","slug":"Vue","permalink":"http://jinyu.host/tags/Vue/"},{"name":"git","slug":"git","permalink":"http://jinyu.host/tags/git/"},{"name":".bat","slug":"bat","permalink":"http://jinyu.host/tags/bat/"},{"name":"cmd","slug":"cmd","permalink":"http://jinyu.host/tags/cmd/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://jinyu.host/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"JVM","slug":"JVM","permalink":"http://jinyu.host/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"http://jinyu.host/tags/GC/"},{"name":"Thread","slug":"Thread","permalink":"http://jinyu.host/tags/Thread/"},{"name":"volatile","slug":"volatile","permalink":"http://jinyu.host/tags/volatile/"},{"name":"Happens-Before","slug":"Happens-Before","permalink":"http://jinyu.host/tags/Happens-Before/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://jinyu.host/tags/TCP-IP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jinyu.host/tags/JavaScript/"},{"name":"Swagger","slug":"Swagger","permalink":"http://jinyu.host/tags/Swagger/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://jinyu.host/tags/RabbitMQ/"},{"name":"多媒体处理","slug":"多媒体处理","permalink":"http://jinyu.host/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86/"},{"name":"GitHub","slug":"GitHub","permalink":"http://jinyu.host/tags/GitHub/"}]}