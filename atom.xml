<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轨 道 兔</title>
  
  <subtitle>为我自己，为友与仇，人与兽，爱者与不爱者，&lt;br&gt;我希望这野草的朽腐，火速到来。</subtitle>
  <link href="https://jinyu.host/atom.xml" rel="self"/>
  
  <link href="https://jinyu.host/"/>
  <updated>2022-08-16T04:30:17.000Z</updated>
  <id>https://jinyu.host/</id>
  
  <author>
    <name>今愚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CRON表达式</title>
    <link href="https://jinyu.host/2022/08/16/CRON%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://jinyu.host/2022/08/16/CRON%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-08-16T04:30:17.000Z</published>
    <updated>2022-08-16T04:30:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CRON表达式是一个具有时间意义的字符串，具有6个域来分别表示：秒、分、时、天、月、周。<br>每个域可以取确定值和具有逻辑意义的特殊字符，确定值可以使用’,’分割。</p><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><div class="table-container"><table><thead><tr><th style="text-align:left">域</th><th style="text-align:left">取值范围</th><th style="text-align:left">特殊字符</th></tr></thead><tbody><tr><td style="text-align:left">秒</td><td style="text-align:left">[0, 59]</td><td style="text-align:left">* , - /</td></tr><tr><td style="text-align:left">分钟</td><td style="text-align:left">[0, 59]</td><td style="text-align:left">* , - /</td></tr><tr><td style="text-align:left">小时</td><td style="text-align:left">[0, 23]</td><td style="text-align:left">* , - /</td></tr><tr><td style="text-align:left">日</td><td style="text-align:left">[1, 31]</td><td style="text-align:left">* , - / ? L W</td></tr><tr><td style="text-align:left">月</td><td style="text-align:left">[1, 12] / [JAN, DEC]</td><td style="text-align:left">* , - /</td></tr><tr><td style="text-align:left">周</td><td style="text-align:left">[1, 7] / [MON, SUN]</td><td style="text-align:left">* , - / ? L #</td></tr></tbody></table></div><h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><div class="table-container"><table><thead><tr><th style="text-align:left">特殊字符</th><th style="text-align:left">含义</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">任意值</td><td style="text-align:left">在周域中，<em>指某周中的每一天；在月域中，</em>指每个月</td></tr><tr><td style="text-align:left">,</td><td style="text-align:left">枚举值列表分隔符</td><td style="text-align:left">在分钟域中，1,3,5表示在某个小时中，第1,3,5分钟分别执行一次</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">范围</td><td style="text-align:left">在分钟域中，20-30表示在某个小时中，在20-30分钟里，每分钟执行一次</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">指定值的增量</td><td style="text-align:left">在分钟域中，10/15表示在某个小时中，在第10分钟开始，每15分钟执行一次</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">不定值</td><td style="text-align:left">日和周域在其中一个指定值后，另一个需要设置为?</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">last，最后一天，仅日和周可用</td><td style="text-align:left">在周域中，L表示某个周的最后一天<br>在日域中，L表示某个月的最后一天<br>在周域中，6L表示某个月的最后一个周六</td></tr><tr><td style="text-align:left">W</td><td style="text-align:left">weekday，工作日，不会跨月</td><td style="text-align:left">在日域中，5W指某月的第5天<br>若5W是周六，则在第4天，即周五执行<br>若5W是周日，则在第6天，即周一执行<br>若5W是工作日，则在5W执行</td></tr><tr><td style="text-align:left">#</td><td style="text-align:left">指定某月的第几个周几，仅周可用</td><td style="text-align:left">在周域中，4#2表示某个月的第2个周四</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="基础知识" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="编程" scheme="https://jinyu.host/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA快捷键</title>
    <link href="https://jinyu.host/2022/08/16/IntelliJ%20IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://jinyu.host/2022/08/16/IntelliJ%20IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2022-08-16T04:08:02.000Z</published>
    <updated>2022-08-16T04:08:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="table-container"><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">快捷键</th></tr></thead><tbody><tr><td style="text-align:left">书签</td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>F11</kbd></td></tr><tr><td style="text-align:left">返回</td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>←</kbd></td></tr><tr><td style="text-align:left">展示类结构</td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>F12</kbd></td></tr><tr><td style="text-align:left">在资源管理器中打开</td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F12</kbd></td></tr><tr><td style="text-align:left">最近编辑文件列表</td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>E</kbd></td></tr><tr><td style="text-align:left">定位行</td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>G</kbd></td></tr><tr><td style="text-align:left">转去定义</td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>B</kbd> / <kbd>Ctrl</kbd> + <kbd>鼠标左键</kbd></td></tr><tr><td style="text-align:left">查找引用</td><td style="text-align:left"><kbd>Alt</kbd> + <kbd>F7</kbd></td></tr><tr><td style="text-align:left">定位下一个错误</td><td style="text-align:left"><kbd>F2</kbd></td></tr><tr><td style="text-align:left">重命名</td><td style="text-align:left"><kbd>Shift</kbd> + <kbd>F6</kbd></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    <category term="IDE" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/Java/IDE/"/>
    
    
    <category term="Java" scheme="https://jinyu.host/tags/Java/"/>
    
    <category term="编程" scheme="https://jinyu.host/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="IDE" scheme="https://jinyu.host/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Newtonsoft.Json使用总结</title>
    <link href="https://jinyu.host/2022/08/16/Newtonsoft.Json%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://jinyu.host/2022/08/16/Newtonsoft.Json%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-16T02:33:38.000Z</published>
    <updated>2022-08-16T02:33:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>Json.NET is a popular high-performance JSON framework for .NET</p></blockquote><div class="tag link"><a class="link-card" title="github地址" href="https://github.com/JamesNK/Newtonsoft.Json"><div class="left"><img src="https://github.com/favicon.ico"/></div><div class="right"><p class="text">github地址</p></div></a></div><div class="tag link"><a class="link-card" title="官网" href="https://www.newtonsoft.com/json"><div class="left"><img src="https://www.newtonsoft.com/favicon.ico"/></div><div class="right"><p class="text">官网</p></div></a></div><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>可以在官网或github仓库查看详细文档。在ide中使用时，无需下载代码，在nuget包管理器中搜索即可，或直接<code>using Newtonsoft.Json;</code>，再使用<kbd>Alt</kbd> + <kbd>Enter</kbd>智能引用</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>简单用法：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsonConvert.SerializeObject(<span class="built_in">object</span>? <span class="keyword">value</span>);</span><br></pre></td></tr></table></figure></p><p>可以创建扩展类方便使用：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">NewtonsoftJsonExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ToJson</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">object</span>? <span class="keyword">value</span></span>)</span> =&gt; JsonConvert.SerializeObject(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>简单用法：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsonConvert.DeserializeObject&lt;T&gt;(<span class="built_in">string</span> <span class="keyword">value</span>);</span><br></pre></td></tr></table></figure></p><p>可以创建扩展类方便使用：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">NewtonsoftJsonExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T? FromJsonToObj&lt;T&gt;(<span class="keyword">this</span> <span class="built_in">string</span> <span class="keyword">value</span>) =&gt; JsonConvert.DeserializeObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="返回Json时日期格式化"><a href="#返回Json时日期格式化" class="headerlink" title="返回Json时日期格式化"></a>返回Json时日期格式化</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>dto类中的属性：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 版本生效年月，格式为yyyy-MM</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 例：&quot;2021-11&quot;</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">DataMember(Name = <span class="string">&quot;effectivePeriod&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">JsonProperty(<span class="string">&quot;effectivePeriod&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">JsonConverter(typeof(ResponseDateFormatter.YearMonth))</span>]</span><br><span class="line"><span class="keyword">public</span> DateTime EffectivePeriod &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure></p><p>日期格式化类：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回日期格式化类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ResponseDateFormatter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> yyyy-MM</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">YearMonth</span> : <span class="title">IsoDateTimeConverter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">YearMonth</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            DateTimeFormat = <span class="string">&quot;yyyy-MM&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>通过继承<code>IsoDateTimeConverter</code>，然后在<code>ctor</code>中对<code>DateTimeFormat</code>属性赋值格式化字符串，之后可以在序列化时需要格式化的<code>DateTime</code>类型的属性上加上<code>[JsonConverter()]</code>特性，参数为<code>typeof(继承类)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term=".NET" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/NET/"/>
    
    <category term="C#" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/NET/C/"/>
    
    <category term="第三方库" scheme="https://jinyu.host/categories/%E7%BC%96%E7%A8%8B/NET/C/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="编程" scheme="https://jinyu.host/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term=".NET" scheme="https://jinyu.host/tags/NET/"/>
    
    <category term="C#" scheme="https://jinyu.host/tags/C/"/>
    
    <category term="第三方库" scheme="https://jinyu.host/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>并发编程锁之ReentrantLock总结</title>
    <link href="https://jinyu.host/2020/09/06/23579483-7206-449c-aa75-14d135b74afd/"/>
    <id>https://jinyu.host/2020/09/06/23579483-7206-449c-aa75-14d135b74afd/</id>
    <published>2020-09-06T03:47:22.000Z</published>
    <updated>2020-09-06T03:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>之前我讲过，在并发编程中一个比较难解决的就是共享资源并发访问控制问题。如果同步做的不好，很容易出现不一致问题，从而导致业务逻辑的错误；但是如果对共享资源控制的过于严格，又很容易对性能造成很大的影响。在并发编程中，一方面多从大牛的源码中学习精巧的思想和结构设计；另一方面要对并发基础知识掌握的足够牢固，你才能游刃有余的结合些设计模式、架构思想做出些高质量的高并发、高性能的系统。并发编程对设计模式、架构设计是非常依赖的，因此，并发编程对经验的积累、知识的积累方面要求是比较高的。</p><p>刚才说过，共享资源在并发访问中很容易造成不一致问题，解决方案就是我们所熟知的悲观锁和乐观锁。悲观锁就如其名字一样：悲观锁认为并发访问一定会导致状态不一致问题，所以在并发操作前一定要锁住资源，让并发线程一个接一个串行化去访问。而乐观锁就不一样了，乐观锁认为并发访问在大多数情况下是不会导致状态不一致问题，所以可以放心的去访问，一旦出现问题再说，本质上乐观锁是不会对共享资源添加锁限制的。这是我个人的理解，可能直白不是那么的精准，有关悲观锁、乐观锁的定义可以搜索更准确的官方解释。</p><p>我们来看看在Java中是如何实现悲观锁和乐观锁的。悲观锁在Java中就是我们所熟知的锁，实现方式主要分为两种：synchronized和Lock，而乐观锁的实现主要通过CAS操作实现。这里我们来比较下synchronized和Lock方式的大致差别：<br>​ 1、synchronized主要依赖JVM底层实现，而Lock是通过编码方式实现，其实现方式差别还是比较大<br>​ 2、synchronized由于其简单方便，只需要声明在方法、代码块上即可，主要是不需要关心锁释放问题，在一般的编程中使用量还是比较大的，但是在真正的并发编程系统中，Lock方式明显优于synchronized：<br>​ a.在高版本JDK中，已经对synchronized进行了优化，synchronized和Lock方式在性能方面差别已不太明显<br>​ b.synchronized最致命的缺陷是：synchronized不支持中断和超时，也就是说通过synchronized一旦被阻塞住，如果一直无法获取到所资源就会一直被阻塞，即使中断也没用，这对并发系统的性能影响太大了；Lock支持中断和超时、还支持尝试机制获取锁，对synchronized进行了很好的扩展，所以从灵活性上Lock是明显优于synchronized的</p><p>在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock(实现类ReentrantReadWriteLock)，ReentrantLock在锁的使用上算是非常普遍的，这一节我们就以ReentrantLock为例，分析下Lock实现方式。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是一个可重入的互斥锁，所谓可重入是线程可以重复获取已经持有的锁。锁基本上都是要支持可重入性，否则很容易出现死锁问题。比如：假如锁B不支持可重入性，线程A在持有锁B的情况下再次获取锁B，由于不支持可重入性导致线程A被阻塞，知道锁B资源被释放，但是锁B资源是被线程A持有的，所以线程A永远无法因获取到锁B而被唤醒，这就导致了死锁问题。</p><p>ReentrantLock内部实现主要通过AbstractQueuedSynchronizer类实现的，AbstractQueuedSynchronizer是抽象类，在ReentrantLock类中有两个实现类：NonfairSync和FairSync，分别对应非公平锁和公平锁的实现。类结构关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">            +-------------------------------+</span><br><span class="line">            |  AbstractQueuedSynchronizer   |</span><br><span class="line">            +--------------^----------------+</span><br><span class="line">                           |</span><br><span class="line">                           |</span><br><span class="line">             +------------------------------+</span><br><span class="line">             |           Sync               |</span><br><span class="line">             +--------^----------^----------+</span><br><span class="line">                      |          |</span><br><span class="line">                      |          |</span><br><span class="line">+-----------------------+      +-----------------------+</span><br><span class="line">|   NonfairSync         |      |     FairSync          |</span><br><span class="line">+-----------------------+      +-----------------------+</span><br></pre></td></tr></table></figure><p>ReentrantLock类内部持有一个Sync类型的变量，主要实现基本上都是调用Sync的实现机制，默认构建的是NonfairSync，即非公平锁，也可以通过带Boolean类型的构造函数构建公平锁，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、默认创建的非公平锁，性能更高，等价于ReentrantLock(false)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fair true:公平锁    false:非公平锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取锁原理"><a href="#获取锁原理" class="headerlink" title="获取锁原理"></a>获取锁原理</h3><p>使用ReentrantLock时，一般流程大致为：1、调用lock()申请锁资源，申请成功则立即返回，如果申请不到则会阻塞直到申请成功；2、申请锁成功后，即可进行共享资源操作；3、共享资源操作完成，最后调用unlock()释放锁资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、获取锁，如果该锁没有被其它线程持有则立即返回，并设置该lock的hold count=1</span></span><br><span class="line"><span class="comment">* 2、如果当前线程已经持有该锁，则lock的count+1并立即返回</span></span><br><span class="line"><span class="comment">* 3、如果该锁被其它线程持有，则当前线程处于休眠直到获取锁，获取锁同时设置hold count=1</span></span><br><span class="line"><span class="comment">* 4、sync.lock()会调用Sync具体实现类NonfairSync、FairSync中的lock()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock.lock()源码非常简单，调用sync.lock()，这就体现了ReentrantLock核心机制都是在Sync中实现的，上面已说过ReentrantLock中的Sync中有两个子类分别对应公平锁和非公平锁，这里我们就来先看非公平锁NonfairSync的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* state在AbstractQueuedSynchronizer类中定义，表示当前锁状态：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  0：当前锁锁未被任何线程持有，线程获取锁资源时可以使用CAS原子操作compareAndSetState(0, 1)</span></span><br><span class="line"><span class="comment">*     将state由0修改成1，修改成功表示获取锁成功，state这时被修改成1了，并将exclusiveOwnerThread设置成当前Thread，</span></span><br><span class="line"><span class="comment">*     exclusiveOwnerThread即表示持有锁的线程</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  &gt;0：表示当前锁被线程持有，因为ReentrantLock是重入锁，同一个线程可以重入多次锁，每重入一次state加1，</span></span><br><span class="line"><span class="comment">*      同样在释放锁资源release()的时候，每释放一次state减1，直到state=0表示全部释放完成，可以被其它线程竞争使用</span></span><br><span class="line"><span class="comment">*      state大于0时CAS原子操作compareAndSetState(0, 1)会失败，即进入另一分支</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//当前线程获取锁成功，并将当前线程赋值给exclusiveOwnerThread变量</span></span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);<span class="comment">//该分支则表示已有线程持有当前锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑也很简单，通过一个CAS操作将state由0设置成1，成功则获取锁成功，并让Sync的exclusiveOwnerThread变量持有当前线程，供后续当前线程重入使用；如果CAS操作失败，则表示存在竞争，已有线程获取到锁，当前线程获取锁失败，需要进入acquire(1)分支。可以看到ReentrantLock的核心就是通过state字段的值判断是否被占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、调用tryAcquire尝试获取锁，注意：tryAcquire在AbstractQueuedSynchronizer类中实现直接抛出异常，一般是子类NonfairSync、FairSync继承重写该方法</span></span><br><span class="line"><span class="comment">* 2、tryAcquire会做如下尝试：</span></span><br><span class="line"><span class="comment">*      a.如果state=0表示当前锁又没有被线程所持有，重新获取一次锁，成功返回true，失败返回false</span></span><br><span class="line"><span class="comment">*      b.如果持有锁的线程就是当前线程，则将state累加1，用于记录重入次数，释放的时候也要全部释放，并返回true表示获取锁成功</span></span><br><span class="line"><span class="comment">*      c.非以上两种情况，直接返回fasle</span></span><br><span class="line"><span class="comment">* 3、如果获取锁成功，即tryAcquire返回true，则直接返回</span></span><br><span class="line"><span class="comment">* 4、如果获取锁失败，即tryAcquire返回false，则将当前线程封装成Node放入到Sync Queue里(调用addWaiter)，等待Signal信号</span></span><br><span class="line"><span class="comment">* 5、调用acquireQueued进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking)</span></span><br><span class="line"><span class="comment">* 4、根据acquireQueued的返回值判断在获取lock的过程中是否被中断, 若被中断, 则自己再中断一下(selfInterrupt)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//acquireQueued的主要作用是把已经追加到队列的线程节点（addWaiter方法返回值）进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer中acquire()逻辑大致如下：</p><p> 1、首先调用tryAcquire()，该方法的目的主要是：a.重新自旋一次获取下锁看看是否成功，成功则返回true；b.判断持有锁的线程是否就是当前线程，如果是的话，直接在state累加1，并返回true表示获取锁成功；c.如果上述两个目的都没有实现，则返回false，表示获取锁失败。注意：tryAcquire()在AbstractQueuedSynchronizer中是直接抛出异常，具体调用的是子类NonfairSync中的实现逻辑，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、该方法重新获取锁state，如果state=0表示当前又没有线程持有该锁了，则重新获取一次锁，成功返回true，失败返回false</span></span><br><span class="line"><span class="comment">* 2、如果持有该锁的线程就是当前线程，则也会返回true表示获取锁成功，并将state累加acquires</span></span><br><span class="line"><span class="comment">* 3、否则返回false表示获取锁失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果等于0表示此刻已没有线程持有该锁，所以重新获取一次锁，成功则立即返回true，否则立即返回false</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="comment">//如果持有该锁的线程就是当前线程，则将state+1，然后立即返回true表示获取锁成功，这是可重入锁特性</span></span><br><span class="line"><span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);<span class="comment">//修改state值，此处只会持有锁的线程才会执行，不存在多线程竞争情况，所以通过setState修改，而非CAS，这段代码实现了偏向锁的功能</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、如果tryAcquire()获取锁失败则执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)语句，首先我们来看下addWaiter(Node.EXCLUSIVE)，它的作用就是将无法获取锁的线程追加到一个双向链表中，然后让线程休眠，当锁资源可用时会从该双向链表头部唤醒一个线程去竞争锁资源，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、将无法获取锁的当前线程封装成Node加入到Sync Queue里面，其中参数mode是独占锁还是共享锁，null表示独占锁。如果是读写锁mode就为共享锁模式</span></span><br><span class="line"><span class="comment">* 2、Sync Queue实现的一个双向链表，包含head和tail分别指向头部和尾部Node，head和tail设置为了volatile,这两个节点的修改将会被其他线程看到,主要是通过修改这两个节点来完成入队和出队</span></span><br><span class="line"><span class="comment">* 3、当新加入Node时，将tail指向新加入的Node，同时之前的Node的next指向新Node，新Node的pre指向之前的tail节点，即在双向链表上添加节点成功</span></span><br><span class="line"><span class="comment">* 4、总而言之，addWaiter的目的就是通过CAS把当前线程封装的Node追加到队尾，并返回该Node实例。</span></span><br><span class="line"><span class="comment">* 5、把线程要包装为Node对象的主要原因：</span></span><br><span class="line"><span class="comment">*        a.构造双向链表时，需要指针前驱节点和后驱节点</span></span><br><span class="line"><span class="comment">*        b.Node中mode用于区分是否是排它模式还是共享模式</span></span><br><span class="line"><span class="comment">*        c.Node中的waitStatus用于表示当前线程状态：</span></span><br><span class="line"><span class="comment">                    SIGNAL(-1) ：线程的后继线程正/已被阻塞，当该线程release或cancel时要重新唤醒这个后继线程</span></span><br><span class="line"><span class="comment">                    CANCELLED(1)：因为超时或中断，该线程已经被取消，其前驱节点释放锁后不会让处于该种状态的线程去竞争锁资源</span></span><br><span class="line"><span class="comment">                    CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了Condition.await而被阻塞</span></span><br><span class="line"><span class="comment">                    PROPAGATE(-3)：传播共享锁</span></span><br><span class="line"><span class="comment">                    0：0代表无状态，默认Node就是该种状态，当存在后驱节点追加，就去把其前驱节点设置成SIGNAL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line"><span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;<span class="comment">//默认head = tail = null, tail !=null说明队列中已经有节点,直接CAS到尾节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将当前Node追加到Queue尾部：</span></span><br><span class="line"><span class="comment">        *      1、将当前node的前驱节点设置成tail节点</span></span><br><span class="line"><span class="comment">        *      2、通过cas操作将tail指针指向当前node</span></span><br><span class="line"><span class="comment">        *      3、并将之前的tail节点的next指向当前node</span></span><br><span class="line"><span class="comment">        * 通过上面三步骤，即将一个node追加到双向链表的尾部</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//4.CAS node到tail</span></span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);<span class="comment">//执行到这里，表明Queue队列为空,调用enq会初始化队列并将当前node追加到尾部</span></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、这里通过一个死循环方式调用CAS，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾</span></span><br><span class="line"><span class="comment">* 2、第一次循环tail肯定为null，则会初始化一个默认的node，并将head=tail指向该node</span></span><br><span class="line"><span class="comment">* 3、第二次循环的时候，会将当前node追加到1中创建的node尾部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">//1.队列为空,初始化一个dummy节点,其实和ConcurrentLinkedQueue一样</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、addWaiter(Node.EXCLUSIVE)将当前线程封装的Node节点添加到等待锁资源的Queue上后，接下来要执行acquireQueued()，该方法是获取锁逻辑比较核心的一个方法，关键点有如下几个：<br>​ a.该方法被设计成了一个无限for循环，只有满足通过tryAcquire()获取到锁时才会退出该循环，当然如果没有获取到锁也不会一直在for循环中进行空循环，而是通过parkAndCheckInterrupt()让线程休眠，当线程被唤醒后才会执行一次for循环看是否可以获取锁，获取成功则会将Queue的head指针指向当前thread，并将之前head废弃<br>​ b.在tryAcquire()竞争锁资源时，会存在p == head判断，判断当前线程的前驱节点是否是head节点，只有前驱是head节点的线程才有资格调用tryAcquire()去竞争锁资源，这个设计思想逻辑主要是：申请锁资源失败的线程会依次加入到Queue中，head指向头部，tail指向尾部，如果head不为空，则该节点代表的线程为锁的占有者，当该线程释放锁时，它会唤醒它的后驱节点，而不是Queue中所有线程，因此，每次释放锁时只会唤醒一个线程，唤醒顺序也是从head到tail依次唤醒，而不是存在锁资源时一起唤醒然后竞争锁资源，因为这样如果存在几百几千个线程，同时竞争锁资源对系统性能损耗很大，有效的避免性能风暴<br>​ c.该方法在让线程真正休眠前会让线程再次自旋一次获取锁，如果还是失败则立即进入休眠状态，作者这么设计就体现了：让线程休眠还是比较耗费性能资源的，涉及到上下文切换，另外当线程唤醒时可能会被分配到其它CPU上执行，由于高速缓存L1、L2是CPU独有的，就会降低高速缓存命中率，对性能影响还是比较大的，因此能尽量不休眠就不会让线程休眠<br>​ d.当有线程释放锁时，会唤醒Queue头部线程的后驱节点，唤醒后依然要竞争锁，竞争的对象是刚申请锁资源还没有进入到Queue等待队列的线程们，如果竞争失败则再次进入休眠状态，这就体现了非公平锁的特性，这么设计的目的：主要从性能考虑，如果新申请锁的线程可以立即获取到锁，避免了后续一系列创建Node、添加Node到队列等一些列操作，而从Queue中唤醒的线程没有申请到锁只是重新进入休眠，代价要小很多，同时让它们一起竞争锁资源避免Queue等待队列中的线程一直无法获取锁而被饿死情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、该方法是一个无限死循环，只有保证前驱节点就是头节点，并且重新调用一次tryAcquire()获取锁并成功，才会推送该循环</span></span><br><span class="line"><span class="comment">* 2、否则会执行shouldParkAfterFailedAcquire()将当前node的前驱节点的waitStatus设置成SIGNAL，表示当它的前驱节点释放锁后会唤醒当前线程，然后当前线程就可以放心的让自己休眠了</span></span><br><span class="line"><span class="comment">* 3、调用shouldParkAfterFailedAcquire()时，由于默认前驱节点的waitStatus不等于SIGNAL，所以会将前驱节点设置成SIGNAL，但是注意这时的返回结果是false，表示并不会立即让当前线程进入休眠状态，而是重新执行一次for循环，相当于给了一次重新获取锁的机会，如果获取锁成功，则将head节点指向当前节点，之前头结点就废弃了；如果获取失败则调用parkAndCheckInterrupt()让线程真正进入休眠状态</span></span><br><span class="line"><span class="comment">4、parkAndCheckInterrupt()中调用LockSupport.park()让当前线程休眠，客户端也就进入阻塞状态，注意这里有个关键点：当休眠状态的线程被唤醒后，需要再次执行一次for循环通过tryAcquire()来竞争锁资源，竞争成功则退出当前for循环，当然也有可能会竞争失败，如果竞争失败会再次进去休眠状态</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    Queue队列中的线程是按照从头到尾部的顺序依次唤醒的，每次只会唤醒Queue中的一个线程，为什么还会出现竞争呢？这是因为虽然从Queue中只会唤醒一个线程，但是假如同时又有一个线程执行lock来获取锁资源，而此时并没有放入Queue等待队列中，它就会和从Queue中唤醒的线程进行竞争锁资源，这就体现了非公平锁的特性：后申请锁资源的线程可能会比先申请锁资源的线程优先申请到锁资源。</span></span><br><span class="line"><span class="comment">*    为什么要这么设计呢？</span></span><br><span class="line"><span class="comment">*    主要从性能考虑，如果新申请锁的线程可以立即获取到锁，避免了后续一系列创建Node、添加Node到队列等一些列操作，而从Queue中唤醒的线程没有申请到锁只是重新进入休眠，代价要小很多,同时让它们一起竞争锁资源避免Queue等待队列中的线程一直无法获取锁而被饿死情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//1.获取当前节点的前驱节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line"><span class="comment">//2.判断前驱节点是否是head节点(前继节点是head, 存在两种情况：</span></span><br><span class="line"><span class="comment">//      a.前继节点现在占用lock</span></span><br><span class="line"><span class="comment">//      b.前继节点是个空节点,已经释放lock,node现在有机会获取lock; 则再次调用tryAcquire尝试获取一下锁，该源码之前已经分析过</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);<span class="comment">//3.获取lock成功,直接设置新head(原来的head可能就直接被GC回收)</span></span><br><span class="line">p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;<span class="comment">//4.返回在整个获取的过程中是否被中断过；若整个过程中被中断过,则最后我在自我中断一下(selfInterrupt),因为外面的函数可能需要知道整个过程是否被中断过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shouldParkAfterFailedAcquire(p, node)返回当前线程是否需要挂起，如果需要则调用parkAndCheckInterrupt()让当前线程休眠</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())<span class="comment">//6.parkAndCheckInterrupt会把当前线程挂起，从而阻塞住线程的调用栈,返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">interrupted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)<span class="comment">//7.在整个获取中出错</span></span><br><span class="line">cancelAcquire(node);<span class="comment">//8.清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//利用LockSupport的park方法来挂起当前线程的，直到被唤醒。</span></span><br><span class="line">LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，基本上对ReentrantLock非公平锁获取锁资源的流程有一个比较清晰的认识了。公平锁和非公平锁流程基本一致，区别只是在tryAcquire()获取锁逻辑的差别，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FailSync类中的tryAcquire()获取锁逻辑：</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当锁资源可用(state=0)并且当Queue队列中不存在等待锁资源的线程时，才会通过cas操作将state由0设置成1，表示申请锁资源成功，否则都将加入到Queue队列的尾部。对比非公平锁获取锁资源逻辑nonfairTryAcquire()，差别主要是：非公平锁只要判断锁资源可用就会立即通过cas操作获取锁资源，而公平锁则会在锁资源可用的情况下，还要满足Queue队列中无等待锁资源线程才能立即申请锁资源，否则会被追加到Queue队列的尾部，这就体现了公平特性。</p><p>上面已经将ReentrantLock.lock()获取锁的流程基本都 分析完成，当然ReentrantLock还提供lockInterruptibly()、tryLock()、tryLock(long timeout, TimeUnit unit)等，如果对lock()逻辑比较清楚，这些方式获取锁的原理就比较简单了，下面大致说下。</p><p>ReentrantLock.lockInterruptibly()：可中断方式获取锁，通过之前源码分析，线程如果没有获取到锁，会通过LockSupport.park()方式休眠，当锁资源释放时，其它线程调用Lock.unpark()唤醒休眠线程去竞争锁资源，但是LockSupport.park()休眠的线程也可以通过中断方式进行唤醒，可中断锁就是在唤醒时候判断如是中断唤醒，则直接抛出异常，而lock()方式获取的锁使用中断唤醒后直接去竞争锁资源了，竞争不到直接休眠，这就是它们的差别，具体实现看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">//进入阻塞状态，阻塞解除时，返回true表示中断方式唤醒</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();<span class="comment">//中断唤醒时，不会去竞争锁资源，而是直接抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock.tryLock()：可尝试性获取锁，获取到返回true，获取不到直接返回fasle，而不会阻塞，实现方式就更简单了，直接nonfairTryAcquire()获取锁，获取到立即返回true，获取不到立即返回false，而不是添加到Sync Queue阻塞队列中去等待。</p><p>ReentrantLock.tryLock(long timeout, TimeUnit unit)：会尝试一段时间，这段时间都无法获取锁就返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;<span class="comment">//超时时间</span></span><br><span class="line">  <span class="comment">//加入到Sync Queue，这里主要是性能优化，下面获取锁的逻辑在for无线循环中，如果超时时间设置较长</span></span><br><span class="line">        <span class="comment">//一直无线循环下去肯定浪费CPU资源，所以会进行休眠，等待前驱节点释放锁时会唤醒该线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)<span class="comment">//如果超时，直接返回false，表示获取锁失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)<span class="comment">//如果超时时间现在大于1000纳秒，就会进入休眠，否则就不停的for循环，因为超时时间太短，没必要进行休眠，比较休眠还是比较耗费资源的</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//可响应中断的，如果中断则会抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面对ReentrantLock源码分析，Lock机制的核心就是通过cas原子操作state属性，state=0表示锁资源可用，获取锁就是通过cas原子操作将state从0设置成1，成功就表示获取锁成功，如果state&gt;0,cas操作将会失败，即表示锁已被占用，当前获取锁失败。获取锁失败，根据是否是可中断、可超时等特性，处理的逻辑不太一致，但大致为：<br>​ 1、将获取锁失败的线程封装成Node，封装成Node一方面是要构建双向队列，另一方面是Node中额外添加状态信息对节点进行控制<br>​ 2、在一个for无线循环中通过Lock.park()让线程休眠，当有锁资源被释放发生时，会从队列头到尾的顺序依次唤醒线程(会跳过CANCELLED标记的节点，因为这些节点代表的线程已经无效了)，注意这里只会唤醒一个线程，唤醒的线程只表示该线程具有竞争锁资源的资格，还需要和新申请但还没有放入到Queue中的线程进行竞争该锁资源，这就是非公平锁的特性，这样设计主要是从性能方面考虑，如果竞争成功则退出for循环返回，否则继续进入休眠状态</p><p>最后再通过一个大致流程图，对整体的执行流程有个更清晰认识。</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/ReentrantLock获取锁流程.png" alt=""></p><h3 id="释放锁原理"><a href="#释放锁原理" class="headerlink" title="释放锁原理"></a>释放锁原理</h3><p>接下来我们来分析下ReentrantLock释放锁资源的流程。释放锁没有区分公平和非公平的，主要的工作就是减小state的值，当state等0的时候，释放锁并唤醒Queue中其他线程来获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release()是在AbstractQueuedSynchronizer中实现的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//tryRelease:尝试释放状态，返回true表示锁资源释放完成，</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、只有持有该锁的线程才会执行tryRelease()，因此不会涉及到多线程问题，不需要使用cas保证原子性</span></span><br><span class="line"><span class="comment">* 2、调用该方法会将state-1，然后判断state值，如果等于0表示当前线程已经释放锁资源完成，返回true，</span></span><br><span class="line"><span class="comment">*    并将exclusiveOwnerThread设置成null，表示当前锁资源空闲，未被线程占用</span></span><br><span class="line"><span class="comment">* 3、如果state&gt;0，则表示当前并未释放完全，返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//只有state=0表示该锁被所有线程都释放完成，即锁可以被其它线程占用了，否则只是释放一次重入次数，并不会释放锁</span></span><br><span class="line">free = <span class="literal">true</span>;</span><br><span class="line">setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">setState(c);<span class="comment">//不存在并发问题，采用setState()而非cas操作，提供性能</span></span><br><span class="line"> <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h3><p>上面通过源码已经对ReentrantLock获取锁和释放锁的大致流程有了比较清晰的认识，当你越深入分析时你会对Doug Lea这位大牛构思和多线程并发处理的游刃有余感到惊叹，以及后面我们会讲到的IO模型，依然会有Doug Lea大牛的精彩大作，如果你对他还不了解，可以多搜索关注下。</p><p>了解了流程并不一定就表示你已经完全熟悉ReentrantLock，你知道他是这么做的，但是你不一定清楚他这么做背后的考量是什么，毕竟并发编程比单线程编程复杂性高出太多，你很难顾及到所有线程分支运行的流程，这就是很容易导致bug的根源。上面我们已经分析过addWaiter()这个方法的作用，下面通过该方法进行更深入的分析，希望对并发编程的认识更加深刻。</p><p>addWaiter()方法主要完成工作：将未获取锁的线程封装成Node，然后追加到等待队列Queue尾部，等待队列Queue并不存在一个定义好的数据结构，而是通过head、tail、next和prev模拟出的具有出队、入队操作的双向链表。追加当前节点到双向链表尾部关键源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//4.CAS node到tail</span></span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面代码梳理一下，大致分为三个步骤：<br>​ 1、将当前node的prev指向tail节点；<br>​ 2、通过cas原子操作将tail指针指向当前节点；<br>​ 3、将之前tail节点的next指向当前节点。</p><p>示意图如下：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/追加节点.jpg" alt=""></p><p>假如将追加节点的三个步骤顺序调换下，先将tail节点的next指向当前节点，然后cas原子修改tail指向，最后再来修改当前节点的prev指向，即将上面的1和3对调一下，会出现上面情况呢？</p><p>将tail节点的next指向当前节点操作后，紧接着会执行cas操作修改tail指向当前节点，由于存在多线程并发问题，即可能会存在多个线程同时申请锁资源，假如现在t1、t2两个线程都同时做上面两个步骤：<br>​ 1、t1线程修改next后，紧接着t2线程也修改next指向，导致会把t1修改的指向覆盖；<br>​ 2、这时t1线程做cas替换tail指向成功后，t2也来做cas操作就会失败；<br>​ 3、t1由于cas操作成功，最后修改prev指向</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/追加节点2.jpg" alt=""></p><p>可以发现，由于并发导致追加的t1节点是存在问题的，正常情况下Node1的next应该指向t1节点，但是却被t2节点覆盖了。所以，1和3对调是在并发下是存在问题的。</p><p>假如1和2对调，先进行cas操作，然后修改prev，最后再来修改next又会怎么样呢？首先通过cas原子操作将tail指向当前节点，示意图如下：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/追加节点3.jpg" alt=""></p><p>tail节点这时还是孤立的节点，prev和next都还没有指向，tail节点和其它节点之间没有关联了，这时如果其它线程需要遍历这个双向链表就比较危险了，比如释放锁时会调用unparkSuccessor()，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前节点的后继节点，如果满足状态，那么进行唤醒操作  // 如果没有满足状态，从尾部开始找寻符合要求的节点并将其唤醒</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//s.waitStatus&gt;0表示当前线程已被CANCELLED，不需要唤醒</span></span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//从tail向前查找，知道找到waitStatus&lt;=0的线程，赋值给s</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队列的维护（首节点的更换）是依靠消费者（获取时）来完成的，也就是说在满足了自旋退出的条件时的一刻，这个节点就会被设置成为首节点。</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现其可能会存在一个从tail向前查找的流程，假如刚好这时执行这个流程，从tail向head查找节点显然就会存在问题，所以1和2对调的流程在并发下也是存在问题的。unparkSuccessor()在查找head的下一个有效节点的时候，没有从head到tail方向查找，而是反方向从tail向head查找，正常逻辑肯定是从head向tail方向查找速度更快，但是为啥反其道而行呢？如果你只看这段代码是永远看不出问题的，具体原因可以参加下面正常流程分析情况。</p><p>错误的顺序我就不一一举例了，大致都是差不多，现在我们来分析下为什么源码中这个顺序执行在并发下就不会存在问题。现在假设两个线程同一时间都没有获取到锁，都需要追加到Sync Queue队列尾部，大致流程如下：<br>​ 1、线程t1的节点设置prev指向tail，线程t2节点同时也设置prev指向tail，这时就不会出现上面如果先设置next就会导致后设置把之前设置覆盖情况，因为如果先设置next是对Node1进行操作，存在多个线程对Node1同时操作导致状态不一致问题，而如果这里先设置prev，操作对象时线程本身的节点，是不存在多线程并发问题，示意图如下：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/追加节点5.png" alt=""></p><p> 2、这时t1和t2都进行cas原子操作，反正会有一个线程会操作成功，假如是t1线程操作成功，然后就可以顺利的设置Node1节点的next指向t1，因为只会存在一个线程操作成功，所以对Node1的操作此时也不会存在并发问题，由于t1的cas操作成功导致t2线程进行cas操作必然失败，此刻示意图如下：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/追加节点6.png" alt=""></p><p> 3、由于t2线程cas操作失败，因此不再继续操作Node1的next指向自己，而是进入enq()方法中，其源码如下，enq方法中通过cas+无限循环方式保证t2节点一定会被追加到Sync Queue尾部的，每次循环都是重新获取最新的tail，然后将t2的prev指向这个最新的tail，然后通过cas操作将tail指向自己，最后在将之前tail节点的next指向t2节点，这个案例中获取的最新tail就是t1节点了，所以t2节点会被追加到t1节点后，这样就能保证即使在高并发下依然可以实现节点正常添加，而不会像之前出现状态不一致情况，示意图如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、这里通过一个死循环方式调用CAS，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾</span></span><br><span class="line"><span class="comment">* 2、第一次循环tail肯定为null，则会初始化一个默认的node，并将head=tail指向该node</span></span><br><span class="line"><span class="comment">* 3、第二次循环的时候，会将当前node追加到1中创建的node尾部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">//1.队列为空,初始化一个dummy节点,其实和ConcurrentLinkedQueue一样</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/追加节点7.png" alt=""></p><p> 4、上面分析unparkSuccessor()在查找head的下一个有效节点的时候，没有从head到tail方向查找，而是反方向从tail向head查找，如果你对我刚才分析得到逻辑理解透彻的话，就比较好解释了。比如：t1设置prev指向Node1，然后cas操作将tail指向了t1，这时Queue的结构如下，假如这时候执行unparkSuccessor()，Node0查找它的后驱节点为Node1，假如Node1是无效节点，Node1需要继续查找它的后驱节点，但是这时Node1的next并没有设置，是无法查找到的，所以必须从tail向head方向查找才行。</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/追加节点8.png" alt=""></p><p>通过对addWaiter的深入分析，你会对并发编程的难度有一个更加深刻的认识，真是处处要小心，搞不好就掉坑里面去了，但是Doug Lea巧妙的构思处理的游刃有余。</p><p>至此，对ReentrantLock也有了一个比较完整的流程分析，这一节也就结束了，后面会对Lock的其它实现类及synchronized的底层实现机制进行些分析。</p><blockquote><ul><li><strong>本文作者：</strong> zhang</li><li><strong>本文链接：</strong> <a href="http://blog.reactor.top/2018/01/31/并发编程锁之ReentrantLock总结/">http://blog.reactor.top/2018/01/31/并发编程锁之ReentrantLock总结/</a></li><li><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Java" scheme="https://jinyu.host/tags/Java/"/>
    
    <category term="锁" scheme="https://jinyu.host/tags/%E9%94%81/"/>
    
    <category term="并发" scheme="https://jinyu.host/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="多线程" scheme="https://jinyu.host/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程锁之synchronized总结</title>
    <link href="https://jinyu.host/2020/09/02/afd8c681-d4f8-4655-bafa-4a958d92d4df/"/>
    <id>https://jinyu.host/2020/09/02/afd8c681-d4f8-4655-bafa-4a958d92d4df/</id>
    <published>2020-09-01T23:03:02.000Z</published>
    <updated>2020-09-01T23:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>并发编程中数据同步需要依赖锁进行控制，上篇博文通过ReentrantLock源码分析也对Lock实现锁机制的大致原理有了一个了解，Lock主要是通过编码的方式实现锁，其核心就是：CAS+循环，CAS原子操作需要依赖底层硬件层特殊的CPU指令。这节我们来看下Java中另一种非常常见的实现同步的方式：synchronized。synchronized主要通过底层JVM进行实现，而且JVM为了优化，产生偏向锁、轻量级锁、重量级锁，由于其处于JVM底层实现中，对很多并发编程人员来说能清晰理解它们间的区别还是件困难的事。通过本篇博文，构建出对Java中锁得体系结构，让你对其有个更系统全面的认知。</p><p>synchronized实现同步主要分为两种情况：<br>​ 1、同步方法：synchronized方法则会被翻译成普通的方法调用，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位设置成1，表示该方法是同步方法，当某个线程要访问某个方法的时候，使用调用该方法的对象(普通方法同步)或该方法所属的Class在JVM的内部对象表示Klass做为监视器锁(静态方法同步，全局锁)，这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放<br>​ 2、同步代码块：对于同步代码块，JVM采用monitorenter、monitorexit两个指令来实现同步。monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应，这样就保证了执行monitorexit指令的线程是monitor监视器的所有者。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取栈顶对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将栈顶对象锁计数器减1，当计数器为0时，锁就会被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p><p>对于同步方法或同步块，通过Class文件中的access_flags或monitorenter、monitorexit指令来标记执行这些代码时需要进行同步，但是具体如何进行同步呢？这就是接下来要分析的主要内容。再讲解同步之前，我们先来看下对象头，因为JVM中synchronized的实现关键就涉及到对象头的操作。</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>Java中对象的内存布局主要分为三个区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。synchronized的实现方式依赖于对象头，所以，这里我们先来简单介绍下Java中对象头。</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/Java中对象的内存布局.png" alt=""></p><p>实例数据区主要是实例属性数据存储区域，对齐填充在HotSpot中主要采用8字节对齐方式，对象头和实例数据区字节数不是8的倍数，采用对齐填充方式让其等于8的倍数。这里来看下对象头，如果是数组类型，其由MarkWord、length(数组长度)和Pointer，Pointer是指向该对象的元数据信息，即该对象的Class实例，对象的方法定义都是在Class实例中；如果是非数组类型，对象头只包含：MarkWord和Pointer两部分。</p><p>对象头具体描述如下：<br>1、如果是数组类型，则使用3个字宽存储对象头，如果是对象非数组类型，则使用2个字宽，在32位JVM中，一个字宽等于4字节，而64位JVM中，一个字宽等于8字节，即在32-bit JVM上对象头占用8bytes，在64-bit JVM上对象头占用16bytes（开启指针压缩后占用4+8=12bytes）<br>2、64位机器上，数组对象的对象头占用24 bytes，启用压缩之后占用16 bytes。之所以比普通对象占用内存多是因为需要额外的空间存储数组的长度，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。<br>3、HotSpot虚拟机的对象头包括两部分信息：Mark Word(标记字段)和Klass Pointer(类型指针)<br>4、Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等<br>5、对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot 虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/java对象头.png" alt=""></p><p>上图展示的是32位机器下对象头的情况，64位情况下原理大致一样而且更简单，这里就不再介绍了。 MarkWord里默认数据是存储对象的hashcode等信息，但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式，当对象成为锁(被锁住)后，对象头里的MarkWord字段就会存储Monitor信息，Monitor信息可以理解为锁信息。</p><p>锁的状态可分为四种：无锁状态、偏向锁、轻量级锁和重量级锁，其实现原理要依赖对象头进行控制。再了解对象头的基础上，下面我们就可以分析每种锁的实现原理。</p><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><p>早期，synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依赖于底层的操作系统互斥Mutex Lock来实现的，而操作系统实现线程之间的阻塞、调度、唤醒等操作时需要从用户态切换到内核态，最后再由内核态切换到用户态，将CPU的控制权交由用户进程，用户态与内核态之间频繁的切换，严重影响锁的性能，这也是为什么早期的synchronized效率低的原因。</p><p>在Java 6之后Java官方对从JVM层面对synchronized进行较大优化，所以现在的synchronized锁效率也优化得很不错了，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁、轻量级锁和自旋锁等概念，下面就来分析下它们的原理。</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量级锁实现的背后基于这样一种场景假设：在真实生产环境下，我们程序中的大部分同步代码一般都处于无锁竞争状态，轻量级锁主要解决如下场景：线程A和线程B都要访问对象o的同步方法，但是它们之间不会同时访问，线程A访问完成后线程B再去访问，它们之间访问类似于交替访问，因此，这种情况下并不会产生锁竞争问题。在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，只需要依靠CAS原子指令就可以完成锁的获取及释放，但是当检测到存在锁竞争的情况下，轻量级锁就会膨胀为重量级锁。</p><p>下面通过如下同步代码块分析下轻量级锁实现的大致流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 1、当代码进入同步块时，即调用Obj.fun1()方法，当Obj实例为无锁状态，即对象头的锁标志位为01，当前线程会在栈帧中创建一个锁记录(Lock Record)，同时将锁对象Obj的对象头中MarkWord拷贝到锁记录中，因为栈是线程私有的，Java方法的调用就是通过栈帧得到入栈和出栈实现的，所以将锁记录保存到栈帧中，这一步主要完成MarkWord拷贝过程；</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/轻量级锁1.png" alt=""></p><p> 2、将MarkWord拷贝到Lock Record中完成后，尝试使用CAS将MarkWord更新为指向锁记录的指针，如果更新成功，当前线程就获得了锁，同时更新锁标志位为00，表示当前对象处于轻量级锁状态</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/轻量级锁2.png" alt=""></p><p> 3、更新失败情况主要如下：比如有两个线程A和线程B同时竞争锁，执行步骤1时由于当前对象处于无锁状态，所以这两个线程都会在它们的栈帧中创建Lock Record，然后将对象头中的MarkWord拷贝进去，然后它们都同时进入步骤2执行CAS原子操作将对象头中的锁指针指向自己栈帧中的Lock Record，所以，肯定有一个成功，另一个就会失败，成功的就是获取到偏向锁的线程，失败的就是没有获取偏向锁的线程。如果更新失败，JVM会先检查锁对象的MarkWord是否指向当前线程的锁记录，如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块，这是重入锁特性，不是则说明其有其它线程抢占了锁</p><p> 4、其它线程抢占了锁，说明存在锁竞争情况，这时轻量级锁并不为立即膨胀为重量级锁，而是进入自旋模式，自旋模式期间还是无法获取锁，就会膨胀为重量级锁，大致思路：尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有非常重要的性能提高。</p><blockquote><p>为什么要进入自旋模式原因？</p><p>膨胀为重量级锁会涉及到有用户态切换到内核态进行线程的休眠和唤醒操作，然后再切换到用户态，这些操作给系统的并发性能带来了很大的压力，共享数据的锁定状态可能只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后面请求锁的那个线程”稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只需要让线程执行一个忙循环（自旋），所以自旋会对CPU造成资源浪费，特别是长时间无法获取锁的情况下，所以自旋次数一定要设置成一个合理的值，而不能无限自旋下去。JDK1.6默认是开启了自旋锁功能，而且对自旋次数也不在是固定值，而是通过一套优化机制进行自适应，简化了对自旋锁的使用。</p><p>注意：自旋在多处理器上才有意义，这理解也很简单：自旋是不会释放CPU资源的，在单处理器上如果某个线程处于自旋状态，也就意味着没有其它线程处于同时处于运行状态，也就在自旋期间不可能存在线程释放锁资源。所以，单处理上自旋是没有意义的，不过现在服务器一般不可能运行在单处理器上。</p></blockquote><p> 5、如何膨胀为重量级锁呢？<br>​ a.步骤4中在自旋模式下依然无法获取锁，即会膨胀为重量锁<br>​ b.首先当前线程会修改Obj对象头中锁标志位，由代表轻量级锁的00修改成代表重量级锁的10，然后当前线程进入休眠模式，当然了再进入休眠模式之前还会进行一些操作，这里先这么理解，后面分析重量锁时具体流程再分析说明<br>​ c.当持有Obj对象偏向锁的线程执行完同步方法后，会通过一次CAS原子操作将对象头中的MarkWord由当前栈帧中的Lock Record进行重置回之前内容，如果重置成功，则释放锁完成；但是，根据上步骤我们知道，由于当前已膨胀为重量级锁，导致Obj对象的MarkWord中的锁标志位已被修改，CAS重置对象头操作会失败，这时就会感知到：在偏向锁运行期间，存在了其它线程竞争锁资源情况，当前锁已被膨胀为重量级锁，所以，在释放锁得到同时，会唤醒应等待该锁导致休眠的线程</p><p>轻量级锁是不支持”并发”，遇到”并发”就要膨胀为重量级锁。可能你会疑问：锁就是用来解决并发下资源同步问题，轻量级锁对“并发”都不支持要它能干什么呢？注意：此并发并非彼并发，这里的并发是带有引号的，即不存在锁竞争的并发。</p><p>轻量级锁在申请锁资源时通过一个CAS操作即可获取，释放锁资源时也是通过一个CAS操作即可完成，CAS是一种乐观锁的实现机制，其开销显然要比互斥开销小很多，这就是轻量级锁提升性能的核心所在。但是，轻量级锁只是对无锁竞争并发场景下的一个优化，如果锁竞争激烈，轻量级锁不但有互斥开销，还要多一次CAS开销，这是轻量级锁比重量级锁性能更差。所以，JVM检测到锁竞争时自动膨胀为重量级锁原因就在于此。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁优化了并发情况下串行化访问的场景，即下面示意图中的场景一，现在有个更极端情况：假如一段时间间隔内同步方法只会被同一个线程多次访问，即下面示意图中的场景二，从总体看同步方法是在单线程环境中运行。如果使用轻量级锁，每次调用同步方法要通过一次CAS操作申请锁，执行完后同样通过一次CAS操作释放锁，如下面场景二产生了7次调用共要执行14次CAS操作，还不包括其它开销。JVM工程师们对场景二进一步进行优化：只会在线程第一次调用同步方法时获取锁，执行完成后不去释放，后面该线程再次进入时不需要再次获取锁，直接进入，只有当其它线程申请锁时才会释放，因此，同样的场景二，偏向锁只会产生2次CAS操作。</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/偏向锁.png" alt=""></p><p>偏向锁的引入，主要是JVM工程师们经过研究发现：在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁的代价而引入偏向锁。偏向锁是对轻量级锁的进一步优化，轻量级锁优化了并发时串行化执行的场景，而偏向锁是对并发时”单线程”场景的优化。</p><p>默认JVM是开启偏向锁特性，但是默认JVM启动后的的头4秒钟这个feature是被禁止的，这也意味着在此期间，prototype MarkWord会将它们的bias位设置为0，以禁止实例化的对象被偏向。4秒钟之后，所有的prototype MarkWord的bias位会被重设为1，如此新的对象就可以被偏向锁定了，当然也可以通过如下方式缩短这个延迟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure><p>偏向锁的MarkWord信息如下：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/偏向锁MarkWord.png" alt=""></p><p><strong>批量重偏向&amp;批量撤销</strong></p><p>存在如下两种情况：<br>​ 1、对于存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列，生产者线程获得了偏向锁，消费者线程再去获得锁的时候，就涉及到这个偏向锁的撤销(revoke)操作，而这个撤销是比较昂贵的，而且在多生产者、多消费者情况下，这种状况更加糟糕，而且可能程序中使用了大量的这种队列，解决方案就是：识别出这些对象并禁止它们使用偏向锁特性；<br>​ 2、还存在这样对象集，它们偏向的线程并不合适，但是重新偏向另外线程确实合适的，例如线程t1初始化了大量对象obj，然后对每个对象执行了用于初始化的同步方法，这样导致这组对象集偏向锁中的threadID都指向了t1，但是如果另外一个线程开始真正指向obj对象集上的同步方法，这就导致了大量偏向锁的revoke操作</p><p>怎么判断对象是否适合偏向锁呢？解决方案是：jvm采用以class类为单位的做法，其内部为每个类维护一个偏向锁计数器，对其对象进行偏向锁的撤销操作进行计数。当这个值达到指定阈值的时候，jvm就认为这个类的偏向锁有问题，需要进行重偏向（rebias），对所有属于这个类的对象进行重偏向的操作叫批量重偏向（bulk rebias）。</p><blockquote><p>之前的做法是对heap进行遍历，但是这种实现方式如果堆增加到很大时是会存在性能问题的，后来便引入epoch。Class实例中包含了MarkWord原型–mark_prototype属性，该属性中的bias决定了该类型的对象是否允许被偏向锁定，与此同时，当前的epoch位也被保留在mark_prototype中。当需要bulk rebias时，对这个类的epcho值加1，以后分配这个类的对象的时候mark字段里就是这个epoch值了，同时还要对当前已经获得偏向锁的对象的epoch值加1，当然是在线程处于安全点时停止线程执行更新。对于那些正在运行且持有偏向锁的线程，由于没法更新导致对象头中的epoch和mark_prototype的epoch值不匹配，即偏向锁状态失效，下一个试图获取锁对象的线程使用原子CAS指令可将该锁对象绑定于当前线程。</p></blockquote><p>偏向撤销(revoke)：如果一个新线程申请偏向锁，发现该对象已经处于偏向锁状态，就会去判断epoch是否有效且线程ID是否指向自己，如果无效或线程ID并没有指向自己，需要让偏向锁撤销并重新偏向自己。在重新偏向自己之前，还回去判断之前线程是否还在运行，如果还在运行是否还在继续使用锁，如果还在继续使用锁则产生锁竞争，偏向锁会被膨胀为轻量级锁，否则，新线程通过CAS原子操作将对象头中的线程ID重新偏向新线程。</p><p>批量重偏向导致对象头中的线程ID指向被重置为null，即线程重新通过CAS操作获取偏向锁。简单理解：批量重偏向是对当前类型下的对象偏向锁的一次校正，因为当前该类型的偏向锁存在大量的revoke被JVM判定是存在问题的偏向锁，批量重偏向后这个类的revoke计数器会被重置，如果这个类的revoke计数器继续增加到一个阈值，可能会继续进行一次批量重偏向，也可能不再继续批量重偏向，就这样继续1到多次批量重偏向后，jvm就认为这个类不适合偏向锁了，就要进行批量撤销(bulk revoke)，将该类的Class的mark_prototype中的bias属性设置成0，表示该类型下所有对象不允许被偏向锁定，同时将已存在的偏向锁膨胀为轻量级锁。</p><p>在批量重偏向(bulk rebias)的操作中，prototype的epoch位将会被更新；在批量吊销(bulk revoke)的操作中，prototype将会被置成不可偏向的状态——bias位被置0。</p><p>下面通过如下同步代码块分析下偏向锁实现的大致流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 1、检测对象类型class中的bias设置是否允许偏向锁特性，只有开启此特性才能使用偏向锁<br>​ 2、检测Obj对象头中MarkWord锁标识位等于01，代表无锁状态或已处于偏向锁状态，否则不能进行偏向锁设置；<br>​ 3、检测Obj对象头中MarkWord偏向标识位，如果等于0，表示当前对象处于无锁状态，通过一次CAS原子操作将对象头线程ID设置成当前线程ID，设置成功则获取偏向锁成功<br>​ 4、检测对象头中MarkWord偏向标识位，如果等于1表示当前已处于偏向锁状态，然后检测MarkWord中的线程ID是否等于当前线程ID，不等于则进入步骤(5)，等于会再进行判断epoch是否等于Obj类型的Class实例中的epoch，不等于说明该偏向锁失效，进入步骤(5)，等于则表明获取偏向锁成功，进入同步方法<br>​ 5、监测偏向锁指向的线程是否还在运行，没有运行则执行步骤(6)，否则继续判断该线程是否还在持有锁，如果没有持有则执行步骤(6)，如果线程还在持有锁，则说明产生了锁竞争，会在持有偏向锁线程运行到全局安全点（这个时间点上没有正在执行的代码）时挂起运行线程，并将偏向锁膨胀为轻量级锁<br>​ 6、使用CAS原子操作将对象头MarkWord中的线程ID设置成当前线程ID</p><p>偏向锁的核心思想是，锁不存在多线程竞争，且一个线程获取锁后接下来继续获取该锁的概率更大，可见偏向锁模式下线程是不会主动去释放偏向锁，只有其它线程来竞争该偏向锁时才会考虑撤销或膨胀。偏向锁解决了一次CAS操作可以实现任意多次调用，节省了每次调用申请锁、释放锁性能消耗，避免了轻量级锁产生大量的CAS操作导致的性能消耗，从而提升锁性能。和轻量级锁一样，偏向锁并不能解决锁竞争问题，一旦遇到锁竞争偏向锁就会膨胀为轻量级锁，轻量级锁也不能解决锁竞争问题，为什么不直接膨胀为重量级锁呢？如果锁竞争不是很激烈或者竞争时间非常短暂，前面介绍过轻量级锁有个自旋模式，可以通过自旋模式补救避免因偶然的误差导致直接膨胀为重量级锁。如果自旋模式也无法解决，说明说竞争可能确实激烈，轻量级锁也无能为力了，只能膨胀为重量级锁。</p><p>另外，偏向锁也不适合像生产者/消费者这种线程交替获取锁模式，这样可能会导致产生大量的偏向锁撤销和重偏向操作，得不偿失。</p><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>通过前面分析发现，无论是轻量锁还是偏向锁，都不能代替重量锁，都只是在无锁竞争或者竞争不是很激烈的情况下进行的一些性能优化，减少重量锁产生的性能消耗，并不能真正解决锁竞争问题。轻量锁和偏向锁都是重量锁的乐观并发优化，因为它们都是通过CAS原子操作尝试性获取锁，在锁竞争不是很激烈情况下，尝试性获取锁的概率当然就会很大，避免了由用户态切换到内核态，借助系统的Mutex Lock互斥锁实现线程协调的过程，但是一旦锁竞争激烈，还是需要借助于重量级锁特性才能解决。</p><p>synchronized的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么synchronized效率低的原因。</p><p>当锁被膨胀为重量级锁后，锁标识位会被设置成10，同时对象头会指向一个monitor对象，它会管理协调这些竞争锁资源的线程们。大致示意图如下：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/膨胀为重量级锁的流程.png" alt=""></p><p>流程如下：</p><p> 1、如果线程A执行Obj对象的同步方法，通过对象头查找到Monitor的位置，然后线程A会进入WaitQueue区域，该区域主要是用于存储所有竞争锁资源的线程，多个线程同时竞争锁资源，只会有一个线程竞争成功，其它线程就会存储到该区域中，该区域主要维护两个队列：<br>​ a.Contention List：所有请求锁的线程将被首先放置到该竞争队列中<br>​ b.Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List，这个设计一方面也是从性能方面考虑：Contention List在高并发场景下不断的有新线程加入该队列，并且存在多个线程同时操作Content List，所以要进行同步控制，如果锁释放时直接从Contention List获取线程显然存在并发访问问题。所以，Owner线程首先会从Contention List迁移出一批线程到Entry List中，锁资源释放时从Entry List中获取线程，一般都是将Entry List的head赋值给OnCheck，Entry List不会存在并发访问问题，因为只有Owner线程才会从Entry List中提取数据，且也只有Owner才能从Contention List迁移线程到Entry List中，所以性能更好，只有等Entry List使用完为空时，Owner线程会再次从Contention List迁移一批线程放入到Entry List中</p><p> 2、Ready Thread区域主要是存储下一个可以参与竞争锁资源的线程，等锁资源释放时让OnCheck指向的线程参与锁竞争，OnCheck一般指向的是Entry List的head位置。注意：等待队列中只会有一个线程参与竞争，一般是FIFO方式参与竞争，避免所有等待线程一起竞争锁资源造成性能问题。</p><blockquote><p>OnCheck要竞争锁资源，而不是将Owner的锁资源直接传递给OnCheck线程，OnCheck只代表有资格竞争锁资源的线程，竞争锁资源就意味着可能会失败，失败就意味着这是一种非公平锁的实现机制。到底哪些线程会和OnCheck线程竞争锁资源呢？就是当前新加入申请锁资源的线程们，因为我们知道，只有申请锁资源失败的线程才会放入到Contention List，现在假如新加入的线程还在刚申请，走了狗屎运这时刚好Owner线程释放了锁资源，这就导致了这些新加入线程会和OnCheck一起竞争锁资源，这些新加入的线程可能优先竞争到锁资源，这就是非公平性的体现。这么做主要是从性能方面考虑，毕竟新线程如果竞争失败要做一大堆初始化工作然后放入到等待队列Contention List中，而OnCheck线程竞争失败只需要重新阻塞即可，显然工作量要小很多。但是，进入等待队列中的线程基本上是按照先进先出FIFO策略获取到锁资源的，因此，这种机制只会牺牲一定的公平性。另外，至少OnCheck线程还可以参与竞争，而不是从性能考虑直接让新线程获取到锁，避免等待队列中线程饿死现象。这里的实现和之前分析的ReentrantLock的思想基本一致，可以参考之前ReentrantLock实现机制加深对这块的理解。</p></blockquote><p> 3、Running Thread区域主要是存储当前获取到锁后正在运行的线程，使用Owner指向当前运行线程</p><p> 4、Blocking Queue区域主要是存储那些获取到锁资源但是调用wait等方法被阻塞的线程，由于wait操作会释放当前锁，即Owner会被重置为null，当前线程进入WaitSet中，同时OnCheck线程参与锁竞争获取锁资源，等被阻塞的线程被唤醒后会被移入Entry List重新等待获取锁资源</p><blockquote><p>只有获取到某个对象的锁时才能调用该对象的wait()让当前线程挂起，也就是如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">&gt;   <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">&gt;     obj.wait();</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>></p><blockquote><p>也就是只有获取obj对象的锁才能调用obj.wait()让当前线程挂起到obj对象上，同样唤醒该对象时也只有先获取obj锁时才能调用obj.notify()或obj.notifyAll()唤醒obj对象上阻塞的线程。这种设计是如何实现的呢？通过这里对Monitor结构的分析，你可能很容易就想到：<br>​ 1、Monitor是线程私有的，也就是只会被当前锁资源持有线程就是Monitor对象的拥有者，即Owner指向的线程<br>​ 2、只有Monitor的拥有者才能调用wait()方法释放监视锁，该线程进入阻塞队列，其它竞争锁资源新线程重新拥有Monitor线程<br>​ 3、同理，只有Monitor拥有者才能调用notify()/notifyAll()，这时会从Blocking Queue队列中将阻塞线程移入到Entry List，等待重新获取锁<br>​ 4、wait()、notify()和notifyAll()都是只有Monitor的拥有者线程才能调用，而Monitor的拥有者线程就是当前持有obj对象锁的线程</p></blockquote><p>多个线程竞争锁资源借助底层系统的Mutex Lock互斥锁实现，需要由用户态切换到内核态，由内核协调哪个线程获取到锁，哪些线程无法获取到锁，获取锁失败的线程会被内核进行阻塞，线程阻塞才能释放CPU资源。系统执行完后，会由内核态重新切换到用户态，将CPU的控制权交给获取锁的线程进行执行。</p><blockquote><p>内核切换属于操作系统范畴，想了解的可以自行搜索资料学习。这里大致简单描述下：<br>​ 1、程序经过编译最终会被翻译成机器指令进行执行<br>​ 2、如果程序执行的是“1+1”这种简单指令，CPU获取到这个指令后直接执行加操作即可，这时CPU处于用户态下，相当于用户进程调用CPU执行指令<br>​ 3、但是如果程序执行的是读取外围设备IO、线程休眠、线程唤醒等操作，这种操作涉及到用户无法访问内存某些区域，出于安全考虑，用户进程需要将CPU的控制权交由内核，由内核代替用户进行执行这些操作，这就是用户态向内核态切换，内核代替用户执行完这些敏感指令后，然后再将CPU控制权重新交给用户进程，用户进程获得CPU控制权后继续执行后续指令，你可以简单认为：处于内核态时，CPU可以执行更多操作指令<br>​ 4、你会发现，涉及到内核切换一般至少要切换两次，即：由用户态切换到内核态，将CPU控制权交给内核，内核执行完后，再由内核态切换到用户态，用户进程重新获取CPU控制权继续向下执行，内核切换还是比较耗费性能的，所以，synchronized底层优化才会出现偏向锁、轻量级锁等</p></blockquote><p>JVM中通过对象监视器Monitor实现重量级锁，也大致了解了Monitor结构，对Monitor进一步抽象可以总结为：其核心就是两个队列，竞争锁队列和信号阻塞队列，前者用于线程互斥，后者用于线程协调。</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/Monitor.png" alt=""></p><p>上图非常形象生动的描述了Monitor本质，图中圆圈代表线程， 左边区域是竞争锁的线程排队区域，简称等待区，右边是曾经获取过锁由于wait()等操作导致线程挂起锁被剥夺排队区域，简称阻塞区，它们中的线程都拼命的争夺进入中心舞台的入场券，而且这张入场券只有一张，这就导致中心舞台只能同时容纳一个线程，当中心区域的线程任务执行完成后，退出时会把它持有的入场券交出来，此时，等待区和阻塞区中的线程又开始竞争，如此往复。</p><h4 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h4><p>JVM底层实现synchronized同步时依赖的偏向锁、轻量级锁和重量级锁的大致原理也分析完成了，还记得轻量级锁中对象头指向Lock Record和重量级锁中对象头指向Monitor，可能你会比较好奇它们之间有什么区别吗？这里我试着总结下，主要区别如下：<br>​ 1、Lock Record存储在线程栈的栈帧中，如果你了解栈帧应该知道，栈帧代表的是一个方法调用，当方法调用完成，该栈帧也会从栈中出栈，因此，如果线程执行完同步方法后释放锁时Lock Record也就不复存在了，这时的对象头会被恢复至之前的MarkWord内容，可以说Lock Record是线程独有的；<br>​ 2、Monitor是线程私有，Monitor中Owner指向的线程就是Monitor的拥有者，注意这里的线程私有和上面Lock Record线程独有是有区别的：Lock Record随线程同步方法执行完成会被销毁，新线程获得锁后继续在自己的线程栈的栈中重新创建一个Lock Record，并让对象头指向自己即获得锁；而Monitor拥有者在进行锁释放时，是不会销毁Monitor对象的，而只会把Monitor中的Owner重置为null，表示当前没有线程持有锁，然后其它线程竞争锁资源，竞争成功的线程会被设置到Owner上，Monitor不会随着线程执行完同步方法而被销毁，这就表明Monitor不可能存储在线程栈中，而是存储在堆上；<br>​ 3、Lock Record和Monitor在释放锁时的行为也存在很大差别：Lock Record释放锁时会被销毁，对象头会被重置为之前的MarkWord内容，然后有新线程申请锁时会重新创建Lock Record让对象头指向，而Monitor释放锁时，只会把Monitor中的Owner重置为null，也就是说Monitor释放锁时对象头是不会变化的<br>​ 4、Monitor结构明显比Lock Record复杂，Lock Record主要保存对象头的MarkWord信息，<strong>由于结构太过简单导致Lock Record没法维护由于锁竞争导致的等待线程，最多也就是让它们自旋几下，并没有存储它们的区域，这就是轻量级锁无法解决锁竞争问题的本质</strong>。Monitor不但要保存对象头的MarkWord信息，还要使用队列维护等待线程和阻塞线程，因此，产生锁竞争时只能用重量级锁处理。另外，Lock Record结构简单才可以每次释放锁时销毁，申请锁时重新创建，而Monitor创建代价大的多，所以，一旦对象膨胀为重量级锁，初始化完Monitor后会被对象头一直指向该Monitor<br>​ 5、由于重量级锁维护着复杂的Monitor结构，同时还要使用底层系统的Mutex Lock导致用户态/内核态之间的多次切换对性能的损耗，所以才出现偏向锁，轻量级锁优化在锁竞争不激烈时的性能，情不得已时才会启用重量级锁</p><p>锁是并发编程中非常重要的一个内容，解决了高并发场景下非原子操作导致的状态不一致问题，通过上篇博文<a href="https://blog.reactor.top/2018/01/31/并发编程锁之ReentrantLock总结/"> 《并发编程锁之ReentrantLock总结》</a>及这篇博文，已经对Java中锁的两种主要实现机制进行大致的分析，再去理解<strong>偏向锁、轻量级锁、重量级锁、自旋锁、重入锁、悲观锁、乐观锁</strong>等一堆曾经困扰我很久的锁概念时，可以非常清晰的、简明扼要的表达出它们之间的本质区别。</p><p>偏向锁、轻量级锁、重量级锁都是JVM底层实现synchronized同步时引入的概念，最开始synchronized采用的是重量级锁机制实现，采用复杂的Monitor锁+底层系统Mutex Lock，由于太过复杂的Monitor结构和频繁的用户态/内核态间的切换导致性能不足，JVM工程师们在JDK1.6版本中引入了偏向锁、轻量级锁对重量级锁进行优化。</p><p>偏向锁和轻量级锁都是解决无锁竞争场景下锁的性能问题，因为它们都无法维护由于锁竞争导致的线程等待问题，所以遇到锁竞争就懵逼了，还是只能用重量级锁来处理。首先来看下轻量级锁，主要是解决线程间交替访问同步块问题，由于是线程交替访问而不是同时访问，所以并不会产生锁竞争，就没有必要使用笨重的重量级锁；再来看下偏向锁，偏向锁就更极端了，偏向锁认为不但没有锁竞争，而且在一段时间t1内都是线程A访问同步块，另一段时间t2内都是另一个线程B访问同步块，这样t1时间段内线程A通过一次CAS获取锁后，即使访问完同步块也不用去释放锁，不管线程A调用同步块多少次，都只需要第一次调用时申请锁，后面通过简单的判断直接进入，用完后即可离开，不需考虑锁申请和释放的问题，直到时间t2线程B过来访问，这时会把锁重偏向到线程B即可。</p><p><strong>偏向锁锁解决的是一个周期内“单线程”访问共享资源问题，连CAS操作都是能节省就尽量节省，轻量级锁解决的是一个周期内多线程交替访问共享资源问题，使用CAS操作消除底层系统的互斥，而重量级锁解决的是一个周期内同时访问共享资源问题，需要管理等待线程以及依赖于底层系统互斥指令。</strong></p><p>再来说说自旋锁，自旋锁不是锁的种类，而是锁的一项特性，如同重入锁一样，自旋的目的无非是优化性能，比如轻量级锁膨胀为重量级锁及ReentrantLock在真正进入休眠之前都会进行自旋，因为一旦轻量级锁膨胀为重量级锁或ReentrantLock中的线程进入休眠状态，对锁的性能都会造成很大的影响，自旋是为了极力挽救避免锁进入更糟糕的情况。但是自旋也会带来一个问题，自旋状态下会一直占用CPU资源，如果长时间无法获取锁而一直自旋下去，对系统资源造成很大的浪费，但是到底自旋多久比较合适呢，这还真是一个比较难拿捏的问题，好在JDK已经引入了自适应自旋，JVM会根据它的监控统计信息进行优化，自动动态的计算出自旋的周期，而不再简单的一个固定值。另外，自旋锁在单核系统下是没有意义的，因为自旋线程占用了CPU希望其它线程尽快释放锁才好结束自旋，其它持有锁的线程由于无法获取到CPU资源所以在自旋期间不可能获取到锁，但是现在一般不可能是单核系统，所以，JDK已经默认开启了自旋特性。</p><p>重入锁也是锁的一项特性，而非种类，其实Java中的锁基本都是重入锁，不可重入性锁会导致自己锁死自己的问题，而且出现一旦锁死再也无法解锁的严重问题，重入锁就是线程获取锁期间可以继续获取该锁，主要是通过在锁中设置一个计数器count，用于统计重入次数，同理在释放锁时，只有释放同样次数情况下才可能完全释放锁。重入锁的代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;<span class="comment">//synchronized方法已保证进入方法中线程已经获取到当前对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//这里再次获取当前对象锁，而且会成功，这就是重入锁特性</span></span><br><span class="line">            System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再来看下乐观锁和悲观锁，这是从另一个维度对锁进行的分类，乐观锁、悲观锁与具体编程语言无关，基本所有的编程语言以及涉及到并发编程的系统中都会存在悲观锁和乐观锁，比如redis、oracle、elasticsearch等中都存在悲观锁和乐观锁的身影。乐观锁借助系统的原子性指令，对共享资源进行操作，即其在操作前并不会加锁控制同步块，而是乐观认为不会存在锁竞争所以没必要加锁，但是一旦操作失败就表示出现了锁竞争，乐观锁一般通过多次自旋方式进行多次尝试，直到操作成功，具体可以参看ReentrantLock源码中CAS+无限循环方式，这就是典型的乐观锁在Java中的实现。而悲观锁有如其名，悲观的认为操作一定会出现多线程竞争导致的同步问题，所以在对同步块操作之前，先锁起来，只有自己能操作共享资源，其它线程此时是无法访问共享资源的，这种控制多线程串行化访问共享资源方式虽然解决了线程安全问题，但是效率肯定是不高的。<strong>乐观锁在竞争不是太激烈的情况下，性能一般是高于悲观锁的，但是一旦在高并发下多线程竞争激烈，由于乐观锁失败的概率增加从而乐观锁不断尝试获取锁导致效率降低，性能反而可能会低于悲观锁，但在一般的生产中，大多数线程都是竞争不太激烈的情况，所以乐观锁的使用概率还是非常大的</strong>。</p><p>偏向锁和轻量级锁都是借助于CAS操作完成，可以理解为是乐观锁的一种实现，而重量级锁借助于底层系统互斥，可以看成是悲观锁的实现。</p><p>回过头来，对比synchronized和ReentrantLock实现机制，会发现它们在很多实现思想上如出一辙，虽然它们实现方式不一样，只有提炼出它们的设计思想才能掌握它们的核心本质，同时提升对并发编程的驾驭能力。</p><hr><blockquote><p><strong>本文作者：</strong> zhang</p><p><strong>本文链接：</strong> <a href="http://blog.reactor.top/2018/02/07/并发编程锁之synchronized总结/">http://blog.reactor.top/2018/02/07/并发编程锁之synchronized总结/</a></p><p><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Java" scheme="https://jinyu.host/tags/Java/"/>
    
    <category term="锁" scheme="https://jinyu.host/tags/%E9%94%81/"/>
    
    <category term="并发" scheme="https://jinyu.host/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="多线程" scheme="https://jinyu.host/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows部署minio注册成服务在后台保持运行</title>
    <link href="https://jinyu.host/2020/08/29/22b43cc2-387b-4368-9c70-50044bac3d50/"/>
    <id>https://jinyu.host/2020/08/29/22b43cc2-387b-4368-9c70-50044bac3d50/</id>
    <published>2020-08-29T00:23:16.000Z</published>
    <updated>2020-08-29T00:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在使用minio做资源存储，要求把minio部署到wondows上使用，发现官方提供的运行命令：.\minio.exe server .\data运行后，关闭cmd窗口，服务就会关闭</p><p><strong>所以需要通过winsw注册服务的方式，把minio注册成服务运行</strong></p><h2 id="WinSW下载配置："><a href="#WinSW下载配置：" class="headerlink" title="WinSW下载配置："></a>WinSW下载配置：</h2><ol><li>地址：<a href="https://github.com/winsw/winsw/releases">https://github.com/winsw/winsw/releases</a></li><li>将WinSW.exe复制到自定义的目录，并重命名为自己想命名的服务名称minio-server.exe</li><li>同目录下创建minio-server.xml，<strong>特别注意</strong>，xml和exe必须同名</li><li>配置minio-server.xml文件</li><li>使用minio-server.exe install安装服务</li><li>安装完后，去服务中启动服务，启动成功就可以正常使用minio啦</li><li>使用minio-server.exe uninstall卸载服务</li></ol><h2 id="具体配置："><a href="#具体配置：" class="headerlink" title="具体配置："></a>具体配置：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>minio-server<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>minio-server<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>minio文件存储服务器<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可设置环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">&quot;HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%BASE%&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executable</span>&gt;</span>%BASE%\minio.exe<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arguments</span>&gt;</span>server &quot;%BASE%\data&quot;<span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;logmode&gt;rotate&lt;/logmode&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logpath</span>&gt;</span>%BASE%\logs<span class="tag">&lt;/<span class="name">logpath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log</span> <span class="attr">mode</span>=<span class="string">&quot;roll-by-size-time&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sizeThreshold</span>&gt;</span>10240<span class="tag">&lt;/<span class="name">sizeThreshold</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>yyyyMMdd<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">autoRollAtTime</span>&gt;</span>00:00:00<span class="tag">&lt;/<span class="name">autoRollAtTime</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">zipOlderThanNumDays</span>&gt;</span>5<span class="tag">&lt;/<span class="name">zipOlderThanNumDays</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">zipDateFormat</span>&gt;</span>yyyyMMdd<span class="tag">&lt;/<span class="name">zipDateFormat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">log</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zys-blog/p/13164197.html" title="原文链接 https://www.cnblogs.com/zys-blog/p/13164197.html">原文链接 https://www.cnblogs.com/zys-blog/p/13164197.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Minio" scheme="https://jinyu.host/tags/Minio/"/>
    
    <category term="Windows" scheme="https://jinyu.host/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>The username you provided is not allowed to use the text-based Tomcat Manager (error 403)</title>
    <link href="https://jinyu.host/2020/08/29/3da6888a-b6ff-4cc7-a3cf-e40efbb943d5/"/>
    <id>https://jinyu.host/2020/08/29/3da6888a-b6ff-4cc7-a3cf-e40efbb943d5/</id>
    <published>2020-08-29T00:16:49.000Z</published>
    <updated>2020-08-29T00:16:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-背景及现象"><a href="#1-背景及现象" class="headerlink" title="1.背景及现象"></a>1.背景及现象</h2><p>在配置Jenkins的自动部署功能，手动构建时报“The username you provided is not allowed to use the text-based Tomcat Manager (error 403)”错误，如图：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/The username you provided is not allowed to use the text-based Tomcat Manager (error 403" alt="">.jpg)</p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h2><p>用于tomcat7自动部署的管理用户必须具有manager-script角色,manager-gui角色是不够的，不然会有错误出现：<br>The username you provided is not allowed to use the text-based Tomcat Manager (error 403)<br>在/etc/tomcat7/tomcat-users.xml文件中为管理用户添加manager-script角色即可。</p><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法"></a>3.解决方法</h2><ol><li><p>进入到tomcat的conf目录下，编辑tomcat-users.xml配置文件</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/tomcat manager-script.png" alt=""></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;tomcat&quot;</span> <span class="attr">password</span>=<span class="string">&quot;tomcat&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;admin-gui,manager-gui,manager-script&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>进入到tomcat的webapps/manager/META_INF/context.xml文件，将文件中对访问的来源受限设置注释</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">antiResourceLocking</span>=<span class="string">&quot;false&quot;</span> <span class="attr">privileged</span>=<span class="string">&quot;true&quot;</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!--注释掉此代码--&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span></span><br><span class="line"><span class="comment">         allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Manager</span> <span class="attr">sessionAttributeValueClassNameFilter</span>=<span class="string">&quot;java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>重启tomcat，再次构建即可</li></ol><p><a href="https://www.cnblogs.com/wanghy898/p/11257574.html" title="原文链接 https://www.cnblogs.com/wanghy898/p/11257574.html">原文链接 https://www.cnblogs.com/wanghy898/p/11257574.html</a></p><p><a href="https://blog.csdn.net/Jay_1989/article/details/52861620?utm_source=blogxgwz2" title="原文链接 https://blog.csdn.net/Jay_1989/article/details/52861620?utm_source=blogxgwz2">原文链接 https://blog.csdn.net/Jay_1989/article/details/52861620?utm_source=blogxgwz2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="错误日志" scheme="https://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Tomcat" scheme="https://jinyu.host/tags/Tomcat/"/>
    
    <category term="Jenkins" scheme="https://jinyu.host/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Build step &#39;Invoke top-level Maven targets&#39; marked build as failure Finished</title>
    <link href="https://jinyu.host/2020/08/29/c49478bb-79a0-4a4c-91b4-fca9116bdfcd/"/>
    <id>https://jinyu.host/2020/08/29/c49478bb-79a0-4a4c-91b4-fca9116bdfcd/</id>
    <published>2020-08-29T00:03:11.000Z</published>
    <updated>2020-08-29T00:03:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Jenkins部署项目时，调用maven打包时报错：</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/Build step &#39;Invoke top-level Maven targets&#39; marked build as failure Finished.png" alt=""></p><p>猜想是运行jenkins的Tomcat内存溢出导致，修改bin/catalina.sh，加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-Xms256m -Xmx512m -Xss1024K -XX:PermSize=128m -XX:MaxPermSize=256m&quot;</span><br></pre></td></tr></table></figure><p>重启Tomcat，再次构建，问题解决</p><p><a href="https://blog.csdn.net/shenjuntao520/article/details/103048287" title="原文链接 https://blog.csdn.net/shenjuntao520/article/details/103048287">原文链接 https://blog.csdn.net/shenjuntao520/article/details/103048287</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="错误日志" scheme="https://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="Jenkins" scheme="https://jinyu.host/tags/Jenkins/"/>
    
    <category term="Maven" scheme="https://jinyu.host/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins + Gitee搭建持续集成环境</title>
    <link href="https://jinyu.host/2020/08/29/76a9a626-f1df-4341-8f60-56f760ddd3fd/"/>
    <id>https://jinyu.host/2020/08/29/76a9a626-f1df-4341-8f60-56f760ddd3fd/</id>
    <published>2020-08-28T21:33:05.000Z</published>
    <updated>2020-08-28T21:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-前置环境"><a href="#1-前置环境" class="headerlink" title="1.前置环境"></a>1.前置环境</h2><ul><li>Java环境</li><li>Tomcat</li></ul><h2 id="2-下载并部署jenkins的war包"><a href="#2-下载并部署jenkins的war包" class="headerlink" title="2.下载并部署jenkins的war包"></a>2.下载并部署jenkins的war包</h2><ul><li><p>下载jenkins.war</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war</span><br></pre></td></tr></table></figure></li><li><p>将下好的jenkinx.war放在tomcat下的webapps，重启tomcat</p></li><li><p><code>ip:8080/jenkins</code>即可访问</p></li></ul><h2 id="3-修改default-json以加快插件下载速度"><a href="#3-修改default-json以加快插件下载速度" class="headerlink" title="3.修改default.json以加快插件下载速度"></a>3.修改default.json以加快插件下载速度</h2><p>出现Unlock Jenkins页面时关闭tomcat，然后编辑jenkins的default.json</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.jenkins/updates/default.json</span><br></pre></td></tr></table></figure><p>替换<code>updates.jenkins-ci.org/download</code>为<code>mirrors.tuna.tsinghua.edu.cn/jenkins</code></p><p>然后把www.google.com修改成www.baidu.com</p><blockquote><p>此处为已经改好的<a href="http://jinyu.host:8888/group1/M00/00/00/rBkeyl9KFniADg-lACsTVa4Ef0A58.json" title="default.json">default.json</a>，覆盖原文件即可</p></blockquote><p>修改好default.json后重启tomcat</p><h2 id="4-配置jenkins"><a href="#4-配置jenkins" class="headerlink" title="4.配置jenkins"></a>4.配置jenkins</h2><h3 id="4-1-登录"><a href="#4-1-登录" class="headerlink" title="4.1.登录"></a>4.1.登录</h3><p>默认admin密码在<code>~/.jenkins/secrets/initialAdminPassword</code></p><h2 id="4-2-插件配置"><a href="#4-2-插件配置" class="headerlink" title="4.2.插件配置"></a>4.2.插件配置</h2><p>选择推荐安装插件，之后进入jenkins界面后，点击系统管理 -&gt; 插件管理 -&gt; 可选插件，搜索gitee，安装后重启jenkins；</p><p>系统管理 -&gt; 系统配置 -&gt; Gitee配置：</p><ul><li>链接名：自定义</li><li>Gitee 域名 URL：<a href="https://gitee.com">https://gitee.com</a></li><li>证书令牌：根据提示添加令牌</li></ul><p>系统管理 -&gt; 全局工具配置：</p><ul><li>添加Maven配置</li><li>添加JDK</li><li>添加Maven</li></ul><h2 id="5-新建任务"><a href="#5-新建任务" class="headerlink" title="5.新建任务"></a>5.新建任务</h2><ul><li>构建一个自由风格的软件项目</li></ul><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/jinyu-blog Config [Jenkins].png" alt=""></p><p><a href="https://www.cnblogs.com/Christine-ting/p/10501515.html" title="参考链接 https://www.cnblogs.com/Christine-ting/p/10501515.html">参考链接 https://www.cnblogs.com/Christine-ting/p/10501515.html</a></p><p><a href="https://blog.csdn.net/u013788943/article/details/103822785" title="参考链接 https://blog.csdn.net/u013788943/article/details/103822785">参考链接 https://blog.csdn.net/u013788943/article/details/103822785</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="Jenkins" scheme="https://jinyu.host/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>vim永久显示行号</title>
    <link href="https://jinyu.host/2020/08/28/44145d69-cff6-4517-adcc-a1e206614c4f/"/>
    <id>https://jinyu.host/2020/08/28/44145d69-cff6-4517-adcc-a1e206614c4f/</id>
    <published>2020-08-28T03:44:55.000Z</published>
    <updated>2020-08-28T03:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编辑vim个人配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure><p>添加<code>set nu</code>，保存退出</p><p><a href="https://blog.csdn.net/ouyang_peng/article/details/83379407" title="原文链接 https://blog.csdn.net/ouyang_peng/article/details/83379407">原文链接 https://blog.csdn.net/ouyang_peng/article/details/83379407</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="vim" scheme="https://jinyu.host/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装Minio存储服务器</title>
    <link href="https://jinyu.host/2020/08/28/09a7931e-a93b-47d2-a861-b15156bd132f/"/>
    <id>https://jinyu.host/2020/08/28/09a7931e-a93b-47d2-a861-b15156bd132f/</id>
    <published>2020-08-28T03:40:14.000Z</published>
    <updated>2020-08-28T03:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1.拉取镜像"></a>1.拉取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure><h2 id="2-启动与安装镜像"><a href="#2-启动与安装镜像" class="headerlink" title="2.启动与安装镜像"></a>2.启动与安装镜像</h2><h3 id="2-1-普通安装"><a href="#2-1-普通安装" class="headerlink" title="2.1.普通安装"></a>2.1.普通安装</h3><p>这种安装方式并没有指定 ACCESS_KEY 和 SECRET_KEY 进行设置，安装后可以进行 echo命令设置,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-it 表示运行参数，-p 表示暴露端口 ，-d 表示后台运行，data 指定目录存放文件</span></span><br><span class="line">docker run -it -p 9000:9000 -d minio/minio server /data</span><br></pre></td></tr></table></figure><p>echo 命令设置 ACCESS_KEY 和 SECRET_KEY</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;minio&quot;</span> | docker secret create access_key -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;minio&quot;</span> | docker secret create secret_key -</span><br></pre></td></tr></table></figure><h3 id="2-2-自定义用户和秘钥安装"><a href="#2-2-自定义用户和秘钥安装" class="headerlink" title="2.2.自定义用户和秘钥安装"></a>2.2.自定义用户和秘钥安装</h3><p>这种安装方式 MinIO 自定义 Access 和 Secret 密钥要覆盖 MinIO 的自动生成的密钥，您可以将 Access 和 Secret 密钥设为环境变量。MinIO 允许常规字符串作为 Access 和 Secret 密钥</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p <span class="number">9000</span>:<span class="number">9000</span> --name minio \</span><br><span class="line">-d --restart=always \</span><br><span class="line">-e <span class="string">&quot;MINIO_ACCESS_KEY=admin&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;MINIO_SECRET_KEY=admin123456&quot;</span> \</span><br><span class="line">-v /home/<span class="keyword">data</span>:/<span class="keyword">data</span> \</span><br><span class="line">-v /home/config:/root/.minio \</span><br><span class="line">minio/minio server /<span class="keyword">data</span></span><br></pre></td></tr></table></figure><h2 id="3-查看安装logs信息"><a href="#3-查看安装logs信息" class="headerlink" title="3.查看安装logs信息"></a>3.查看安装logs信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs minio</span><br></pre></td></tr></table></figure><p>minio安装的日志信息，其中AccessKey和SecretKey是登陆minio客户端的用户名和秘钥</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Endpoint: http:<span class="comment">//172.17.0.5:9000 http://127.0.0.1:9000</span></span><br><span class="line">AccessKey: <span class="number">4</span>RUAAMD4JVDTSYFZAIIU</span><br><span class="line">SecretKey: mn5fYWV2CPtENTS6XHQqRB+j+NNjI3w79qcdQ4VZ</span><br><span class="line">Browser Access:</span><br><span class="line">http:<span class="comment">//172.17.0.5:9000 http://127.0.0.1:9000</span></span><br><span class="line">Command-line Access: https:<span class="comment">//docs.min.io/docs/minio-client-quickstart-guide</span></span><br><span class="line">$ mc config host <span class="keyword">add</span> myminio http:<span class="comment">//172.17.0.5:9000 4RUAAMD4JVDTSYFZAIIU</span></span><br><span class="line">mn5fYWV2CPtENTS6XHQqRB+j+<span class="function">NNjI3w79qcdQ4VZ</span></span><br><span class="line"><span class="function">Object <span class="title">API</span> (<span class="params">Amazon S3 compatible</span>):</span></span><br><span class="line"><span class="function">Go: https:<span class="comment">//docs.min.io/docs/golang-client-quickstart-guide</span></span></span><br><span class="line"><span class="function">Java: https:<span class="comment">//docs.min.io/docs/java-client-quickstart-guide</span></span></span><br><span class="line"><span class="function">Python: https:<span class="comment">//docs.min.io/docs/python-client-quickstart-guide</span></span></span><br><span class="line"><span class="function">JavaScript: https:<span class="comment">//docs.min.io/docs/javascript-client-quickstart-guide</span></span></span><br><span class="line"><span class="function">.NET: https:<span class="comment">//docs.min.io/docs/dotnet-client-quickstart-guide</span></span></span><br></pre></td></tr></table></figure><h2 id="4-登录客户端"><a href="#4-登录客户端" class="headerlink" title="4.登录客户端"></a>4.登录客户端</h2><p>访问ip:9000即可</p><p><a href="https://www.jianshu.com/p/52dbc679094a" title="原文链接 https://www.jianshu.com/p/52dbc679094a">原文链接 https://www.jianshu.com/p/52dbc679094a</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Docker部署App" scheme="https://jinyu.host/categories/Docker%E9%83%A8%E7%BD%B2App/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="Docker" scheme="https://jinyu.host/tags/Docker/"/>
    
    <category term="Minio" scheme="https://jinyu.host/tags/Minio/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署Nacos-Server(单机版)</title>
    <link href="https://jinyu.host/2020/08/28/c23b6d6f-7386-4c4b-ad02-cc30b5f54f14/"/>
    <id>https://jinyu.host/2020/08/28/c23b6d6f-7386-4c4b-ad02-cc30b5f54f14/</id>
    <published>2020-08-28T02:23:23.000Z</published>
    <updated>2020-08-28T02:43:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>仅部署nacos-server,不使用prometheus/grafana等监控组件</p><p><strong>1. 拉取镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure><p><strong>2.启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker  run \</span><br><span class="line">--name nacos -d \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">-e JVM_XMS=256m \</span><br><span class="line">-e JVM_XMX=256m \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e PREFER_HOST_MODE=hostname \</span><br><span class="line">nacos/nacos-server</span><br></pre></td></tr></table></figure><p>3.<strong>进入容器修改配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it nacos bash</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd conf</span><br><span class="line">vim application.properties</span><br></pre></td></tr></table></figure><p>然后添加数据库的信息</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/nacos设置mysql.png" alt=""></p><p>保存退出后，在nacos设置的mysql中新建数据库nacos_config，然后执行<a href="http://jinyu.host:8888/group1/M00/00/00/rBkeyl9IbTWAUArEAAAppB5mbeI509.sql" title="nacos-mysql.sql">nacos-mysql.sql</a></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>通过docker-compose部署,包含prometheus/grafana等监控组件</p><p><strong>1.拉取仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/nacos-group/nacos-docker.git</span><br></pre></td></tr></table></figure><p><strong>2.运行docker-compose</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> nacos-docker</span><br><span class="line">docker-compose -f example/standalone-derby.yaml up -d </span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3d3e17bc629f" title="原文链接 https://www.jianshu.com/p/3d3e17bc629f">原文链接 https://www.jianshu.com/p/3d3e17bc629f</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Docker部署App" scheme="https://jinyu.host/categories/Docker%E9%83%A8%E7%BD%B2App/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="Docker" scheme="https://jinyu.host/tags/Docker/"/>
    
    <category term="Nacos" scheme="https://jinyu.host/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>使用js美化Markdown文档</title>
    <link href="https://jinyu.host/2020/08/28/7f6f748b-2b84-4ff0-b369-55169f13911e/"/>
    <id>https://jinyu.host/2020/08/28/7f6f748b-2b84-4ff0-b369-55169f13911e/</id>
    <published>2020-08-28T00:43:18.000Z</published>
    <updated>2020-08-28T00:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引入<a href="http://strapdownjs.com/">strapdown.js</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/sandstone/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmp</span> <span class="attr">theme</span>=<span class="string">&quot;sandstone&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--M↓文本--&gt;</span></span><br><span class="line">xxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xmp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://strapdownjs.com/v/0.2/strapdown.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主题的修改方式：打开上面的链接，strapdown.js中会有不同的主题，粘贴主题名并改为小写，复制到link标签的href（只需替换4.5.2和bootstrap.min.css中间的主题名）和xmp标签的theme即可；此例使用的主题为：sandstone</p><p><a href="https://zhuanlan.zhihu.com/p/37690583?native.theme=7" title="原文链接 https://zhuanlan.zhihu.com/p/37690583?native.theme=7">原文链接 https://zhuanlan.zhihu.com/p/37690583?native.theme=7</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Markdown" scheme="https://jinyu.host/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装zsh配置oh-my-zsh</title>
    <link href="https://jinyu.host/2020/08/28/98f43741-13b2-4b4c-8ea1-16da41826cc0/"/>
    <id>https://jinyu.host/2020/08/28/98f43741-13b2-4b4c-8ea1-16da41826cc0/</id>
    <published>2020-08-28T00:25:10.000Z</published>
    <updated>2020-08-28T00:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-查看当前shell"><a href="#1-查看当前shell" class="headerlink" title="1.查看当前shell"></a>1.查看当前shell</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/bash</span><br></pre></td></tr></table></figure><h2 id="2-安装zsh"><a href="#2-安装zsh" class="headerlink" title="2.安装zsh"></a>2.安装zsh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zsh</span><br></pre></td></tr></table></figure><h2 id="3-在root用户下设置zsh为默认shell"><a href="#3-在root用户下设置zsh为默认shell" class="headerlink" title="3.在root用户下设置zsh为默认shell"></a>3.在root用户下设置zsh为默认shell</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h2 id="4-zsh需要git支持"><a href="#4-zsh需要git支持" class="headerlink" title="4.zsh需要git支持"></a>4.zsh需要git支持</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><h2 id="5-安装oh-my-zsh"><a href="#5-安装oh-my-zsh" class="headerlink" title="5.安装oh-my-zsh"></a>5.安装oh-my-zsh</h2><p>自动安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>手动安装：</p><ol><li><p>下载源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure></li><li><p>复制配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-配置主题"><a href="#6-配置主题" class="headerlink" title="6.配置主题"></a>6.配置主题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>修改ZSH_THEME即可</p><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/zsh修改主题.png" alt=""></p><p><a href="https://www.jianshu.com/p/4ce7d511bc13" title="原文链接 https://www.jianshu.com/p/4ce7d511bc13">原文链接 https://www.jianshu.com/p/4ce7d511bc13</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="zsh" scheme="https://jinyu.host/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat访问路径去掉项目名</title>
    <link href="https://jinyu.host/2020/08/26/6af2baee-79c4-4f16-9e51-ca4a087f94b6/"/>
    <id>https://jinyu.host/2020/08/26/6af2baee-79c4-4f16-9e51-ca4a087f94b6/</id>
    <published>2020-08-25T20:30:19.000Z</published>
    <updated>2020-08-25T20:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>将项目重命名为ROOT.war，放入<code>tomcat/webapps</code>（不推荐）</p></li><li><p>修改<code>tomcat/conf/server.xml</code>：</p></li></ol><p><img src="https://gitee.com/jinyu52370/images/raw/master/images/tomcat修改访问路径.png" alt=""></p><p>docBase：项目实际路径</p><p>path：要修改成的访问路径</p><p><a href="https://blog.csdn.net/liyifan687/article/details/80040121" title="原文链接 https://blog.csdn.net/liyifan687/article/details/80040121">原文链接 https://blog.csdn.net/liyifan687/article/details/80040121</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="Tomcat" scheme="https://jinyu.host/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Linux修改hosts</title>
    <link href="https://jinyu.host/2020/08/23/c0a480fa-50af-4262-bc0d-a3ef51f36625/"/>
    <id>https://jinyu.host/2020/08/23/c0a480fa-50af-4262-bc0d-a3ef51f36625/</id>
    <published>2020-08-23T02:35:37.000Z</published>
    <updated>2020-08-23T02:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编辑hosts：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>添加需要的信息，保存后退出，然后重启hosts：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure><p>可以查看是否修改成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux开机自启应用</title>
    <link href="https://jinyu.host/2020/08/23/9f4e62c2-0112-429f-91c3-80b33e0d8586/"/>
    <id>https://jinyu.host/2020/08/23/9f4e62c2-0112-429f-91c3-80b33e0d8586/</id>
    <published>2020-08-23T01:46:03.000Z</published>
    <updated>2020-08-23T01:46:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="以tomcat为例"><a href="#以tomcat为例" class="headerlink" title="以tomcat为例"></a>以tomcat为例</h2><p>创建脚本<code>tomcat_start.sh</code>并编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chkconfig: 2345 80 90</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">description:tomcat_start.sh</span></span><br><span class="line">export JAVA_HOME=/@app/jdk1.8.0_221</span><br><span class="line">cd /@app/tomcat/bin</span><br><span class="line">nohup ./startup.sh</span><br></pre></td></tr></table></figure><p>　说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是指此脚本使用/bin/sh来解释执行</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2345表示系统运行级别是2，3，4或者5时都启动此服务，20，是启动的优先级，80是关闭的优先级，如果启动优先级配置的数太小时如0时，则有可能启动不成功，因为此时可能其依赖的网络服务还没有启动，从而导致自启动失败。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chkconfig: 2345 80 90</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">描述信息</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">description:tomcat_start.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定java环境变量</span></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_65</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入tomcat目录</span></span><br><span class="line">cd /usr/local/software/apache-tomcat-8.5.0/bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动脚本</span></span><br><span class="line">nohup ./startup.sh</span><br></pre></td></tr></table></figure><p><code>:wq!</code>保存退出后 使用<code>chmod</code>设置可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x tomcat_start.sh</span><br></pre></td></tr></table></figure><p>然后将其拷贝到/etc/init.d/目录下，否则添加服务不成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp tomcat_start.sh /etc/init.d/</span><br></pre></td></tr></table></figure><p>添加到系统服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add tomcat_start.sh</span><br></pre></td></tr></table></figure><p>设置开机启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig tomcat_start.sh on</span><br></pre></td></tr></table></figure><p>然后重启即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启之后连接查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/abcwanglinyong/article/details/84638125" title="原文链接 https://blog.csdn.net/abcwanglinyong/article/details/84638125">原文链接 https://blog.csdn.net/abcwanglinyong/article/details/84638125</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="Tomcat" scheme="https://jinyu.host/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>docker logs－查看docker容器日志</title>
    <link href="https://jinyu.host/2020/08/23/6ad8c6b0-7ee9-4b8f-9cfe-d422a0e2e0d0/"/>
    <id>https://jinyu.host/2020/08/23/6ad8c6b0-7ee9-4b8f-9cfe-d422a0e2e0d0/</id>
    <published>2020-08-22T21:26:17.000Z</published>
    <updated>2020-08-22T21:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="通过docker-logs命令可以查看容器的日志"><a href="#通过docker-logs命令可以查看容器的日志" class="headerlink" title="通过docker logs命令可以查看容器的日志"></a>通过<code>docker logs</code>命令可以查看容器的日志</h2><h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs [OPTIONS] CONTAINER</span></span><br><span class="line">  Options:</span><br><span class="line">        --details        显示更多的信息</span><br><span class="line">    -f, --follow         跟踪实时日志</span><br><span class="line">        --since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）</span><br><span class="line">        --tail string    从日志末尾显示多少行日志， 默认是all</span><br><span class="line">    -t, --timestamps     显示时间戳</span><br><span class="line">        --until string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）</span><br></pre></td></tr></table></figure><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>查看指定时间后的日志，只显示最后100行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f -t --since=<span class="string">&quot;2018-02-08&quot;</span> --<span class="built_in">tail</span>=100 CONTAINER_ID</span></span><br></pre></td></tr></table></figure><p>查看最近30分钟的日志:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs --since 30m CONTAINER_ID</span></span><br></pre></td></tr></table></figure><p>查看某时间之后的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -t --since=<span class="string">&quot;2018-02-08T13:23:37&quot;</span> CONTAINER_ID</span></span><br></pre></td></tr></table></figure><p>查看某时间段日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker logs -t --since=<span class="string">&quot;2018-02-08T13:23:37&quot;</span> --until <span class="string">&quot;2018-02-09T12:23:37&quot;</span> CONTAINER_ID</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/1eb1d1d3f25e" title="原文链接 https://www.jianshu.com/p/1eb1d1d3f25e">原文链接 https://www.jianshu.com/p/1eb1d1d3f25e</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Linux" scheme="https://jinyu.host/tags/Linux/"/>
    
    <category term="Docker" scheme="https://jinyu.host/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[ERR] 1273 - Unknown collation: &#39;utf8mb4_0900_ai_ci&#39;</title>
    <link href="https://jinyu.host/2020/08/20/dc1110f2-bfd5-46b3-96b5-6ff2d30291a8/"/>
    <id>https://jinyu.host/2020/08/20/dc1110f2-bfd5-46b3-96b5-6ff2d30291a8/</id>
    <published>2020-08-20T03:42:43.000Z</published>
    <updated>2020-08-21T02:34:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用navicate12运行sql文件出错</p><h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERR] 1273 - Unknown collation: &#x27;utf8mb4_0900_ai_ci&#x27;</span><br></pre></td></tr></table></figure><h2 id="报错原因："><a href="#报错原因：" class="headerlink" title="报错原因："></a>报错原因：</h2><p>生成转储文件的数据库版本为8.0,要导入sql文件的数据库版本为5.6,因为是高版本导入到低版本，引起1273错误</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>打开sql文件，将文件中的所有<code>utf8mb4_0900_ai_ci</code>替换为<code>utf8_general_ci</code>、<code>utf8mb4</code>替换为<code>utf8</code>保存后再次运行sql文件，运行成功</p><p><a href="https://blog.csdn.net/yinzitun7947/article/details/89917611" title="原文链接 https://blog.csdn.net/yinzitun7947/article/details/89917611">原文链接 https://blog.csdn.net/yinzitun7947/article/details/89917611</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="错误日志" scheme="https://jinyu.host/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="MySQL" scheme="https://jinyu.host/tags/MySQL/"/>
    
    <category term="Navicat" scheme="https://jinyu.host/tags/Navicat/"/>
    
  </entry>
  
  <entry>
    <title>Redlock（redis分布式锁）原理分析</title>
    <link href="https://jinyu.host/2020/08/20/28b38cee-8734-4732-8de7-47f9f99b3f13/"/>
    <id>https://jinyu.host/2020/08/20/28b38cee-8734-4732-8de7-47f9f99b3f13/</id>
    <published>2020-08-19T21:24:20.000Z</published>
    <updated>2020-08-19T21:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html" title="原文链接 https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html">原文链接 https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习日志" scheme="https://jinyu.host/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Redis" scheme="https://jinyu.host/tags/Redis/"/>
    
  </entry>
  
</feed>
